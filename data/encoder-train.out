_ , content_params = cgi . parse_header ( environ . get ( 'CONTENT_TYPE' , '' ) )
_ , file_ext = os . path . splitext ( self . file )
_ , params = cgi . parse_header ( content_disposition )
_ , rest = token . contents . split ( None , 1 )
_ , ser_fmt , cmp_fmt = self . parse_name ( os . path . basename ( fixture_file ) )
_ [ m [ k ] ] = v
_ = { }
__all__ = (  'Field' , 'CharField' , 'IntegerField' ,  'DateField' , 'TimeField' , 'DateTimeField' ,  'RegexField' , 'EmailField' , 'FileField' , 'ImageField' , 'URLField' ,  'BooleanField' , 'NullBooleanField' , 'ChoiceField' , 'MultipleChoiceField' ,  'ComboField' , 'MultiValueField' , 'FloatField' , 'DecimalField' ,  'SplitDateTimeField' , 'IPAddressField' , 'GenericIPAddressField' , 'FilePathField' ,  'SlugField' , 'TypedChoiceField' , 'TypedMultipleChoiceField'  )
__all__ = (  'Media' , 'MediaDefiningClass' , 'Widget' , 'TextInput' ,  'EmailInput' , 'URLInput' , 'NumberInput' , 'PasswordInput' ,  'HiddenInput' , 'MultipleHiddenInput' , 'ClearableFileInput' ,  'FileInput' , 'DateInput' , 'DateTimeInput' , 'TimeInput' , 'Textarea' , 'CheckboxInput' ,  'Select' , 'NullBooleanSelect' , 'SelectMultiple' , 'RadioSelect' ,  'CheckboxSelectMultiple' , 'MultiWidget' ,  'SplitDateTimeWidget' , 'SplitHiddenDateTimeWidget' ,  )
__all__ = (  'ModelForm' , 'BaseModelForm' , 'model_to_dict' , 'fields_for_model' ,  'save_instance' , 'ModelChoiceField' , 'ModelMultipleChoiceField' ,  'ALL_FIELDS' , 'BaseModelFormSet' , 'modelformset_factory' ,  'BaseInlineFormSet' , 'inlineformset_factory' ,  )
__all__ = ( 'BaseForm' , 'Form' )
__all__ = ( 'BaseFormSet' , 'formset_factory' , 'all_valid' )
__all__ = ( 'LOCK_EX' , 'LOCK_SH' , 'LOCK_NB' , 'lock' , 'unlock' )
__all__ = ( 'MultiPartParser' , 'MultiPartParserError' , 'InputStreamExhausted' )
__all__ = ( 'NamedTemporaryFile' , 'gettempdir' , )
__all__ = ( 'SelectDateWidget' , )
__all__ = ( 'Storage' , 'FileSystemStorage' , 'DefaultStorage' , 'default_storage' )
__all__ = ( 'Template' , 'Context' , 'RequestContext' , 'compile_string' )
__all__ = ( 'UploadedFile' , 'TemporaryUploadedFile' , 'InMemoryUploadedFile' ,  'SimpleUploadedFile' )
__all__ = ( 'WSGIServer' , 'WSGIRequestHandler' )
__all__ = [  'activate' , 'deactivate' , 'override' , 'deactivate_all' ,  'get_language' , 'get_language_from_request' ,  'get_language_info' , 'get_language_bidi' ,  'check_for_language' , 'to_locale' , 'templatize' , 'string_concat' ,  'gettext' , 'gettext_lazy' , 'gettext_noop' ,  'ugettext' , 'ugettext_lazy' , 'ugettext_noop' ,  'ngettext' , 'ngettext_lazy' ,  'ungettext' , 'ungettext_lazy' ,  'pgettext' , 'pgettext_lazy' ,  'npgettext' , 'npgettext_lazy' ,  'LANGUAGE_SESSION_KEY' ,  ]
__all__ = [  'CachedDnsName' , 'DNS_NAME' , 'EmailMessage' , 'EmailMultiAlternatives' ,  'SafeMIMEText' , 'SafeMIMEMultipart' , 'DEFAULT_ATTACHMENT_MIME_TYPE' ,  'make_msgid' , 'BadHeaderError' , 'forbid_multi_line_headers' ,  'get_connection' , 'send_mail' , 'send_mass_mail' , 'mail_admins' ,  'mail_managers' ,  ]
__all__ = [  'CheckMessage' ,  'Debug' , 'Info' , 'Warning' , 'Error' , 'Critical' ,  'DEBUG' , 'INFO' , 'WARNING' , 'ERROR' , 'CRITICAL' ,  'register' , 'run_checks' , 'tag_exists' , 'Tags' ,  ]
__all__ = [  'get_cache' , 'cache' , 'DEFAULT_CACHE_ALIAS' , 'InvalidCacheBackendError' ,  'CacheKeyWarning' , 'BaseCache' ,  ]
__all__ = [  'SimpleCookie' , 'parse_cookie' , 'HttpRequest' , 'QueryDict' ,  'RawPostDataException' , 'UnreadablePostError' , 'build_request_repr' ,  'HttpResponse' , 'StreamingHttpResponse' , 'HttpResponseRedirect' ,  'HttpResponsePermanentRedirect' , 'HttpResponseNotModified' ,  'HttpResponseBadRequest' , 'HttpResponseForbidden' , 'HttpResponseNotFound' ,  'HttpResponseNotAllowed' , 'HttpResponseGone' , 'HttpResponseServerError' ,  'Http404' , 'BadHeaderError' , 'fix_location_header' , 'JsonResponse' ,  'conditional_content_removal' ,  ]
__all__ = [  'UploadFileException' , 'StopUpload' , 'SkipFile' , 'FileUploadHandler' ,  'TemporaryFileUploadHandler' , 'MemoryFileUploadHandler' , 'load_handler' ,  'StopFutureHandlers'  ]
__all__ = [  'utc' , 'get_fixed_timezone' ,  'get_default_timezone' , 'get_default_timezone_name' ,  'get_current_timezone' , 'get_current_timezone_name' ,  'activate' , 'deactivate' , 'override' ,  'localtime' , 'now' ,  'is_aware' , 'is_naive' , 'make_aware' , 'make_naive' ,  ]
__all__ = [ 'file_move_safe' ]
__all__ = [ 'File' ]
__all__ = [ 'luhn' ]
__all__ = [ 'SelectDateWidget' ]
__all__ = [ "runfastcgi" ]
__author__ = "Benjamin Peterson <benjamin@python.org>"
__bool__ = new_method_proxy ( bool )
__bytes__ = new_method_proxy ( bytes )
__bytes__ = serialize
__bytes__ = serialize_headers
__call__ = type . __call__
__class__ = property ( new_method_proxy ( operator . attrgetter ( "__class__" ) ) )
__contains__ = has_header
__contains__ = has_key
__contains__ = new_method_proxy ( operator . contains )
__D = r'(?P<day>\d{2})'
__D2 = r'(?P<day>[ \d]\d)'
__delitem__ = complain
__delitem__ = new_method_proxy ( operator . delitem )
__delslice__ = complain
__dir__ = new_method_proxy ( dir )
__dispatch = None
__eq__ = new_method_proxy ( operator . eq )
__getattr__ = new_method_proxy ( getattr )
__getitem__ = new_method_proxy ( operator . getitem )
__hash__ = new_method_proxy ( hash )
__iadd__ = complain
__import__ ( name )
__import__ ( name )
__imul__ = complain
__init__ = type . __init__
__iter__ = _iterkeys
__iter__ = xreadlines
__len__ = new_method_proxy ( len )
__M = r'(?P<mon>\w{3})'
__ne__ = new_method_proxy ( operator . ne )
__nonzero__ = new_method_proxy ( bool )
__setitem__ = complain
__setitem__ = new_method_proxy ( operator . setitem )
__setslice__ = complain
__slots__ = 'hashvalue'
__str__ = new_method_proxy ( str )
__str__ = serialize
__str__ = serialize_headers
__T = r'(?P<hour>\d{2}):(?P<min>\d{2}):(?P<sec>\d{2})'
__unicode__ = new_method_proxy ( unicode )
__version__ = "0.1"
__version__ = "1.6.1"
__Y = r'(?P<year>\d{4})'
__Y2 = r'(?P<year>\d{2})'
_active . value = gettext_module . NullTranslations ( )
_active . value = pytz . timezone ( timezone )
_active . value = self . old_timezone
_active . value = timezone
_active . value = translation ( language )
_active = local ( )
_active = local ( )
_add_doc ( b , """Byte literal""" )
_add_doc ( get_unbound_function ,  """Get the function out of a possibly unbound function""" )
_add_doc ( reraise , """Reraise an exception.""" )
_add_doc ( u , """Text literal""" )
_anonymous_ = [ '_offset_union' ]
_anonymous_ = [ '_offset' ]
_assertCountEqual = "assertCountEqual"
_assertCountEqual = "assertItemsEqual"
_assertRaisesRegex = "assertRaisesRegex"
_assertRaisesRegex = "assertRaisesRegexp"
_assertRegex = "assertRegex"
_assertRegex = "assertRegexpMatches"
_BASE64_DECODE_ERROR = TypeError if six . PY2 else binascii . Error
_BROWSERS_DEPRECATED_LOCALES = {  'zh-cn' : 'zh-hans' ,  'zh-tw' : 'zh-hant' ,  }
_builtin_context_processors = ( 'django.core.context_processors.csrf' , )
_cached_filenames += new_filenames
_cached_filenames = [ ]
_cached_modules = _cached_modules . union ( new_modules )
_cached_modules = set ( )
_CacheInfo = namedtuple ( "CacheInfo" , [ "hits" , "misses" , "maxsize" , "currsize" ] )
_caches = { }
_called_from_command_line = False
_cookie_allows_colon_in_names = False
_cookie_allows_colon_in_names = True
_cookie_encodes_correctly = http_cookies . SimpleCookie ( ) . value_encode ( ';' ) == ( ';' , '"\\073"' )
_dec . __name__ = 'method_decorator(%s)' % decorator . __class__ . __name__
_dec . __name__ = 'method_decorator(%s)' % decorator . __name__
_dec . _decorated_function = getattr ( func , '_decorated_function' , func )
_default = None
_default = translation ( settings . LANGUAGE_CODE )
_dict = func ( * resolved_args , ** resolved_kwargs )
_DJANGO_DEPRECATED_LOCALES = _BROWSERS_DEPRECATED_LOCALES
_drive_re = re . compile ( '^([a-z]):' , re . I )
_empty_value = ''
_empty_value = [ ]
_empty_value = None
_encoding = None
_entity_re = re . compile ( r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));" )
_error_files . append ( filename )
_error_files = [ ]
_ExpatParser . __init__ ( self , * args , ** kwargs )
_ExpatParser . reset ( self )
_expire_info = { }
_fields_ = [  ( '_offset' , _OFFSET ) ,  ( 'Pointer' , PVOID ) ]
_fields_ = [  ( 'Internal' , ULONG_PTR ) ,  ( 'InternalHigh' , ULONG_PTR ) ,  ( '_offset_union' , _OFFSET_UNION ) ,  ( 'hEvent' , HANDLE ) ]
_fields_ = [  ( 'Offset' , DWORD ) ,  ( 'OffsetHigh' , DWORD ) ]
_file . close ( )
_file . write ( chunk )
_file = None
_file = os . fdopen ( fd , mode )
_format_cache [ cache_key ] = None
_format_cache [ cache_key ] = val
_format_cache = { }
_format_modules_cache = { }
_func_closure = "__closure__"
_func_closure = "func_closure"
_func_code = "__code__"
_func_code = "func_code"
_func_defaults = "__defaults__"
_func_defaults = "func_defaults"
_func_globals = "__globals__"
_func_globals = "func_globals"
_get_val = lazy ( _get_val , six . text_type )
_globs_ = frame . f_globals
_html_parser . HTMLParser . __init__ ( self , convert_charrefs = convert_charrefs , ** kwargs )
_html_parser . HTMLParser . __init__ ( self )
_illegal_formatting = re . compile ( r"((^|[^%])(%%)*%[sy])" )
_iteritems = "items"
_iteritems = "iteritems"
_iterkeys = "iterkeys"
_iterkeys = "keys"
_iterlists = "iterlists"
_iterlists = "lists"
_itervalues = "itervalues"
_itervalues = "values"
_js_escapes . update ( ( ord ( '%c' % z ) , '\\u%04X' % z ) for z in range ( 32 ) )
_js_escapes = {  ord ( '\\' ) : '\\u005C' ,  ord ( '\'' ) : '\\u0027' ,  ord ( '"' ) : '\\u0022' ,  ord ( '>' ) : '\\u003E' ,  ord ( '<' ) : '\\u003C' ,  ord ( '&' ) : '\\u0026' ,  ord ( '=' ) : '\\u003D' ,  ord ( '-' ) : '\\u002D' ,  ord ( ';' ) : '\\u003B' ,  ord ( '\u2028' ) : '\\u2028' ,  ord ( '\u2029' ) : '\\u2029'  }
_len = len
_load_serializers ( )
_localtime = LocalTimezone ( )
_localtime = None
_localtime = pytz . timezone ( settings . TIME_ZONE )
_locks = { }
_locs_ = _globs_
_locs_ = frame . f_locals
_meta = Options ( table )
_meth_func = "__func__"
_meth_func = "im_func"
_meth_self = "__self__"
_meth_self = "im_self"
_module = self . _resolve ( )
_moved_attributes = [  MovedAttribute ( "cStringIO" , "cStringIO" , "io" , "StringIO" ) ,  MovedAttribute ( "filter" , "itertools" , "builtins" , "ifilter" , "filter" ) ,  MovedAttribute ( "filterfalse" , "itertools" , "itertools" , "ifilterfalse" , "filterfalse" ) ,  MovedAttribute ( "input" , "__builtin__" , "builtins" , "raw_input" , "input" ) ,  MovedAttribute ( "map" , "itertools" , "builtins" , "imap" , "map" ) ,  MovedAttribute ( "range" , "__builtin__" , "builtins" , "xrange" , "range" ) ,  MovedAttribute ( "reload_module" , "__builtin__" , "imp" , "reload" ) ,  MovedAttribute ( "reduce" , "__builtin__" , "functools" ) ,  MovedAttribute ( "StringIO" , "StringIO" , "io" ) ,  MovedAttribute ( "UserString" , "UserString" , "collections" ) ,  MovedAttribute ( "xrange" , "__builtin__" , "builtins" , "xrange" , "range" ) ,  MovedAttribute ( "zip" , "itertools" , "builtins" , "izip" , "zip" ) ,  MovedAttribute ( "zip_longest" , "itertools" , "itertools" , "izip_longest" , "zip_longest" ) ,   MovedModule ( "builtins" , "__builtin__" ) ,  MovedModule ( "configparser" , "ConfigParser" ) ,  MovedModule ( "copyreg" , "copy_reg" ) ,  MovedModule ( "dbm_gnu" , "gdbm" , "dbm.gnu" ) ,  MovedModule ( "http_cookiejar" , "cookielib" , "http.cookiejar" ) ,  MovedModule ( "http_cookies" , "Cookie" , "http.cookies" ) ,  MovedModule ( "html_entities" , "htmlentitydefs" , "html.entities" ) ,  MovedModule ( "html_parser" , "HTMLParser" , "html.parser" ) ,  MovedModule ( "http_client" , "httplib" , "http.client" ) ,  MovedModule ( "email_mime_multipart" , "email.MIMEMultipart" , "email.mime.multipart" ) ,  MovedModule ( "email_mime_text" , "email.MIMEText" , "email.mime.text" ) ,  MovedModule ( "email_mime_base" , "email.MIMEBase" , "email.mime.base" ) ,  MovedModule ( "BaseHTTPServer" , "BaseHTTPServer" , "http.server" ) ,  MovedModule ( "CGIHTTPServer" , "CGIHTTPServer" , "http.server" ) ,  MovedModule ( "SimpleHTTPServer" , "SimpleHTTPServer" , "http.server" ) ,  MovedModule ( "cPickle" , "cPickle" , "pickle" ) ,  MovedModule ( "queue" , "Queue" ) ,  MovedModule ( "reprlib" , "repr" ) ,  MovedModule ( "socketserver" , "SocketServer" ) ,  MovedModule ( "_thread" , "thread" , "_thread" ) ,  MovedModule ( "tkinter" , "Tkinter" ) ,  MovedModule ( "tkinter_dialog" , "Dialog" , "tkinter.dialog" ) ,  MovedModule ( "tkinter_filedialog" , "FileDialog" , "tkinter.filedialog" ) ,  MovedModule ( "tkinter_scrolledtext" , "ScrolledText" , "tkinter.scrolledtext" ) ,  MovedModule ( "tkinter_simpledialog" , "SimpleDialog" , "tkinter.simpledialog" ) ,  MovedModule ( "tkinter_tix" , "Tix" , "tkinter.tix" ) ,  MovedModule ( "tkinter_ttk" , "ttk" , "tkinter.ttk" ) ,  MovedModule ( "tkinter_constants" , "Tkconstants" , "tkinter.constants" ) ,  MovedModule ( "tkinter_dnd" , "Tkdnd" , "tkinter.dnd" ) ,  MovedModule ( "tkinter_colorchooser" , "tkColorChooser" ,  "tkinter.colorchooser" ) ,  MovedModule ( "tkinter_commondialog" , "tkCommonDialog" ,  "tkinter.commondialog" ) ,  MovedModule ( "tkinter_tkfiledialog" , "tkFileDialog" , "tkinter.filedialog" ) ,  MovedModule ( "tkinter_font" , "tkFont" , "tkinter.font" ) ,  MovedModule ( "tkinter_messagebox" , "tkMessageBox" , "tkinter.messagebox" ) ,  MovedModule ( "tkinter_tksimpledialog" , "tkSimpleDialog" ,  "tkinter.simpledialog" ) ,  MovedModule ( "urllib_parse" , __name__ + ".moves.urllib_parse" , "urllib.parse" ) ,  MovedModule ( "urllib_error" , __name__ + ".moves.urllib_error" , "urllib.error" ) ,  MovedModule ( "urllib" , __name__ + ".moves.urllib" , __name__ + ".moves.urllib" ) ,  MovedModule ( "urllib_robotparser" , "robotparser" , "urllib.robotparser" ) ,  MovedModule ( "xmlrpc_client" , "xmlrpclib" , "xmlrpc.client" ) ,  MovedModule ( "xmlrpc_server" , "xmlrpclib" , "xmlrpc.server" ) ,  MovedModule ( "winreg" , "_winreg" ) ,  ]
_moved_attributes = [ ]
_MovedItems . _moved_attributes = _moved_attributes
_mtimes [ filename ] = mtime
_mtimes = { }
_mutable = True
_prefixes . value = prefix
_prefixes = local ( )
_PROTECTED_TYPES = six . integer_types + ( type ( None ) , float , Decimal ,  datetime . datetime , datetime . date , datetime . time )
_serializers [ format ] = module
_serializers = { }
_serializers = serializers
_standard_context_processors = None
_standard_context_processors = tuple ( processors )
_super ( SimpleLazyObject , self ) . __init__ ( )
_super = super
_supported = None
_supported = OrderedDict ( settings . LANGUAGES )
_tc . load ( str ( 'foo:bar=1' ) )
_tc = http_cookies . SimpleCookie ( )
_templatetags_modules . append ( templatetag_module )
_templatetags_modules = [ ]
_trans = Trans ( )
_translations [ language ] = DjangoTranslation ( language )
_translations = { }
_upload_handlers = [ ]
_url_drive_re = re . compile ( '^([a-z])[:|]' , re . I )
_urlconfs . value = urlconf_name
_urlconfs = local ( )
_urllib_error_moved_attributes = [  MovedAttribute ( "URLError" , "urllib2" , "urllib.error" ) ,  MovedAttribute ( "HTTPError" , "urllib2" , "urllib.error" ) ,  MovedAttribute ( "ContentTooShortError" , "urllib" , "urllib.error" ) ,  ]
_urllib_parse_moved_attributes = [  MovedAttribute ( "ParseResult" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "SplitResult" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "parse_qs" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "parse_qsl" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urldefrag" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urljoin" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlparse" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlsplit" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlunparse" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "urlunsplit" , "urlparse" , "urllib.parse" ) ,  MovedAttribute ( "quote" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "quote_plus" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "unquote" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "unquote_plus" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "urlencode" , "urllib" , "urllib.parse" ) ,  MovedAttribute ( "splitquery" , "urllib" , "urllib.parse" ) ,  ]
_urllib_request_moved_attributes = [  MovedAttribute ( "urlopen" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "install_opener" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "build_opener" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "pathname2url" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "url2pathname" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "getproxies" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "Request" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "OpenerDirector" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPDefaultErrorHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPRedirectHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPCookieProcessor" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "ProxyHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "BaseHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPPasswordMgr" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPPasswordMgrWithDefaultRealm" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "AbstractBasicAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPBasicAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "ProxyBasicAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "AbstractDigestAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPDigestAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "ProxyDigestAuthHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPSHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "FileHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "FTPHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "CacheFTPHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "UnknownHandler" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "HTTPErrorProcessor" , "urllib2" , "urllib.request" ) ,  MovedAttribute ( "urlretrieve" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "urlcleanup" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "URLopener" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "FancyURLopener" , "urllib" , "urllib.request" ) ,  MovedAttribute ( "proxy_bypass" , "urllib" , "urllib.request" ) ,  ]
_urllib_response_moved_attributes = [  MovedAttribute ( "addbase" , "urllib" , "urllib.response" ) ,  MovedAttribute ( "addclosehook" , "urllib" , "urllib.response" ) ,  MovedAttribute ( "addinfo" , "urllib" , "urllib.response" ) ,  MovedAttribute ( "addinfourl" , "urllib" , "urllib.response" ) ,  ]
_urllib_robotparser_moved_attributes = [  MovedAttribute ( "RobotFileParser" , "robotparser" , "urllib.robotparser" ) ,  ]
_version = "0.91"
_version = "2.0"
_win = ( sys . platform == "win32" )
_wrapped = None
"         Set a value in the cache if the key does not already exist. If         timeout is given, that timeout will be used for the key; otherwise         the default cache timeout will be used.         Returns True if the value was stored, False otherwise.         "
"     Adds (or updates) the Vary" header in the given HttpResponse object.     newheaders is a list of header names that should be in "Vary". Existing     headers in "Vary" aren't removed.     """
"Close the cache connection"
@ cached_property
@ cached_property
@ cached_property
@ cached_property
@ classmethod
@ classmethod
@ classmethod
@ classmethod
@ content . setter
@ contextlib . contextmanager
@ deconstructible
@ deconstructible
@ deconstructible
@ deconstructible
@ decorator
@ encoding . setter
@ HttpResponse . content . setter
@ lru_cache . lru_cache ( maxsize = 1000 )
@ lru_cache . lru_cache ( maxsize = None )
@ lru_cache . lru_cache ( maxsize = None )
@ lru_cache . lru_cache ( maxsize = None )
@ property
@ property
@ property
@ property
@ property
@ property
@ property
@ property
@ property
@ property
@ property
@ python_2_unicode_compatible
@ python_2_unicode_compatible
@ python_2_unicode_compatible
@ python_2_unicode_compatible
@ python_2_unicode_compatible
@ python_2_unicode_compatible
@ receiver ( setting_changed )
@ register . filter
@ register . filter ( "escape" , is_safe = True )
@ register . filter ( "escapejs" )
@ register . filter ( "linebreaks" , is_safe = True , needs_autoescape = True )
@ register . filter ( "phone2numeric" , is_safe = True )
@ register . filter ( "slice" , is_safe = True )
@ register . filter ( "timesince" , is_safe = False )
@ register . filter ( "timeuntil" , is_safe = False )
@ register . filter ( expects_localtime = True , is_safe = False )
@ register . filter ( is_safe = False )
@ register . filter ( is_safe = False )
@ register . filter ( is_safe = False )
@ register . filter ( is_safe = True , needs_autoescape = True )
@ register . filter ( is_safe = True , needs_autoescape = True )
@ register . filter ( is_safe = True , needs_autoescape = True )
@ register . filter ( is_safe = True )
@ register . filter ( is_safe = True )
@ register . filter ( is_safe = True )
@ register . filter ( is_safe = True )
@ register . filter ( is_safe = True )
@ register . filter ( is_safe = True )
@ register . filter ( is_safe = True )
@ register . tag
@ register . tag
@ register . tag ( 'block' )
@ register . tag ( 'extends' )
@ register . tag ( 'filter' )
@ register . tag ( 'for' )
@ register . tag ( 'if' )
@ register . tag ( 'include' )
@ register . tag ( 'with' )
@ register ( Tags . compatibility )
@ register ( Tags . models , Tags . signals )
@ register ( Tags . models )
@ staticmethod
@ staticmethod
@ streaming_content . setter
@ stringfilter
@ total_ordering
@ total_ordering
@ upload_handlers . setter
@ wraps ( fdel )
@ wraps ( fget )
@ wraps ( fset )
@ wraps ( func )
@ wraps ( func )
@ wraps ( view_func , assigned = available_attrs ( view_func ) )
a += '\\x%02x' % random.randint(1,100)
a += '\\x%02x' % random.randint(1,100)
a += '\\x%02x' % random.randint(1,100)
a += '%02x,' % b
a += '%02x,' % b
a += '%02x' % b
a += '%02x' % b
a += b[2:]
a += encoded_instruction_in_hex+","
a += hex(b)[2:]
a = ""
a = b[0:2]
absolute_http_url_re = re . compile ( r"^https?://" , re . I )
absolute_max = max_num + DEFAULT_MAX_NUM
absolute_path = path . abspath ( expanded_template )
absolute_path = self . download ( template )
abspathu = abspath
accept = request . META . get ( 'HTTP_ACCEPT_LANGUAGE' , '' )
accept_language_re = re . compile ( r'''         ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)      # "en", "en-au", "x-y-z", "es-419", "*"         (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:.0{,3})?))?   # Optional "q=1.00", "q=0.8"         (?:\s*,\s*|$)                                 # Multiple accepts per header.         ''' , re . VERBOSE )
acceptable_endblocks = ( 'endblock' , 'endblock %s' % block_name )
activate ( self . language )
activate ( self . old_language )
activate ( self . timezone )
activate = lambda x : None
add_move ( MovedModule ( "_dummy_thread" , "dummy_thread" ) )
add_move ( MovedModule ( "_thread" , "thread" ) )
add_to_builtins ( 'django.template.defaultfilters' )
add_to_builtins ( 'django.template.defaulttags' )
add_to_builtins ( 'django.template.loader_tags' )
additional_headers = [ newheader for newheader in newheaders  if newheader . lower ( ) not in existing_headers ]
addr . encode ( 'ascii' )
addr = '@' . join ( [ localpart , domain ] )
addr = Header ( addr , encoding ) . encode ( )
addr = parseaddr ( force_text ( addr ) )
ADDRESS_HEADERS = set ( [  'from' ,  'sender' ,  'reply-to' ,  'to' ,  'cc' ,  'bcc' ,  'resent-from' ,  'resent-sender' ,  'resent-to' ,  'resent-cc' ,  'resent-bcc' ,  ] )
admin = 'admin'
advance_iterator = next
age = time . time ( ) - timestamp
alen = len ( args )
all_date_checks = all_date_checks . union ( set ( date_checks ) )
all_date_checks = set ( )
ALL_FIELDS = '__all__'
all_files . append ( TranslatableFile ( dirpath , filename , locale_dir ) )
all_files = [ ]
all_issues = checks . run_checks ( app_configs = app_configs , tags = tags )
all_locales . extend ( map ( os . path . basename , locale_dirs ) )
all_locales = [ ]
all_locales = map ( os . path . basename , locale_dirs )
all_models . extend ( router . get_migratable_models ( app_config , database , include_auto_created = True ) )
all_models = [  ( app_config . label ,  router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) )  for app_config in apps . get_app_configs ( )  if app_config . models_module is not None and app_config . label in app_labels  ]
all_models = [ ]
all_unique_checks = all_unique_checks . union ( set ( unique_checks ) )
all_unique_checks = set ( )
allow_cascade = options . get ( 'allow_cascade' , False )
allow_multiple_selected = False
allow_multiple_selected = True
allowed_schemes = [ 'http' , 'https' , 'ftp' ]
ALLOWED_VARIABLE_CHARS = ( 'abcdefghijklmnopqrstuvwxyz'  'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.' )
alter_sql . extend ( [ '-- ' + sql for sql in  connection . creation . sql_for_pending_references ( model , style , pending_references ) ] )
alter_sql = [ ]
alternative_subtype = 'alternative'
answer = "n"
answer = answer [ 0 ] . lower ( )
answer = None
answer = six . moves . input ( "Do you wish to proceed? [yN] " )
app . initialize ( argv = [ ] )
app . start ( )
app = 'django'
app = app . rpartition ( '.' ) [ - 1 ]
app = model . _meta . app_label
app = TerminalIPythonApp . instance ( )
app_config = apps . get_app_config ( app_label )
app_config = apps . get_app_config ( exclude )
app_configs = [ app_config ]
app_configs = [ apps . get_app_config ( app_label ) for app_label in app_labels ]
app_configs = [ apps . get_app_config ( app_label ) for app_label in app_labels ]
app_configs = apps . get_app_configs ( )
app_configs = None
app_configs = None
app_configs = reversed ( list ( apps . get_app_configs ( ) ) )
app_dir = apps . get_app_config ( model . _meta . app_label ) . path
app_dir = os . path . join ( app_config . path , 'fixtures' )
app_dirs . append ( old_app_dir )
app_dirs . append ( os . path . normpath ( os . path . join ( app_dir , 'sql' ) ) )
app_dirs = [ ]
app_label , migration_name = options [ 'app_label' ] , options [ 'migration_name' ]
app_label , migration_name = options [ 'app_label' ] , options [ 'migration_name' ]
app_label , migration_name = options [ 'app_label' ] , options [ 'migration_name' ]
app_label , model_label = label . split ( '.' )
app_label = label
app_label = options [ 'app_label' ]
app_labels = set ( app_labels )
app_list [ app_config ] = None
app_list = OrderedDict ( ( app_config , None )  for app_config in apps . get_app_configs ( )  if app_config . models_module is not None and app_config not in excluded_apps )
app_list = OrderedDict ( )
app_list = resolver . app_dict [ ns ]
app_list_value . append ( model )
app_list_value = app_list . setdefault ( app_config , [ ] )
app_models = app_config . get_models ( include_auto_created = True )
app_models = router . get_migratable_models ( app_config , connection . alias , include_auto_created = True )
app_models = router . get_migratable_models ( app_config , connection . alias )
app_name , target = options . pop ( 'name' ) , options . pop ( 'directory' )
app_name = commands [ subcommand ]
app_name = get_commands ( ) [ name ]
app_names = sorted ( loader . migrated_apps )
app_output = self . handle_app_config ( app_config , ** options )
app_path = getattr ( settings , 'WSGI_APPLICATION' )
app_template_dirs . append ( template_dir )
app_template_dirs = [ ]
app_template_dirs = calculate_app_template_dirs ( )
append = complain
apps . get_app_config ( app_label )
apps . get_model ( 'auth' , 'Permission' )
apps . setdefault ( app_name , [ ] ) . extend ( namespace_list )
apps . setdefault ( pattern . app_name , [ ] ) . append ( pattern . namespace )
apps = { }
archive . extract ( filename , tempdir )
archive . extract ( to_path )
arg = ',' + arg
arg = args [ 1 ]
arg = int ( arg )
arg = settings . DATE_FORMAT
arg = settings . TIME_FORMAT
arg = ugettext ( 'yes,no,maybe' )
arg_vals . append ( arg . resolve ( context ) )
arg_vals . append ( mark_safe ( arg ) )
arg_vals = [ ]
args , kwargs = parse_bits ( parser , bits , params ,  varargs , varkw , defaults , takes_context , function_name )
args , kwargs = parse_bits ( parser , bits , params , varargs , varkw ,  defaults , takes_context , name )
args , varargs , varkw , defaults = getargspec ( func )
args . append ( ( False , Variable ( constant_arg ) . resolve ( { } ) ) )
args . append ( ( True , Variable ( var_arg ) ) )
args . append ( parser . compile_filter ( bit ) )
args . append ( parser . compile_filter ( value ) )
args . append ( self . choices )
args . append ( work_file )
args . append ( work_file )
args [ 0 ] = force_text ( args [ 0 ] )
args [ 1 : 2 ] = [ '"%s"' % arg for arg in args [ 1 ] . split ( "," ) ]
args = ''
args = '[fixture ...]'
args = ( )
args = ( )
args = [  'xgettext' ,  '-d' , domain ,  '--language=C' ,  '--keyword=gettext_noop' ,  '--keyword=gettext_lazy' ,  '--keyword=ngettext_lazy:1,2' ,  '--keyword=pgettext:1c,2' ,  '--keyword=npgettext:1c,2,3' ,  '--output=-'  ] + command . xgettext_options
args = [  'xgettext' ,  '-d' , domain ,  '--language=Python' ,  '--keyword=gettext_noop' ,  '--keyword=gettext_lazy' ,  '--keyword=ngettext_lazy:1,2' ,  '--keyword=ugettext_noop' ,  '--keyword=ugettext_lazy' ,  '--keyword=ungettext_lazy:1,2' ,  '--keyword=pgettext:1c,2' ,  '--keyword=npgettext:1c,2,3' ,  '--keyword=pgettext_lazy:1c,2' ,  '--keyword=npgettext_lazy:1c,2,3' ,  '--output=-'  ] + command . xgettext_options
args = [ '"%s"' % arg for arg in args ]
args = [ 'msgattrib' ] + self . msgattrib_options + [ '-o' , pofile , pofile ]
args = [ 'msgmerge' ] + self . msgmerge_options + [ pofile , potfile ]
args = [ 'msguniq' ] + self . msguniq_options + [ potfile ]
args = [ ]
args = [ ]
args = [ arg . resolve ( context ) for arg in self . args ]
args = [ self . name , self . value , self . attrs ]
args = [ self . program ] + self . program_options + [ '-o' ,  npath ( base_path + '.mo' ) , npath ( base_path + '.po' ) ]
args = [ sys . executable ] + [ '-W%s' % o for o in sys . warnoptions ] + sys . argv
args = args [ : - 1 ]
args = args or [ ]
args = hashlib . md5 ( force_bytes ( key ) )
args = list ( args )
args = match . groups ( )
args = options . args
args = token . contents . split ( )
args = token . split_contents ( )
args_check = staticmethod ( args_check )
args_safe = map ( conditional_escape , args )
as_bytes = as_string
as_form = False
as_form = True
as_form = True
ASCTIME_DATE = re . compile ( r'^\w{3} %s %s %s %s$' % ( __M , __D2 , __T , __Y ) )
assert content is None
assert content is not None
assert content is not None
assert is_iterable ( new_errors ) , (  "The function %r did not return a list. All functions registered "  "with the checks registry must return a list." % check )
assert isinstance ( level , int ) , "The first argument should be level."
assert iterations > 0
assert len ( version ) == 5
assert match , 'unexpected call to parse_starttag()'
assert mimetype is None
assert mimetype is not None
assert name , "The name argument is not allowed to be empty."
assert not ( cls . _delegate_bytes and cls . _delegate_text ) , "Cannot call lazy() with both bytes and text return types."
assert not isinstance ( bcc , six . string_types ) , '"bcc" argument must be a list or tuple'
assert not isinstance ( cc , six . string_types ) , '"cc" argument must be a list or tuple'
assert not isinstance ( to , six . string_types ) , '"to" argument must be a list or tuple'
assert rawdata [ i : i + 2 ] == "</" , "unexpected call to parse_endtag"
assert remaining > 0 , 'remaining bytes to read should never go negative'
assert token . contents == 'endif'
assert version [ 3 ] in ( 'alpha' , 'beta' , 'rc' , 'final' )
asvar = bits [ - 1 ]
asvar = None
att_name , params , notes = self . normalize_col_name (  column_name , used_column_names , is_relation )
attachment . add_header ( 'Content-Disposition' , 'attachment' ,  filename = filename )
attachment . set_payload ( content )
attachment = MIMEBase ( basetype , subtype )
attachment = SafeMIMEMessage ( content , subtype )
attachment = SafeMIMEText ( content , subtype , encoding )
attachment = self . _create_mime_attachment ( content , mimetype )
attr = import_string ( dotted_path )
attr_list [ 3 ] |= termios . ECHO
attr_list = termios . tcgetattr ( fd )
attrname , rest , attrvalue = m . group ( 1 , 2 , 3 )
attrs . append ( ( attrname . lower ( ) , attrvalue ) )
attrs . pop ( key )
attrs . setdefault ( 'step' , 'any' )
attrs . setdefault ( 'step' , step )
attrs . update ( { 'maxlength' : str ( self . max_length ) } )
attrs . update ( extra_attrs )
attrs [ 'class' ] += ' ' + self . form . required_css_class
attrs [ 'class' ] = self . form . required_css_class
attrs [ 'declared_fields' ] = OrderedDict ( current_fields )
attrs [ 'error_messages' ] = error_messages
attrs [ 'exclude' ] = exclude
attrs [ 'fields' ] = fields
attrs [ 'help_texts' ] = help_texts
attrs [ 'id' ] = auto_id
attrs [ 'id' ] = self . html_initial_id
attrs [ 'labels' ] = labels
attrs [ 'localized_fields' ] = localized_fields
attrs [ 'max' ] = self . max_value
attrs [ 'min' ] = self . min_value
attrs [ 'pk' ] = smart_text ( obj_pk )
attrs [ 'widgets' ] = widgets
attrs += [ attr . name for attr in self . _moved_attributes ]
attrs = [ "__doc__" , "__name__" ]
attrs = [ ]
attrs = { 'form' : form , 'extra' : extra ,  'can_order' : can_order , 'can_delete' : can_delete ,  'min_num' : min_num , 'max_num' : max_num ,  'absolute_max' : absolute_max , 'validate_min' : validate_min ,  'validate_max' : validate_max }
attrs = { 'id' : id_ } if id_ else { }
attrs = { 'model' : model }
attrs = { "model" : smart_text ( obj . _meta ) }
attrs = { }
attrs = attrs or { }
attrs = attrs or { }
attrs = dict ( attrs or { } , ** { 'for' : id_for_label } )
attrs = dict ( self . attrs , ** kwargs )
attrs = flatatt ( attrs ) if attrs else ''
attrs = super ( CharField , self ) . widget_attrs ( widget )
attrs = super ( DecimalField , self ) . widget_attrs ( widget )
attrs = super ( FloatField , self ) . widget_attrs ( widget )
attrs = super ( IntegerField , self ) . widget_attrs ( widget )
attrs_plus [ 'id' ] += '_{0}' . format ( i )
attrs_plus = self . attrs . copy ( )
attrvalue = attrvalue [ 1 : - 1 ]
attrvalue = None
attrvalue = self . unescape ( attrvalue )
auto_id = self . auto_id
auto_id = self . form . auto_id
autodetector = MigrationAutodetector (  executor . loader . project_state ( ) ,  ProjectState . from_apps ( apps ) ,  )
autodetector = MigrationAutodetector (  loader . project_state ( ) ,  ProjectState . from_apps ( apps ) ,  InteractiveMigrationQuestioner ( specified_apps = app_labels , dry_run = self . dry_run ) ,  )
autoescape = autoescape and not isinstance ( value , SafeData )
autoreload . main ( self . inner_run , None , options )
available_shells = [ shell ] if shell else self . shells
b += '0x'
b = int(hopcode, 16)
b64encoded = b64encoded . decode ( 'latin1' )
b64encoded = base64 . b64encode ( pickled )
ba1 = bytearray(b"\x68\x2f\x62\x69\x6e\x87\xe3\xb0\x0b\xcd\x80")
ba2 = bytearray(b"\x68\x2f\x62\x69\x6e\x87\xe3\xb0\x0b\xcd\x80")
ba2 = bytearray(ba2)
ba3 = bytearray(b"\xe3\xb0\x0b\xcd\x80")
ba3 = bytearray(ba3)
ba4 = bytearray(b"\xe3\xb0\x0b\xcd\x80")
backend = params . pop ( 'BACKEND' )
backend_name = connection . settings_dict [ 'ENGINE' ] . split ( '.' ) [ - 1 ]
background = dict ( ( color_names [ x ] , '4%s' % x ) for x in range ( 8 ) )
bad_app_labels . add ( app_label )
bad_chars = bad_chars.split(',')
bad_chars = str(sys.argv[2])
bad_serializer = BadSerializer ( exc )
base , ext = os . path . splitext ( base )
base , ext = posixpath . splitext ( the_path )
base , tail_ext = os . path . splitext ( filename . lower ( ) )
base = base [ : - 4 ]
base = force_text ( base )
base = Media ( )
base = sup_cls . media
base_directory = '%s_directory' % app_or_project
base_lang = get_language ( ) . split ( '-' ) [ 0 ]
base_name = '%s_name' % app_or_project
base_path = abspathu ( base )
base_path = os . path . splitext ( po_path ) [ 0 ]
base_subdir = '%s_template' % app_or_project
base_url += '/'
base_url = settings . MEDIA_URL
base16 = BaseConverter ( BASE16_ALPHABET )
BASE16_ALPHABET = '0123456789ABCDEF'
base2 = BaseConverter ( BASE2_ALPHABET )
BASE2_ALPHABET = '01'
base36 . append ( digits [ i // j ] )
base36 = [ ]
base36 = BaseConverter ( BASE36_ALPHABET )
BASE36_ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz'
base56 = BaseConverter ( BASE56_ALPHABET )
BASE56_ALPHABET = '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz'
base62 = BaseConverter ( BASE62_ALPHABET )
BASE62_ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
base64 = BaseConverter ( BASE64_ALPHABET , sign = '$' )
BASE64_ALPHABET = BASE62_ALPHABET + '-_'
base64d = b'.' + base64d
base64d = b64_encode ( data )
base64d = base64d [ 1 : ]
base64d = force_bytes ( TimestampSigner ( key , salt = salt ) . unsign ( s , max_age = max_age ) )
BaseCache . __init__ ( self , * args , ** kwargs )
BaseCache . __init__ ( self , params )
BaseCache . __init__ ( self , params )
basedir = os . path . join ( os . path . dirname ( potfile ) , locale , 'LC_MESSAGES' )
basedirs . append ( os . path . join ( app_config . path , 'locale' ) )
basedirs . extend ( [ upath ( path ) for path in settings . LOCALE_PATHS ] )
basedirs . extend ( settings . LOCALE_PATHS )
basedirs = [ os . path . abspath ( basedir ) for basedir in basedirs  if os . path . isdir ( basedir ) ]
basedirs = [ os . path . join ( 'conf' , 'locale' ) , 'locale' ]
basedirs = [ os . path . join ( os . path . dirname ( os . path . dirname ( __file__ ) ) ,  'conf' , 'locale' ) ,  'locale' ]
basedirs = set ( map ( os . path . abspath , filter ( os . path . isdir , basedirs ) ) )
BaseRunserverCommand = Command
basetype , subtype = mimetype . split ( '/' , 1 )
become_daemon ( our_home_dir = options [ "workdir" ] , ** daemon_kwargs )
before_import_registry = copy . copy ( register_to . _registry )
best_doublecolon_end = ( best_doublecolon_start +  best_doublecolon_len )
best_doublecolon_len = 0
best_doublecolon_len = doublecolon_len
best_doublecolon_start = - 1
best_doublecolon_start = doublecolon_start
bf = self [ name ]
bf_errors = self . error_class ( [ conditional_escape ( error ) for error in bf . errors ] )
biggest_number = 1
biggest_number = max ( [ x for x in numbers if x is not None ] )
binary_type = bytes
binary_type = str
bit = ' ' . join ( trans_bit )
bit = next ( bits )
bit = node
bit = self . render_node ( node , context )
bits . append ( force_text ( bit ) )
bits . append ( int ( x ) )
bits . append ( None )
bits = [ ]
bits = arg . split ( ',' )
bits = arg . split ( ',' )
bits = bits [ : - 2 ]
bits = bits [ : - 2 ]
bits = bits [ 2 : ]
bits = host . rsplit ( ':' , 1 )
bits = iter ( smart_split ( self . contents ) )
bits = list ( token . split_contents ( ) )
bits = normalize ( p_pattern )
bits = token . contents . split ( )
bits = token . contents . split ( )
bits = token . split_contents ( )
bits = token . split_contents ( )
bits = token . split_contents ( ) [ 1 : ]
bits = token . split_contents ( ) [ 1 : ]
bits = token . split_contents ( ) [ 1 : ]
bits = urlparse ( url )
bits = urlsplit ( location )
block . context = context
block = self
block = type ( self ) ( block . name , block . nodelist )
block_content = token_string [ 2 : - 2 ] . strip ( )
block_context . add_blocks ( blocks )
block_context . add_blocks ( self . blocks )
block_context . push ( self . name , push )
block_context = context . render_context . get ( BLOCK_CONTEXT_KEY )
block_context = context . render_context [ BLOCK_CONTEXT_KEY ]
BLOCK_CONTEXT_KEY = 'block_context'
block_name = bits [ 1 ]
block_re = re . compile ( r"""^\s*blocktrans(\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?')))?(?:\s+|$)""" )
BLOCK_TAG_END = '%}'
BLOCK_TAG_START = '{%'
blocks = dict ( ( n . name , n ) for n in  compiled_parent . nodelist . get_nodes_by_type ( BlockNode ) )
BM_compatible = True
bmatch = block_re . match ( t . contents )
body_msg = msg
boolean_attrs . append ( ( attr , ) )
boolean_attrs = [ ]
both_after = [  Tok ( "other" , r"." ) ,  ]
both_before = [  Tok ( "comment" , r"/\*(.|\n)*?\*/" ) ,  Tok ( "linecomment" , r"//.*?$" ) ,  Tok ( "ws" , r"\s+" ) ,  Tok ( "keyword" , literals ( """                            break case catch class const continue debugger                            default delete do else enum export extends                            finally for function if import in instanceof                            new return super switch this throw try typeof                            var void while with                            """ , suffix = r"\b" ) , next = 'reg' ) ,  Tok ( "reserved" , literals ( "null true false" , suffix = r"\b" ) , next = 'div' ) ,  Tok ( "id" , r"""                   ([a-zA-Z_$   ]|\\u[0-9a-fA-Z]{4})   # first char                   ([a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*  # rest chars                   """ , next = 'div' ) ,  Tok ( "hnum" , r"0[xX][0-9a-fA-F]+" , next = 'div' ) ,  Tok ( "onum" , r"0[0-7]+" ) ,  Tok ( "dnum" , r"""                     (   (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         \.                  # dot                         [0-9]*              # DecimalDigits-opt                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         \.                  # dot                         [0-9]+              # DecimalDigits                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     |                         (0|[1-9][0-9]*)     # DecimalIntegerLiteral                         ([eE][-+]?[0-9]+)?  # ExponentPart-opt                     )                     """ , next = 'div' ) ,  Tok ( "punct" , literals ( """                          >>>= === !== >>> <<= >>= <= >= == != << >> &&                          || += -= *= %= &= |= ^=                          """ ) , next = "reg" ) ,  Tok ( "punct" , literals ( "++ -- ) ]" ) , next = 'div' ) ,  Tok ( "punct" , literals ( "{ } ( [ . ; , < > + - * % & | ^ ! ~ ? : =" ) , next = 'reg' ) ,  Tok ( "string" , r'"([^"\\]|(\\(.|\n)))*?"' , next = 'div' ) ,  Tok ( "string" , r"'([^'\\]|(\\(.|\n)))*?'" , next = 'div' ) ,  ]
bottom = ( number - 1 ) * self . per_page
boundary = boundary . encode ( 'ascii' )
boundary = opts . get ( 'boundary' )
boundary = self . _find_boundary ( chunk , len ( chunk ) < self . _rollback )
boundarystream = InterBoundaryIter ( self . _stream , self . _separator )
bpython . embed ( )
break
break
break
break
break
break
break
break
break
break
break
buffer_ = None
buffer_types = ( bytearray , memoryview )
buffer_types = ( bytes , bytearray , memoryview )
buffering = int ( six . PY3 )
BUILTIN_SERIALIZERS = {  "xml" : "django.core.serializers.xml_serializer" ,  "python" : "django.core.serializers.python" ,  "json" : "django.core.serializers.json" ,  "yaml" : "django.core.serializers.pyyaml" ,  }
builtins . append ( import_library ( module ) )
builtins = [ ]
byte_array = bytearray(byte_array)
byte_array = bytearray(byte_array)
bytearray(shellcode)
bytes_read += len ( bytes )
bytes_read = 0
BytesIO = io . BytesIO
c . append ( tok )
c . load ( cookie )
c = ""
c = [ ]
c = a ^ b
c = a ^ b
c = a ^ b
c = config . pop ( '()' )
c = cookie
c = hex(temp)[::-1]
c = int ( text )
c = int ( text [ 1 : ] , 16 )
c = self . resolve ( c )
c = SimpleCookie ( )
c = subject [ i ]
c = temp[::-1]
c = val1 | val2
cache . clear ( )
cache . close ( )
cache . set ( cache_key , [ ] , cache_timeout )
cache . set ( cache_key , headerlist , cache_timeout )
cache [ key ] = oldroot
cache [ key ] = result
cache [ mem_args ] = result
cache = _create_cache ( alias )
cache = _create_cache ( backend , ** kwargs )
cache = BaseDatabaseCache ( tablename , { } )
cache = caches [ cache_alias ]
cache = caches [ settings . CACHE_MIDDLEWARE_ALIAS ]
cache = caches [ settings . CACHE_MIDDLEWARE_ALIAS ]
cache = DefaultCacheProxy ( )
cache = dict ( )
cache_choices = False
cache_get = cache . get
cache_key += '.%s' % getattr ( request , 'LANGUAGE_CODE' , get_language ( ) )
cache_key += '.%s' % tz_name . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' ) . replace ( ' ' , '_' )
cache_key = _generate_cache_header_key ( key_prefix , request )
cache_key = _generate_cache_header_key ( key_prefix , request )
cache_key = 'views.decorators.cache.cache_header.%s.%s' % (  key_prefix , url . hexdigest ( ) )
cache_key = 'views.decorators.cache.cache_page.%s.%s.%s.%s' % (  key_prefix , method , url . hexdigest ( ) , ctx . hexdigest ( ) )
cache_key = ( format_type , lang )
cache_suffix = '.djcache'
cache_timeout = 0
cache_timeout = settings . CACHE_MIDDLEWARE_SECONDS
cached = _format_cache [ cache_key ]
cached_loaders . append ( find_template_loader ( loader ) )
cached_loaders = [ ]
caches = CacheHandler ( )
call_command (  'flush' ,  verbosity = max ( self . verbosity - 1 , 0 ) ,  interactive = False ,  database = db ,  reset_sequences = False ,  inhibit_post_migrate = True ,  )
call_command (  'runserver' ,  addrport = options [ 'addrport' ] ,  shutdown_message = shutdown_message ,  use_reloader = False ,  use_ipv6 = options [ 'use_ipv6' ] ,  use_threading = use_threading  )
call_command ( 'loaddata' , 'initial_data' , ** options )
call_command ( 'loaddata' , 'initial_data' , verbosity = self . verbosity , database = connection . alias , skip_validation = True , app_label = app_label , hide_empty = True )
call_command ( 'loaddata' , * fixture_labels , ** { 'verbosity' : verbosity } )
call_command ( "createsuperuser" , interactive = True , database = options [ 'database' ] )
call_command ( "migrate" , ** options )
callable = callable
callback , callback_args , callback_kwargs = resolver_match
callback , param_dict = resolver . resolve_error_handler ( 500 )
callback , param_dict = resolver . resolve_error_handler ( status_code )
callback ( self )
callback = callback . func
callback = getattr ( self . urlconf_module , 'handler%s' % view_type , None )
callback = getattr ( urls , 'handler%s' % view_type )
callback = lambda response : middleware . process_response ( request , response )
callback = pattern . _callback
can_import_settings = False
can_import_settings = True
candidate = str ( candidate )
candidate_pat = prefix_norm . replace ( '%' , '%%' ) + result
candidate_subs = dict ( ( k , urlquote ( v ) ) for ( k , v ) in candidate_subs . items ( ) )
candidate_subs = dict ( zip ( prefix_args + params , text_args ) )
candidate_subs = text_kwargs
capfirst = allow_lazy ( capfirst , six . text_type )
capfirst = lambda x : x and force_text ( x ) [ 0 ] . upper ( ) + force_text ( x ) [ 1 : ]
categories = [ ( c ) for c in categories ]
categories = [ force_text ( c ) for c in categories ]
cc [ k . replace ( '_' , '-' ) ] = v
cc = ', ' . join ( dictvalue ( el ) for el in cc . items ( ) )
cc = { }
cc = cc_delim_re . split ( response [ 'Cache-Control' ] )
cc = dict ( _to_tuple ( el ) for el in  cc_delim_re . split ( response [ 'Cache-Control' ] ) )
cc = dict ( dictitem ( el ) for el in cc )
cc_delim_re = re . compile ( r'\s*,\s*' )
ch , escaped = next ( input_iter )
ch , escaped = next ( pattern_iter )
ch = '%02x' % o
ch = next ( input_iter )
ch = None
ch2 , escaped = next ( input_iter )
ch2 = None
change = fn ( )
changed = False
changed = True
changes = autodetector . arrange_for_graph ( changes , loader . graph )
changes = autodetector . changes (  graph = loader . graph ,  trim_to_apps = app_labels or None ,  convert_apps = app_labels or None ,  )
changes = autodetector . changes ( graph = executor . loader . graph )
changes = dict (  ( app , [ Migration ( "custom" , app ) ] )  for app in app_labels  )
changeset = None
changeset = timestamp . strftime ( '%Y%m%d%H%M%S' )
char2number = { 'a' : '2' , 'b' : '2' , 'c' : '2' , 'd' : '3' , 'e' : '3' , 'f' : '3' ,  'g' : '4' , 'h' : '4' , 'i' : '4' , 'j' : '5' , 'k' : '5' , 'l' : '5' , 'm' : '6' ,  'n' : '6' , 'o' : '6' , 'p' : '7' , 'q' : '7' , 'r' : '7' , 's' : '7' , 't' : '8' ,  'u' : '8' , 'v' : '8' , 'w' : '9' , 'x' : '9' , 'y' : '9' , 'z' : '9' }
chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'
chars = []
chars = allow_lazy ( chars )
chars.append(ch)
charset = content_type_extra . get ( 'charset' )
charset = msg . get_charset ( ) . get_output_charset ( ) if msg . get_charset ( ) else 'utf-8'
check . tags = tags
check_for_language . cache_clear ( )
check_for_language = lambda x : True
check_for_migrations ( app_config , connection )
check_for_migrations ( app_config , connection )
check_for_migrations ( app_config , connection )
check_for_migrations ( app_config , connection )
check_for_migrations ( app_config , connection )
check_programs ( 'msguniq' , 'msgmerge' , 'msgattrib' )
check_programs ( 'xgettext' )
checkbox_id = self . clear_checkbox_id ( checkbox_name )
checkbox_name = self . clear_checkbox_name ( name )
checks = [ check for check in self . registered_checks  if hasattr ( check , 'tags' ) and set ( check . tags ) & set ( tags ) ]
checks = self . registered_checks
child_loggers . append ( existing [ i ] )
child_loggers = [ ]
child_nodelists = ( 'nodelist_loop' , 'nodelist_empty' )
child_nodelists = ( 'nodelist_true' , 'nodelist_false' )
child_nodelists = ( 'nodelist_true' , 'nodelist_false' )
child_nodelists = ( 'nodelist' , )
choice = self . choices [ idx ]
choice_input_class = CheckboxChoiceInput
choice_input_class = None
choice_input_class = RadioChoiceInput
choice_value , choice_label = choice
choices . insert ( 0 , none_value )
choices = ( ( '1' , ugettext_lazy ( 'Unknown' ) ) ,  ( '2' , ugettext_lazy ( 'Yes' ) ) ,  ( '3' , ugettext_lazy ( 'No' ) ) )
choices = [ ( i , i ) for i in range ( 1 , 32 ) ]
choices = [ ( i , i ) for i in self . years ]
choices = list ( chain ( self . choices , choices ) )
choices = list ( six . iteritems ( self . months ) )
choices = property ( _get_choices , _set_choices )
choices = property ( _get_choices , ChoiceField . _set_choices )
chunk += over_chunk
chunk = b'' . join ( chunks )
chunk = base64 . b64decode ( chunk )
chunk = handler . receive_data_chunk ( chunk ,  counters [ i ] )
chunk = next ( self )
chunk = self . _read_limited ( )
chunk_buffer = BytesIO ( chunk )
chunk_size = 1024
chunk_size = 64 * 2 ** 10
chunk_size = self . DEFAULT_CHUNK_SIZE
chunk_size = self . DEFAULT_CHUNK_SIZE
chunks . append ( bytes )
chunks = (  ( 60 * 60 * 24 * 365 , ungettext_lazy ( '%d year' , '%d years' ) ) ,  ( 60 * 60 * 24 * 30 , ungettext_lazy ( '%d month' , '%d months' ) ) ,  ( 60 * 60 * 24 * 7 , ungettext_lazy ( '%d week' , '%d weeks' ) ) ,  ( 60 * 60 * 24 , ungettext_lazy ( '%d day' , '%d days' ) ) ,  ( 60 * 60 , ungettext_lazy ( '%d hour' , '%d hours' ) ) ,  ( 60 , ungettext_lazy ( '%d minute' , '%d minutes' ) )  )
chunks = [ ]
class __proxy__ ( Promise ) :
class _HashedSeq ( list ) :
class _LazyDescr ( object ) :
class _LazyModule ( types . ModuleType ) :
class _MovedItems ( _LazyModule ) :
class _OFFSET ( Structure ) :
class _OFFSET_UNION ( Union ) :
class AdminEmailHandler ( logging . Handler ) :
class AppCommand ( BaseCommand ) :
class AppRegistryNotReady ( Exception ) :
class Archive ( object ) :
class ArchiveException ( Exception ) :
class AssignmentNode ( TagHelperNode ) :
class Atom1Feed ( SyndicationFeed ) :
class AutoEscapeControlNode ( Node ) :
class BadHeaderError ( ValueError ) :
class BadHeaderError ( ValueError ) :
class BadSerializer ( object ) :
class BadSignature ( Exception ) :
class BaseArchive ( object ) :
class BaseCache ( object ) :
class BaseCommand ( object ) :
class BaseConfigurator ( object ) :
class BaseContext ( object ) :
class BaseConverter ( object ) :
class BaseDatabaseCache ( BaseCache ) :
class BaseEmailBackend ( object ) :
class BaseForm ( object ) :
class BaseFormSet ( object ) :
class BaseHandler ( object ) :
class BaseInlineFormSet ( BaseModelFormSet ) :
class BaseLoader ( object ) :
class BaseMemcachedCache ( six . with_metaclass ( BaseMemcachedCacheMethods , BaseCache ) ) :
class BaseMemcachedCacheMethods ( RenameMethodsBase ) :
class BaseModelForm ( BaseForm ) :
class BaseModelFormSet ( BaseFormSet ) :
class BaseTemporalField ( Field ) :
class BaseValidator ( object ) :
class BlockContext ( object ) :
class BlockNode ( Node ) :
class BooleanField ( Field ) :
class BoundaryIter ( six . Iterator ) :
class BoundField ( object ) :
class CacheClass ( DatabaseCache ) :
class CacheClass ( DummyCache ) :
class CacheClass ( FileBasedCache ) :
class CacheClass ( LocMemCache ) :
class cached_property ( object ) :
class CachedDnsName ( object ) :
class CacheEntry ( object ) :
class CacheHandler ( object ) :
class CacheKeyWarning ( DjangoRuntimeWarning ) :
class CallbackFilter ( logging . Filter ) :
class CharField ( Field ) :
class CheckboxChoiceInput ( ChoiceInput ) :
class CheckboxFieldRenderer ( ChoiceFieldRenderer ) :
class CheckboxInput ( Widget ) :
class CheckboxSelectMultiple ( RendererMixin , SelectMultiple ) :
class CheckMessage ( object ) :
class CheckRegistry ( object ) :
class Choice ( list ) :
class ChoiceField ( Field ) :
class ChoiceFieldRenderer ( object ) :
class ChoiceInput ( SubWidget ) :
class ChunkIter ( six . Iterator ) :
class classonlymethod ( classmethod ) :
class ClearableFileInput ( FileInput ) :
class ComboField ( Field ) :
class Command ( AppCommand ) :
class Command ( AppCommand ) :
class Command ( AppCommand ) :
class Command ( BaseCommand ) :
class Command ( BaseCommand ) :
class Command ( BaseCommand ) :
class Command ( BaseCommand ) :
class Command ( BaseCommand ) :
class Command ( BaseCommand ) :
class Command ( BaseCommand ) :
class Command ( BaseCommand ) :
class Command ( CheckCommand ) :
class Command ( TemplateCommand ) :
class Command ( TemplateCommand ) :
class CommandError ( Exception ) :
class CommandParser ( ArgumentParser ) :
class CommentNode ( Node ) :
class ContentFile ( File ) :
class ContentNotRenderedError ( Exception ) :
class Context ( BaseContext ) :
class ContextDict ( dict ) :
class ContextPopException ( Exception ) :
class ConvertingDict ( dict ) :
class ConvertingList ( list ) :
class ConvertingTuple ( tuple ) :
class Critical ( CheckMessage ) :
class CsrfTokenNode ( Node ) :
class CycleNode ( Node ) :
class DatabaseCache ( BaseDatabaseCache ) :
class date ( real_date ) :
class DateField ( BaseTemporalField ) :
class DateFormat ( TimeFormat ) :
class DateInput ( DateTimeBaseInput ) :
class datetime ( real_datetime ) :
class DateTimeBaseInput ( TextInput ) :
class DateTimeField ( BaseTemporalField ) :
class DateTimeInput ( DateTimeBaseInput ) :
class Debug ( CheckMessage ) :
class DebugLexer ( Lexer ) :
class DebugNode ( Node ) :
class DebugNodeList ( NodeList ) :
class DebugParser ( Parser ) :
class DebugVariableNode ( VariableNode ) :
class DecimalField ( IntegerField ) :
class DeclarativeFieldsMetaclass ( MediaDefiningClass ) :
class DefaultCacheProxy ( object ) :
class DefaultStorage ( LazyObject ) :
class DefusedExpatParser ( _ExpatParser ) :
class DefusedXmlException ( ValueError ) :
class DeserializationError ( Exception ) :
class DeserializedObject ( object ) :
class Deserializer ( base . Deserializer ) :
class Deserializer ( six . Iterator ) :
class DictConfigurator ( BaseConfigurator ) :
class DictWrapper ( dict ) :
class DisallowedHost ( SuspiciousOperation ) :
class DisallowedRedirect ( SuspiciousOperation ) :
class DjangoJSONEncoder ( json . JSONEncoder ) :
class DjangoRuntimeWarning ( RuntimeWarning ) :
class DjangoSafeDumper ( SafeDumper ) :
class DjangoTranslation ( gettext_module . GNUTranslations ) :
class DjangoUnicodeDecodeError ( UnicodeDecodeError ) :
class DTDForbidden ( DefusedXmlException ) :
class dummy :
class DummyCache ( BaseCache ) :
class EmailBackend ( BaseEmailBackend ) :
class EmailBackend ( ConsoleEmailBackend ) :
class EmailField ( CharField ) :
class EmailInput ( TextInput ) :
class EmailMessage ( object ) :
class EmailMultiAlternatives ( EmailMessage ) :
class EmailValidator ( object ) :
class EmptyPage ( InvalidPage ) :
class Enclosure ( object ) :
class EndToken ( TokenBase ) :
class EntitiesForbidden ( DefusedXmlException ) :
class Error ( CheckMessage ) :
class ErrorDict ( dict ) :
class ErrorList ( UserList , list ) :
class EscapeBytes ( bytes , EscapeData ) :
class EscapeData ( object ) :
class EscapeText ( six . text_type , EscapeData ) :
class EventHandler ( pyinotify . ProcessEvent ) :
class ExtendsError ( Exception ) :
class ExtendsNode ( Node ) :
class ExternalReferenceForbidden ( DefusedXmlException ) :
class Field ( object ) :
class FieldError ( Exception ) :
class File ( FileProxyMixin ) :
class FileBasedCache ( BaseCache ) :
class FileField ( Field ) :
class FileInput ( Input ) :
class FilePathField ( ChoiceField ) :
class FileProxyMixin ( object ) :
class FileSystemStorage ( Storage ) :
class FileUploadHandler ( object ) :
class FilterExpression ( object ) :
class FilterNode ( Node ) :
class FirstOfNode ( Node ) :
class FixedOffset ( tzinfo ) :
class FixedOffset ( tzinfo ) :
class FixUnicode ( fixer_base . BaseFix ) :
class FloatField ( IntegerField ) :
class Form ( six . with_metaclass ( DeclarativeFieldsMetaclass , BaseForm ) ) :
class Formatter ( object ) :
class ForNode ( Node ) :
class GenericIPAddressField ( CharField ) :
class Group ( list ) :
class HiddenInput ( Input ) :
class HTMLParser ( _html_parser . HTMLParser ) :
class Http404 ( Exception ) :
class HttpRequest ( object ) :
class HttpResponse ( HttpResponseBase ) :
class HttpResponseBadRequest ( HttpResponse ) :
class HttpResponseBase ( six . Iterator ) :
class HttpResponseForbidden ( HttpResponse ) :
class HttpResponseGone ( HttpResponse ) :
class HttpResponseNotAllowed ( HttpResponse ) :
class HttpResponseNotFound ( HttpResponse ) :
class HttpResponseNotModified ( HttpResponse ) :
class HttpResponsePermanentRedirect ( HttpResponseRedirectBase ) :
class HttpResponseRedirect ( HttpResponseRedirectBase ) :
class HttpResponseRedirectBase ( HttpResponse ) :
class HttpResponseServerError ( HttpResponse ) :
class IfChangedNode ( Node ) :
class IfEqualNode ( Node ) :
class IfNode ( Node ) :
class IfParser ( object ) :
class ImageField ( FileField ) :
class ImageFile ( File ) :
class ImmutableList ( tuple ) :
class ImproperlyConfigured ( Exception ) :
class IncludeNode ( Node ) :
class InclusionNode ( TagHelperNode ) :
class Info ( CheckMessage ) :
class InlineForeignKeyField ( Field ) :
class InMemoryUploadedFile ( UploadedFile ) :
class Input ( Widget ) :
class InputStreamExhausted ( Exception ) :
class IntegerField ( Field ) :
class InterBoundaryIter ( six . Iterator ) :
class InvalidCacheBackendError ( ImproperlyConfigured ) :
class InvalidPage ( Exception ) :
class InvalidTemplateLibrary ( Exception ) :
class IPAddressField ( CharField ) :
class Iterator ( object ) :
class JsLexer ( Lexer ) :
class JsonResponse ( HttpResponse ) :
class JSONSerializer ( object ) :
class LabelCommand ( BaseCommand ) :
class lazy_property ( property ) :
class LazyObject ( object ) :
class LazyStream ( six . Iterator ) :
class Lexer ( object ) :
class Lexer ( object ) :
class Library ( object ) :
class LimitedStream ( object ) :
class Literal ( TokenBase ) :
class Loader ( BaseLoader ) :
class LoaderOrigin ( Origin ) :
class LoadNode ( Node ) :
class LocaleRegexProvider ( object ) :
class LocaleRegexURLResolver ( RegexURLResolver ) :
class LocalTimezone ( ReferenceLocalTimezone ) :
class LocalTimezone ( tzinfo ) :
class LocMemCache ( BaseCache ) :
class ManagementForm ( Form ) :
class ManagementUtility ( object ) :
class MaxLengthValidator ( BaseValidator ) :
class MaxValueValidator ( BaseValidator ) :
class Media ( object ) :
class MediaDefiningClass ( type ) :
class MemcachedCache ( BaseMemcachedCache ) :
class MemoryFileUploadHandler ( FileUploadHandler ) :
class MergeDict ( object ) :
class metaclass ( meta ) :
class MiddlewareNotUsed ( Exception ) :
class MIMEMixin ( ) :
class MinLengthValidator ( BaseValidator ) :
class MinValueValidator ( BaseValidator ) :
class MLStripper ( HTMLParser ) :
class ModelChoiceField ( ChoiceField ) :
class ModelChoiceIterator ( object ) :
class ModelForm ( six . with_metaclass ( ModelFormMetaclass , BaseModelForm ) ) :
class ModelFormMetaclass ( DeclarativeFieldsMetaclass ) :
class ModelFormOptions ( object ) :
class ModelMultipleChoiceField ( ModelChoiceField ) :
class Module_six_moves_urllib ( types . ModuleType ) :
class Module_six_moves_urllib_error ( _LazyModule ) :
class Module_six_moves_urllib_parse ( _LazyModule ) :
class Module_six_moves_urllib_request ( _LazyModule ) :
class Module_six_moves_urllib_response ( _LazyModule ) :
class Module_six_moves_urllib_robotparser ( _LazyModule ) :
class MovedAttribute ( _LazyDescr ) :
class MovedModule ( _LazyDescr ) :
class MultiPartParser ( object ) :
class MultiPartParserError ( Exception ) :
class MultipleChoiceField ( ChoiceField ) :
class MultipleHiddenInput ( HiddenInput ) :
class MultipleObjectsReturned ( Exception ) :
class MultiValueDict ( dict ) :
class MultiValueDictKeyError ( KeyError ) :
class MultiValueField ( Field ) :
class MultiWidget ( Widget ) :
class NoArgsCommand ( BaseCommand ) :
class Node ( object ) :
class Node ( object ) :
class NodeList ( list ) :
class NonCapture ( list ) :
class NoReverseMatch ( Exception ) :
class NowNode ( Node ) :
class NullBooleanField ( BooleanField ) :
class NullBooleanSelect ( Select ) :
class NullDevice :
class NumberAwareString ( resultclass ) :
class NumberInput ( TextInput ) :
class ObjectDoesNotExist ( Exception ) :
class Operator ( TokenBase ) :
class Options ( object ) :
class OrderedSet ( object ) :
class Origin ( object ) :
class OutputWrapper ( object ) :
class OVERLAPPED ( Structure ) :
class override ( object ) :
class Page ( collections . Sequence ) :
class PageNotAnInteger ( InvalidPage ) :
class Paginator ( object ) :
class Parser ( object ) :
class Parser ( object ) :
class PasswordInput ( TextInput ) :
class PermissionDenied ( Exception ) :
class Promise ( object ) :
class PyLibMCCache ( BaseMemcachedCache ) :
class QueryDict ( MultiValueDict ) :
class RadioChoiceInput ( ChoiceInput ) :
class RadioFieldRenderer ( ChoiceFieldRenderer ) :
class RadioSelect ( RendererMixin , Select ) :
class RawPostDataException ( Exception ) :
class ReferenceLocalTimezone ( tzinfo ) :
class RegexField ( CharField ) :
class RegexURLPattern ( LocaleRegexProvider ) :
class RegexURLResolver ( LocaleRegexProvider ) :
class RegexValidator ( object ) :
class RegroupNode ( Node ) :
class RemovedInDjango19Warning ( DeprecationWarning ) :
class RemovedInDjango20Warning ( PendingDeprecationWarning ) :
class RenameMethodsBase ( type ) :
class RenderContext ( BaseContext ) :
class RendererMixin ( object ) :
class RequestContext ( Context ) :
class RequireDebugFalse ( logging . Filter ) :
class RequireDebugTrue ( logging . Filter ) :
class Resolver404 ( Http404 ) :
class ResolverMatch ( object ) :
class Rss201rev2Feed ( RssFeed ) :
class RssFeed ( SyndicationFeed ) :
class RssUserland091Feed ( RssFeed ) :
class RWLock ( object ) :
class SafeBytes ( bytes , SafeData ) :
class SafeData ( object ) :
class SafeMIMEMessage ( MIMEMixin , MIMEMessage ) :
class SafeMIMEMultipart ( MIMEMixin , MIMEMultipart ) :
class SafeMIMEText ( MIMEMixin , MIMEText ) :
class SafeText ( six . text_type , SafeData ) :
class Select ( Widget ) :
class SelectDateWidget ( Widget ) :
class SelectMultiple ( Select ) :
class SerializationError ( Exception ) :
class Serializer ( base . Serializer ) :
class Serializer ( base . Serializer ) :
class Serializer ( object ) :
class Serializer ( PythonSerializer ) :
class Serializer ( PythonSerializer ) :
class SerializerDoesNotExist ( KeyError ) :
class SignatureExpired ( BadSignature ) :
class Signer ( object ) :
class SimpleCookie ( http_cookies . SimpleCookie ) :
class SimpleLazyObject ( LazyObject ) :
class SimpleNode ( TagHelperNode ) :
class SimplerXMLGenerator ( XMLGenerator ) :
class SimpleTemplateResponse ( HttpResponse ) :
class SimpleUploadedFile ( InMemoryUploadedFile ) :
class SingleZipReader ( zipfile . ZipFile ) :
class SkipFile ( UploadFileException ) :
class SlugField ( CharField ) :
class SortedDict ( dict ) :
class SpacelessNode ( Node ) :
class SplitDateTimeField ( MultiValueField ) :
class SplitDateTimeWidget ( MultiWidget ) :
class SplitHiddenDateTimeWidget ( SplitDateTimeWidget ) :
class SsiNode ( Node ) :
class StopFutureHandlers ( UploadFileException ) :
class StopUpload ( UploadFileException ) :
class Storage ( object ) :
class StreamingBuffer ( object ) :
class StreamingHttpResponse ( HttpResponseBase ) :
class StringOrigin ( Origin ) :
class SubWidget ( object ) :
class SuspiciousFileOperation ( SuspiciousOperation ) :
class SuspiciousMultipartForm ( SuspiciousOperation ) :
class SuspiciousOperation ( Exception ) :
class SyndicationFeed ( object ) :
class TagHelperNode ( Node ) :
class Tags ( object ) :
class TarArchive ( BaseArchive ) :
class Template ( object ) :
class TemplateCommand ( BaseCommand ) :
class TemplateDoesNotExist ( Exception ) :
class TemplateEncodingError ( Exception ) :
class TemplateIfParser ( IfParser ) :
class TemplateLiteral ( Literal ) :
class TemplateResponse ( SimpleTemplateResponse ) :
class TemplateSyntaxError ( Exception ) :
class TemplateTagNode ( Node ) :
class TemporaryFile ( FileProxyMixin ) :
class TemporaryFileUploadHandler ( FileUploadHandler ) :
class TemporaryUploadedFile ( UploadedFile ) :
class Textarea ( Widget ) :
class TextInput ( Input ) :
class TextNode ( Node ) :
class TimeField ( BaseTemporalField ) :
class TimeFormat ( Formatter ) :
class TimeInput ( DateTimeBaseInput ) :
class TimestampSigner ( Signer ) :
class Tok ( object ) :
class Token ( object ) :
class TokenBase ( object ) :
class TokenParser ( object ) :
class Trans ( object ) :
class TranslatableFile ( object ) :
class TranslatorCommentWarning ( SyntaxWarning ) :
class Truncator ( SimpleLazyObject ) :
class TypedChoiceField ( ChoiceField ) :
class TypedMultipleChoiceField ( MultipleChoiceField ) :
class UnreadablePostError ( IOError ) :
class UnrecognizedArchiveFormat ( ArchiveException ) :
class UploadedFile ( File ) :
class UploadFileException ( Exception ) :
class URLField ( CharField ) :
class URLInput ( TextInput ) :
class URLNode ( Node ) :
class URLValidator ( RegexValidator ) :
class UTC ( tzinfo ) :
class ValidationError ( Exception ) :
class Variable ( object ) :
class VariableDoesNotExist ( Exception ) :
class VariableNode ( Node ) :
class VerbatimNode ( Node ) :
class ViewDoesNotExist ( Exception ) :
class warn_about_renamed_method ( object ) :
class Warning ( CheckMessage ) :
class Widget ( six . with_metaclass ( MediaDefiningClass ) ) :
class WidthRatioNode ( Node ) :
class WindowsError ( Exception ) :
class WithNode ( Node ) :
class WSGIHandler ( base . BaseHandler ) :
class WSGIRequest ( http . HttpRequest ) :
class WSGIRequestHandler ( simple_server . WSGIRequestHandler , object ) :
class WSGIServer ( simple_server . WSGIServer , object ) :
class X ( object ) :
class ZipArchive ( BaseArchive ) :
class_name = base . __name__
class_name = model . __name__ + str ( 'Form' )
class_types = ( type , types . ClassType )
class_types = type ,
clean = lambda self , x : len ( x )
clean = lambda self , x : x
clean_data . append ( field . clean ( field_value ) )
clean_data = [ ]
cleaned = self . clean ( value )
cleaned_data = form . cleaned_data
cleaned_data = self . clean ( )
cleaned_line = comment_re . sub ( r"\1" , line ) . strip ( )
clear_checkbox_label = ugettext_lazy ( 'Clear' )
client . behaviors = self . _options
client = self . _lib . Client ( self . _servers )
closable . close ( )
close = self . closed
close = True
closed = property ( _get_closed )
closing_tag , tagname , self_closing = tag . groups ( )
cls . __bytes__ = cls . __bytes_cast
cls . __dispatch [ klass ] [ funcname ] = method
cls . __dispatch [ klass ] = { }
cls . __dispatch [ resultclass ] = { }
cls . __dispatch = { }
cls . __str__ = cls . __bytes_cast
cls . __str__ = cls . __text_cast
cls . __unicode__ = cls . __text_cast
cls . _delegate_bytes = bytes in resultclasses
cls . _delegate_text = six . text_type in resultclasses
cls = extension_map . get ( ext )
cls = extension_map . get ( tail_ext )
cls = None
cmatch = constant_re . match ( parts [ 0 ] )
cmatches = constant_re . findall ( t . contents )
cmd_options = vars ( options )
cmp_fmt = None
cmp_fmt = parts [ - 1 ]
cmp_fmts = list ( self . compression_formats . keys ( ) ) if cmp_fmt is None else [ cmp_fmt ]
code . interact ( local = imported_objects )
code = 'invalid'
code = 'invalid'
code = 'limit_value'
code = 'max_length'
code = 'max_value'
code = 'min_length'
code = 'min_value'
code_list . append ( background [ v ] )
code_list . append ( foreground [ v ] )
code_list . append ( opt_dict [ o ] )
code_list = [ ]
codecs . lookup ( content_params [ 'charset' ] )
codecs . lookup ( encoding )
collect . extend ( _builtin_context_processors )
collect . extend ( settings . TEMPLATE_CONTEXT_PROCESSORS )
collect = [ ]
color_names = ( 'black' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' )
color_settings = termcolors . parse_color_setting ( DJANGO_COLORS )
colors . reverse ( )
colors = styles . pop ( ) . split ( '/' )
column_name = row [ 0 ]
combined = Media ( )
comma_separated_int_list_re = re . compile ( '^[\d,]+$' )
command , source = self . command_stack . pop ( )
command . stdout . write ( 'processing file %s in %s\n' % ( self . file , self . dirpath ) )
command . stdout . write ( errors )
command = app_name
command = load_command_class ( app_name , name )
command = token . contents . split ( ) [ 0 ]
command_dir = os . path . join ( management_dir , 'commands' )
commands . update ( { name : app_config . name for name in find_commands ( path ) } )
commands = { name : 'django.core' for name in find_commands ( __path__ [ 0 ] ) }
commands = get_commands ( )
commands_dict [ app ] . append ( name )
commands_dict = collections . defaultdict ( lambda : [ ] )
comment . append ( t . contents )
comment = [ ]
comment_lineno_cache = None
comment_lineno_cache = None
comment_lineno_cache = t . lineno
comment_notes . append ( 'AutoField?' )
comment_notes . extend ( field_notes )
comment_notes . extend ( notes )
comment_notes = [ ]
comment_re = re . compile ( r"^((?:'[^']*'|[^'])*?)--.*$" )
COMMENT_TAG_END = '#}'
COMMENT_TAG_START = '{#'
common_ancestor = level [ 0 ]
common_ancestor = None
common_prefix = None
common_prefix = prefix
compare = lambda self , a , b : a < b
compare = lambda self , a , b : a > b
compare = lambda self , a , b : a is not b
compare_to = [ var . resolve ( context , True ) for var in self . _varlist ]
compare_to = nodelist_true_output = self . nodelist_true . render ( context )
compare_to = None
compatibility = 'compatibility'
compile_func . __doc__ = func . __doc__
compile_func . __doc__ = func . __doc__
compile_func . __doc__ = func . __doc__
compile_func = partial ( generic_tag_compiler ,  params = params , varargs = varargs , varkw = varkw ,  defaults = defaults , name = function_name ,  takes_context = takes_context , node_class = InclusionNode )
compile_func = partial ( generic_tag_compiler ,  params = params , varargs = varargs , varkw = varkw ,  defaults = defaults , name = function_name ,  takes_context = takes_context , node_class = SimpleNode )
compile_func = self . tags [ command ]
compiled_parent = self . get_parent ( context )
compiled_regex = re . compile ( regex , re . UNICODE )
compiled_result = compile_func ( self , token )
compressed = zlib . compress ( data )
concrete_model = obj . _meta . concrete_model
condition = TemplateIfParser ( parser , bits ) . parse ( )
conditions_nodelists . append ( ( condition , nodelist ) )
conditions_nodelists . append ( ( None , nodelist ) )
conditions_nodelists = [ ( condition , nodelist ) ]
conf = settings . CACHES [ backend ]
config [ '()' ] = factory
config [ 'address' ] = self . as_tuple ( config [ 'address' ] )
config [ 'fmt' ] = config . pop ( 'format' )
config [ 'mailhost' ] = self . as_tuple ( config [ 'mailhost' ] )
config [ 'target' ] = self . config [ 'handlers' ] [ config [ 'target' ] ]
config = self . config
confirm = 'yes'
confirm = input ( 'Please enter either "yes" or "no": ' )
confirm = input ( """You have requested a flush of the database. This will IRREVERSIBLY DESTROY all data currently in the %r database, and return each table to an empty state. Are you sure you want to do this?     Type 'yes' to continue, or 'no' to cancel: """ % connection . settings_dict [ 'NAME' ] )
confirm = input ( msg )
conflicts = executor . loader . detect_conflicts ( )
conflicts = loader . detect_conflicts ( )
connection . check_constraints ( table_names = table_names )
connection . client . runshell ( )
connection . close ( )
connection = connection or get_connection ( username = auth_user ,  password = auth_password ,  fail_silently = fail_silently )
connection = connection or get_connection ( username = auth_user ,  password = auth_password ,  fail_silently = fail_silently )
connection = connections [ database ]
connection = connections [ db ]
connection = connections [ options . get ( 'database' , DEFAULT_DB_ALIAS ) ]
connection = connections [ options . get ( 'database' ) ]
connection = connections [ options . get ( 'database' ) ]
connection = connections [ options [ 'database' ] ]
connection = connections [ options [ 'database' ] ]
connection = connections [ options [ 'database' ] ]
connection = connections [ options [ 'database' ] ]
connection = connections [ options [ 'database' ] ]
connection = connections [ self . using ]
connection_class = smtplib . SMTP_SSL if self . use_ssl else smtplib . SMTP
connection_params [ 'timeout' ] = self . timeout
connection_params = { 'local_hostname' : DNS_NAME . get_fqdn ( ) }
connections [ self . using ] . close ( )
constant_arg , var_arg = match . group ( "constant_arg" , "var_arg" )
constant_re = re . compile ( r"""_\(((?:".*?")|(?:'.*?'))\)""" )
constant_string = constant_string . replace ( "\n" , "" )
constant_string = r""" (?:%(i18n_open)s%(strdq)s%(i18n_close)s| %(i18n_open)s%(strsq)s%(i18n_close)s| %(strdq)s| %(strsq)s) """ % {  'strdq' : r'"[^"\\]*(?:\\.[^"\\]*)*"' ,  'strsq' : r"'[^'\\]*(?:\\.[^'\\]*)*'" ,  'i18n_open' : re . escape ( "_(" ) ,  'i18n_close' : re . escape ( ")" ) ,  }
construct_instance_exclude . append ( name )
construct_instance_exclude = list ( exclude )
consume_next = False
consume_next = True
contains_nontext = False
content = ''
content = '' . join ( comment )
content = content . decode ( 'utf-8' )
content = content . encode ( 'utf-8' )
content = content . message ( )
content = content or b''
content = f . read ( )
content = File ( content )
content = force_bytes ( content )
content = message_from_string ( content )
content = template . render ( context )
content = template . render ( context )
content = template_file . read ( )
content = templatize ( src_data , orig_file [ 2 : ] )
content = token_string [ 2 : - 2 ] . strip ( )
content_disposition = info . get ( 'content-disposition' )
content_length = 0
content_length = int ( environ . get ( 'CONTENT_LENGTH' ) )
content_length = int ( META . get ( 'HTTP_CONTENT_LENGTH' , META . get ( 'CONTENT_LENGTH' , 0 ) ) )
content_length = int ( meta_data . get ( 'content-length' ) [ 0 ] )
content_length = None
content_subtype = 'plain'
content_type , content_type_extra = meta_data . get ( 'content-type' , ( '' , { } ) )
content_type = "%s; charset=%s" % ( settings . DEFAULT_CONTENT_TYPE ,  self . _charset )
content_type = content_type . strip ( )
content_type = info . get ( 'content-type' )
content_type = META . get ( 'HTTP_CONTENT_TYPE' , META . get ( 'CONTENT_TYPE' , '' ) )
contents = conditional_escape ( contents )
contents = contents or self . label
contents = format_html ( '{0}{1}' , contents , label_suffix )
contents = format_html ( '<label{0}>{1}</label>' , attrs , contents )
contents = one_percent_re . sub ( '%%' , t . contents )
Context . __init__ ( self , dict_ , current_app = current_app ,  use_l10n = use_l10n , use_tz = use_tz )
context . autoescape = old_setting
context . autoescape = self . setting
context . dicts . append ( self )
context . pop ( )
context . render_context . pop ( )
context . render_context . push ( )
context . render_context [ BLOCK_CONTEXT_KEY ] = BlockContext ( )
context . render_context [ self ] = itertools_cycle ( self . cyclevars )
context . update ( unpacked_vars )
context [ 'block' ] = block
context [ 'block' ] = self
context [ self . asvar ] = result
context [ self . asvar ] = url
context [ self . loopvars [ 0 ] ] = item
context [ self . target_var ] = func ( * resolved_args , ** resolved_kwargs )
context [ self . var_name ] = [  { 'grouper' : key , 'list' : list ( val ) }  for key , val in  groupby ( obj_list , lambda obj : self . resolve_expression ( obj , context ) )  ]
context [ self . var_name ] = [ ]
context [ self . var_name ] = obj
context [ self . variable_name ] = value
context = Context ( dict ( options , ** {  base_name : name ,  base_directory : top_dir ,  'docs_version' : docs_version ,  } ) , autoescape = False )
context = self . resolve_context ( self . context_data )
context_extras [ 'debug' ] = True
context_extras [ 'LANGUAGE_BIDI' ] = translation . get_language_bidi ( )
context_extras [ 'LANGUAGE_CODE' ] = translation . get_language ( )
context_extras [ 'LANGUAGES' ] = settings . LANGUAGES
context_extras [ 'sql_queries' ] = connection . queries
context_extras = { }
context_match = context_re . match ( bmatch . group ( 1 ) )
context_match = context_re . match ( imatch . group ( 2 ) )
context_re = re . compile ( r"""^\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?'))\s*""" )
CONTEXT_SEPARATOR = "\x04"
continue
continue
continue
continue
continue
continue
continue
continue
continue
convert = {  '__lt__' : [ ( '__gt__' , lambda self , other : not ( self < other or self == other ) ) ,  ( '__le__' , lambda self , other : self < other or self == other ) ,  ( '__ge__' , lambda self , other : not self < other ) ] ,  '__le__' : [ ( '__ge__' , lambda self , other : not self <= other or self == other ) ,  ( '__lt__' , lambda self , other : self <= other and not self == other ) ,  ( '__gt__' , lambda self , other : not self <= other ) ] ,  '__gt__' : [ ( '__lt__' , lambda self , other : not ( self > other or self == other ) ) ,  ( '__ge__' , lambda self , other : self > other or self == other ) ,  ( '__le__' , lambda self , other : not self > other ) ] ,  '__ge__' : [ ( '__le__' , lambda self , other : ( not self >= other ) or self == other ) ,  ( '__gt__' , lambda self , other : self >= other and not self == other ) ,  ( '__lt__' , lambda self , other : not self >= other ) ]  }
CONVERT_PATTERN = re . compile ( r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$' )
converter = connection . introspection . table_name_converter
converter = getattr ( self , converter )
converter = self . value_converters . get ( prefix , None )
cookie_value = self . COOKIES [ key ]
cookiedict [ key ] = c . get ( key ) . value
cookiedict = { }
cookies = '<could not parse>'
cookies = ( pformat ( COOKIES_override )  if COOKIES_override is not None  else pformat ( request . COOKIES ) )
copystat ( old_file_name , new_file_name )
count = property ( _get_count )
count = since // seconds
counters [ i ] += chunk_length
counters = [ 0 ] * len ( handlers )
create_bound_method = types . MethodType
create_models = set ( itertools . chain ( * manifest . values ( ) ) )
created_models . add ( model )
created_models = [ ]
created_models = self . sync_apps ( connection , executor . loader . unmigrated_apps )
created_models = set ( )
creation_counter = 0
CRITICAL = 50
criticals = [ e for e in all_issues if checks . CRITICAL <= e . level ]
csrf_token = context . get ( 'csrf_token' , None )
csrf_token = context . get ( 'csrf_token' , None )
css_classes = bf . css_classes ( )
ctx . update ( force_bytes ( value ) )
ctx = hashlib . md5 ( )
ctypes , opts = parse_header ( content_type . encode ( 'ascii' ) )
cull_frequency = params . get ( 'cull_frequency' , options . get ( 'CULL_FREQUENCY' , 3 ) )
cull_num = num // self . _cull_frequency
cur_lineno = t . lineno + t . contents . count ( '\n' )
curr = ''
curr = cwords [ cword - 1 ]
current = context
current = current ( )
current = current [ bit ]
current = current [ int ( bit ) ]
current = getattr ( current , bit )
current = settings . TEMPLATE_STRING_IF_INVALID
current = settings . TEMPLATE_STRING_IF_INVALID
current_chunk = None
current_chunk = old_file . read ( chunk_size )
current_expires = result [ 1 ]
current_expires = typecast_timestamp ( str ( current_expires ) )
current_fields . append ( ( key , value ) )
current_fields . sort ( key = lambda x : x [ 1 ] . creation_counter )
current_fields = [ ]
current_len += 1
current_len = 0
current_timezone = timezone . get_current_timezone ( )
current_timezone = timezone . get_current_timezone ( )
current_uri = '{scheme}://{host}{path}' . format ( scheme = self . scheme ,  host = self . get_host ( ) ,  path = self . path )
current_version = sys . version_info
curs . execute ( "\n" . join ( full_statement ) )
curs . execute ( statement )
cursor . close ( )
cursor . close ( )
cursor . execute (  connections [ db ] . ops . cache_key_culling_sql ( ) % table ,  [ cull_num ] )
cursor . execute ( 'DELETE FROM %s' % table )
cursor . execute ( "DELETE FROM %s "  "WHERE cache_key < %%s" % table ,  [ cursor . fetchone ( ) [ 0 ] ] )
cursor . execute ( "DELETE FROM %s "  "WHERE cache_key = %%s" % table , [ key ] )
cursor . execute ( "DELETE FROM %s WHERE cache_key = %%s" % table , [ key ] )
cursor . execute ( "DELETE FROM %s WHERE expires < %%s" % table ,  [ connections [ db ] . ops . value_to_db_datetime ( now ) ] )
cursor . execute ( "INSERT INTO %s (cache_key, value, expires) "  "VALUES (%%s, %%s, %%s)" % table ,  [ key , b64encoded , exp ] )
cursor . execute ( "SELECT cache_key FROM %s "  "WHERE cache_key = %%s and expires > %%s" % table ,  [ key , connections [ db ] . ops . value_to_db_datetime ( now ) ] )
cursor . execute ( "SELECT cache_key, expires FROM %s "  "WHERE cache_key = %%s" % table , [ key ] )
cursor . execute ( "SELECT cache_key, value, expires FROM %s "  "WHERE cache_key = %%s" % table , [ key ] )
cursor . execute ( "SELECT COUNT(*) FROM %s" % table )
cursor . execute ( "SELECT COUNT(*) FROM %s" % table )
cursor . execute ( "UPDATE %s SET value = %%s, expires = %%s "  "WHERE cache_key = %%s" % table ,  [ b64encoded , exp , key ] )
cursor . execute ( line )
cursor . execute ( sql )
cursor . execute ( sql )
cursor . execute ( sql )
cursor . execute ( statement )
cursor = connection . cursor ( )
cursor = connection . cursor ( )
cursor = connection . cursor ( )
cursor = None
custom_sql = custom_sql_for_model ( model , no_style ( ) , connection )
cword = int ( os . environ [ 'COMP_CWORD' ] )
cwords = os . environ [ 'COMP_WORDS' ] . split ( ) [ 1 : ]
cycle_iter = context . render_context [ self ]
d [ k ] = val
d += '0x'
d = ',%s' % datetime_safe . new_datetime ( date ) . strftime ( '%Y-%m-%d' )
d = ''
d = { }
d = d [ idx ]
d = d [ m . groups ( ) [ 0 ] ]
d = d [ n ]
d = data . get ( self . day_field % name )
d = datetime . datetime ( d . year , d . month , d . day )
d = Decimal ( force_text ( float ( text ) ) )
d = Decimal ( input_val )
d = get_deserializer ( format )
d = m . groupdict ( )
d = self . config [ m . groups ( ) [ 0 ] ]
daemon_kwargs [ 'err_log' ] = options [ 'errlog' ]
daemon_kwargs [ 'out_log' ] = options [ 'outlog' ]
daemon_kwargs [ 'umask' ] = int ( options [ 'umask' ] , 8 )
daemon_kwargs = { }
daemonize = ( wsgi_opts [ 'bindAddress' ] is not None )
daemonize = False
daemonize = True
DARK_PALETTE = 'dark'
data [ "pk" ] = smart_text ( obj . _get_pk_val ( ) , strings_only = True )
data [ f . name ] = [ ]
data [ f . name ] = [ item . pk for item in qs ]
data [ f . name ] = f . value_from_object ( instance )
data [ f . name ] = list ( qs . values_list ( 'pk' , flat = True ) )
data [ field . attname ] = field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )
data [ field . attname ] = None
data [ field . attname ] = self . _handle_fk_field_node ( field_node , field )
data [ field . attname ] = value
data [ field . name ] = field . to_python ( field_value )
data [ field . name ] = value
data [ Model . _meta . pk . attname ] = Model . _meta . pk . to_python (  node . getAttribute ( 'pk' ) )
data [ Model . _meta . pk . attname ] = Model . _meta . pk . to_python ( d . get ( "pk" , None ) )
data = ( form . cleaned_data [ field ] , ) + date_data
data = [ ]
data = {  "model" : smart_text ( obj . _meta ) ,  "fields" : self . _current ,  }
data = { }
data = { }
data = b64_decode ( base64d )
data = base64 . b64decode ( raw_data )
data = bool ( data )
data = BytesIO ( self . _body )
data = compressed
data = conditional_escape ( arg ) . join ( value )
data = data . encode ( fp . encoding , errors )
data = data . replace ( microsecond = 0 )
data = data ( )
data = data or [ ]
data = field_stream . read ( )
data = file . read ( chunk_size )
data = json . dumps ( data , cls = encoder )
data = method ( self , * args , ** kwargs )
data = None
data = obj_dict . pop ( '_data' , { } )
data = raw_data
data = self
data = self . _archive . read ( name )
data = self . _coerce ( data )
data = self . _prepare_data ( data )
data = self . field . bound_data (  self . data , self . form . initial . get ( self . name , self . field . initial )  )
data = self . flo . read ( self . chunk_size )
data = self . form . initial . get ( self . name , self . field . initial )
data = self . read ( chunk_size )
data = self . to_python ( data )
data = serializer ( ) . dumps ( obj )
data = str ( data )
data = zlib . decompress ( data )
data_set = set ( force_text ( value ) for value in data )
data_set = set ( force_text ( value ) for value in data )
data_value = data if data is not None else ''
data_value = data if data is not None else ''
data_value = field . widget . value_from_datadict ( self . data , self . files , prefixed_name )
database = options . get ( 'database' )
databases = [ self . using , None ]
date = datetime_safe . new_datetime ( date )
date = datetime_safe . new_datetime ( date )
date = form . cleaned_data [ unique_for ]
date_data = ( date . year , date . month , date . day )
date_data = ( getattr ( form . cleaned_data [ unique_for ] , lookup ) , )
date_keys = ( 'updateddate' , 'pubdate' )
date_re = re . compile (  r'(?P<year>\d{4})-(?P<month>\d{1,2})-(?P<day>\d{1,2})$'  )
date_value = datetime . date ( int ( y ) , int ( m ) , int ( d ) )
date_value = datetime_safe . new_date ( date_value )
datetime_re = re . compile (  r'(?P<year>\d{4})-(?P<month>\d{1,2})-(?P<day>\d{1,2})'  r'[T ](?P<hour>\d{1,2}):(?P<minute>\d{1,2})'  r'(?::(?P<second>\d{1,2})(?:\.(?P<microsecond>\d{1,6})\d{0,6})?)?'  r'(?P<tzinfo>Z|[+-]\d{2}(?::?\d{2})?)?$'  )
DateTimeAwareJSONEncoder = DjangoJSONEncoder
day = int ( m . group ( 'day' ) )
day_field = '%s_day'
day_of_year = self . z ( )
days = ( 'Mon' , 'Tue' , 'Wed' , 'Thu' , 'Fri' , 'Sat' , 'Sun' )
db = options . get ( 'database' )
db = options . get ( 'database' )
db = options . pop ( 'using' , DEFAULT_DB_ALIAS )
db = router . db_for_read ( self . cache_model_class )
db = router . db_for_read ( self . cache_model_class )
db = router . db_for_write ( self . cache_model_class )
db_module = 'django.db'
db_name = connection . creation . create_test_db ( verbosity = verbosity , autoclobber = not interactive , serialize = False )
deactivate ( )
deactivate = deactivate_all = lambda : None
deactivate_all ( )
DEBUG = 10
dec_part = dec_part + ( '0' * ( decimal_pos - len ( dec_part ) ) )
dec_part = decimal_sep + dec_part
decimal_digits = '0123456789'
decimal_separator = get_format ( 'DECIMAL_SEPARATOR' )
decimals = abs ( exponent )
declared_fields . pop ( attr )
decompress = True
decorated = Node ( syms . decorated , [ decorator , klass ] , prefix = node . prefix )
decorator = Node ( syms . decorator , [ Leaf ( token . AT , "@" ) , Name ( 'python_2_unicode_compatible' ) ] )
def __add__ ( self , other ) :
def __add__ ( self , rhs ) :
def __bool__ ( self ) :
def __bool__ ( self ) :
def __bytes_cast ( self ) :
def __call__ ( self , * args , ** kwargs ) :
def __call__ ( self , environ , start_response ) :
def __call__ ( self , f ) :
def __call__ ( self , template_name , template_dirs = None ) :
def __call__ ( self , value ) :
def __cast ( self ) :
def __contains__ ( self , item ) :
def __contains__ ( self , item ) :
def __contains__ ( self , key ) :
def __contains__ ( self , key ) :
def __contains__ ( self , key ) :
def __contains__ ( self , other ) :
def __copy__ ( self ) :
def __copy__ ( self ) :
def __deepcopy__ ( self , memo ) :
def __deepcopy__ ( self , memo ) :
def __deepcopy__ ( self , memo ) :
def __deepcopy__ ( self , memo ) :
def __deepcopy__ ( self , memo ) :
def __deepcopy__ ( self , memo = None ) :
def __deepcopy__ ( self , memodict ) :
def __del__ ( self ) :
def __delattr__ ( self , name ) :
def __delattr__ ( self , name ) :
def __delitem__ ( self , header ) :
def __delitem__ ( self , key ) :
def __delitem__ ( self , key ) :
def __dir__ ( self ) :
def __enter__ ( self ) :
def __enter__ ( self ) :
def __enter__ ( self ) :
def __eq__ ( self , other ) :
def __eq__ ( self , other ) :
def __eq__ ( self , other ) :
def __eq__ ( self , other ) :
def __eq__ ( self , other ) :
def __eq__ ( self , other ) :
def __eq__ ( self , other ) :
def __exit__ ( self , * args , ** kwargs ) :
def __exit__ ( self , exc , value , tb ) :
def __exit__ ( self , exc_type , exc_value , tb ) :
def __exit__ ( self , exc_type , exc_value , traceback ) :
def __exit__ ( self , exc_type , exc_value , traceback ) :
def __exit__ ( self , exc_type , exc_value , traceback ) :
def __get__ ( self , instance , owner ) :
def __get__ ( self , instance , type = None ) :
def __get__ ( self , obj , tp ) :
def __getattr__ ( self , attr ) :
def __getattr__ ( self , attr ) :
def __getattr__ ( self , name ) :
def __getattr__ ( self , name ) :
def __getattr__ ( self , real_name ) :
def __getinitargs__ ( self ) :
def __getitem__ ( self , alias ) :
def __getitem__ ( self , header ) :
def __getitem__ ( self , i ) :
def __getitem__ ( self , idx ) :
def __getitem__ ( self , index ) :
def __getitem__ ( self , index ) :
def __getitem__ ( self , index ) :
def __getitem__ ( self , key ) :
def __getitem__ ( self , key ) :
def __getitem__ ( self , key ) :
def __getitem__ ( self , name ) :
def __getitem__ ( self , name ) :
def __getstate__ ( self ) :
def __hash__ ( self ) :
def __html__ ( self ) :
def __init__ ( self , _subtype = 'mixed' , boundary = None , _subparts = None , encoding = None , ** _params ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * args , ** kwargs ) :
def __init__ ( self , * dicts ) :
def __init__ ( self , args , kw ) :
def __init__ ( self , argv = None ) :
def __init__ ( self , attrs = None , check_test = None ) :
def __init__ ( self , attrs = None , choices = ( ) ) :
def __init__ ( self , attrs = None , date_format = None , time_format = None ) :
def __init__ ( self , attrs = None , date_format = None , time_format = None ) :
def __init__ ( self , attrs = None , format = None ) :
def __init__ ( self , attrs = None , render_value = False ) :
def __init__ ( self , attrs = None , years = None , months = None , empty_label = None ) :
def __init__ ( self , attrs = None ) :
def __init__ ( self , attrs = None ) :
def __init__ ( self , callback ) :
def __init__ ( self , children = None , connector = None , negated = False ) :
def __init__ ( self , choices = ( ) , required = True , widget = None , label = None ,  initial = None , help_text = '' , * args , ** kwargs ) :
def __init__ ( self , class_name , old_method_name , new_method_name , deprecation_warning ) :
def __init__ ( self , cmd , ** kwargs ) :
def __init__ ( self , conditions_nodelists ) :
def __init__ ( self , config ) :
def __init__ ( self , connection_reset = False ) :
def __init__ ( self , content , name = None ) :
def __init__ ( self , content ) :
def __init__ ( self , content = b'' , * args , ** kwargs ) :
def __init__ ( self , content_type = None , status = None , reason = None ) :
def __init__ ( self , context , * args , ** kwargs ) :
def __init__ ( self , context , base , sysid , pubid ) :
def __init__ ( self , convert_charrefs = False , ** kwargs ) :
def __init__ ( self , cyclevars , variable_name = None , silent = False ) :
def __init__ ( self , data , encoder = DjangoJSONEncoder , safe = True , ** kwargs ) :
def __init__ ( self , data , func , prefix ) :
def __init__ ( self , data = None , files = None , auto_id = 'id_%s' , prefix = None ,  initial = None , error_class = ErrorList , label_suffix = None ,  empty_permitted = False , instance = None ) :
def __init__ ( self , data = None , files = None , auto_id = 'id_%s' , prefix = None ,  initial = None , error_class = ErrorList , label_suffix = None ,  empty_permitted = False ) :
def __init__ ( self , data = None , files = None , auto_id = 'id_%s' , prefix = None ,  initial = None , error_class = ErrorList ) :
def __init__ ( self , data = None , files = None , auto_id = 'id_%s' , prefix = None ,  queryset = None , ** kwargs ) :
def __init__ ( self , data = None , files = None , instance = None ,  save_as_new = False , prefix = None , queryset = None , ** kwargs ) :
def __init__ ( self , data = None ) :
def __init__ ( self , dict_ = None , autoescape = True , current_app = None ,  use_l10n = None , use_tz = None ) :
def __init__ ( self , dict_ = None ) :
def __init__ ( self , digits , sign = '-' ) :
def __init__ ( self , dir , params ) :
def __init__ ( self , dirpath , file_name , locale_dir ) :
def __init__ ( self , display_name , loader , name , dirs ) :
def __init__ ( self , dt ) :
def __init__ ( self , environ ) :
def __init__ ( self , exception ) :
def __init__ ( self , fail_silently = False , ** kwargs ) :
def __init__ ( self , field ) :
def __init__ ( self , fields = ( ) , * args , ** kwargs ) :
def __init__ ( self , fields = ( ) , * args , ** kwargs ) :
def __init__ ( self , file , field_name , name , content_type , size , charset , content_type_extra = None ) :
def __init__ ( self , file , name = None ) :
def __init__ ( self , file ) :
def __init__ ( self , file = None , name = None , content_type = None , size = None , charset = None , content_type_extra = None ) :
def __init__ ( self , filepath , parsed ) :
def __init__ ( self , filter_expr , nodelist ) :
def __init__ ( self , filter_expression ) :
def __init__ ( self , flo , chunk_size = 64 * 1024 ) :
def __init__ ( self , form , field , name ) :
def __init__ ( self , format_string ) :
def __init__ ( self , func , args , kwargs , url_name = None , app_name = None , namespaces = None ) :
def __init__ ( self , func , name = None ) :
def __init__ ( self , func ) :
def __init__ ( self , host , * args , ** kwargs ) :
def __init__ ( self , host = None , port = None , username = None , password = None ,  use_tls = None , fail_silently = False , use_ssl = None , timeout = None ,  ** kwargs ) :
def __init__ ( self , include_html = False , email_backend = None ) :
def __init__ ( self , initlist = None , error_class = None ) :
def __init__ ( self , input_date_formats = None , input_time_formats = None , * args , ** kwargs ) :
def __init__ ( self , input_formats = None , * args , ** kwargs ) :
def __init__ ( self , iterable = None ) :
def __init__ ( self , key = None , sep = ':' , salt = None ) :
def __init__ ( self , key_to_list_mapping = ( ) ) :
def __init__ ( self , language , deactivate = False ) :
def __init__ ( self , language ) :
def __init__ ( self , level , msg , hint = None , obj = None , id = None ) :
def __init__ ( self , lexer ) :
def __init__ ( self , limit_value ) :
def __init__ ( self , loaders ) :
def __init__ ( self , location = None , base_url = None , file_permissions_mode = None ,  directory_permissions_mode = None ) :
def __init__ ( self , loopvars , sequence , is_reversed , nodelist_loop , nodelist_empty = None ) :
def __init__ ( self , max_length = None , min_length = None , * args , ** kwargs ) :
def __init__ ( self , max_value = None , min_value = None , * args , ** kwargs ) :
def __init__ ( self , max_value = None , min_value = None , max_digits = None , decimal_places = None , * args , ** kwargs ) :
def __init__ ( self , media = None , ** kwargs ) :
def __init__ ( self , message , code = None , params = None ) :
def __init__ ( self , message = None , code = None , whitelist = None ) :
def __init__ ( self , META , input_data , upload_handlers , encoding = None ) :
def __init__ ( self , mode = 'w+b' , bufsize = - 1 , suffix = '' , prefix = '' ,  dir = None ) :
def __init__ ( self , msg , params = ( ) ) :
def __init__ ( self , name , content , content_type = 'text/plain' ) :
def __init__ ( self , name , content_type , size , charset , content_type_extra = None ) :
def __init__ ( self , name , nodelist , parent = None ) :
def __init__ ( self , name , old , new = None ) :
def __init__ ( self , name , old_mod , new_mod , old_attr = None , new_attr = None ) :
def __init__ ( self , name , params ) :
def __init__ ( self , name , regex , next = None ) :
def __init__ ( self , name , sysid , pubid ) :
def __init__ ( self , name , value , attrs , choice , index ) :
def __init__ ( self , name , value , attrs , choices ) :
def __init__ ( self , name , value , base , sysid , pubid , notation_name ) :
def __init__ ( self , name ) :
def __init__ ( self , nodelist , parent_name , template_dirs = None ) :
def __init__ ( self , nodelist ) :
def __init__ ( self , nodelist_true , nodelist_false , * varlist ) :
def __init__ ( self , obj , * args ) :
def __init__ ( self , obj , m2m_data = None ) :
def __init__ ( self , obj ) :
def __init__ ( self , object_list , number , paginator ) :
def __init__ ( self , object_list , per_page , orphans = 0 ,  allow_empty_first_page = True ) :
def __init__ ( self , offset ) :
def __init__ ( self , offset = None , name = None ) :
def __init__ ( self , options = None ) :
def __init__ ( self , out , style_func = None , ending = '\n' ) :
def __init__ ( self , params ) :
def __init__ ( self , parent_instance , * args , ** kwargs ) :
def __init__ ( self , parent_widget , name , value , attrs , choices ) :
def __init__ ( self , parser , * args , ** kwargs ) :
def __init__ ( self , path , match = None , recursive = False , allow_files = True ,  allow_folders = False , required = True , widget = None , label = None ,  initial = None , help_text = '' , * args , ** kwargs ) :
def __init__ ( self , permitted_methods , * args , ** kwargs ) :
def __init__ ( self , producer , length = None ) :
def __init__ ( self , protocol = 'both' , unpack_ipv4 = False , * args , ** kwargs ) :
def __init__ ( self , query_string = None , mutable = False , encoding = None ) :
def __init__ ( self , queryset , cache_choices = None , required = True ,  widget = None , label = None , initial = None ,  help_text = '' , * args , ** kwargs ) :
def __init__ ( self , queryset , empty_label = "---------" , cache_choices = None ,  required = True , widget = None , label = None , initial = None ,  help_text = '' , to_field_name = None , limit_choices_to = None ,  * args , ** kwargs ) :
def __init__ ( self , redirect_to , * args , ** kwargs ) :
def __init__ ( self , regex , callback , default_args = None , name = None ) :
def __init__ ( self , regex , max_length = None , min_length = None , error_message = None , * args , ** kwargs ) :
def __init__ ( self , regex , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) :
def __init__ ( self , regex ) :
def __init__ ( self , regex = None , message = None , code = None , inverse_match = None , flags = None ) :
def __init__ ( self , request , dict_ = None , processors = None , current_app = None ,  use_l10n = None , use_tz = None ) :
def __init__ ( self , request , template , context = None , content_type = None ,  status = None , current_app = None ) :
def __init__ ( self , request = None ) :
def __init__ ( self , required = True , widget = None , label = None , initial = None ,  help_text = '' , error_messages = None , show_hidden_initial = False ,  validators = [ ] , localize = False , label_suffix = None ) :
def __init__ ( self , s ) :
def __init__ ( self , schemes = None , ** kwargs ) :
def __init__ ( self , server , params , library , value_not_found_exception ) :
def __init__ ( self , server , params ) :
def __init__ ( self , server , params ) :
def __init__ ( self , setting , nodelist ) :
def __init__ ( self , source ) :
def __init__ ( self , states , first ) :
def __init__ ( self , stream , boundary ) :
def __init__ ( self , stream , limit , buf_size = 64 * 1024 * 1024 ) :
def __init__ ( self , stream_or_string , ** options ) :
def __init__ ( self , stream_or_string , ** options ) :
def __init__ ( self , streaming_content = ( ) , * args , ** kwargs ) :
def __init__ ( self , subject ) :
def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None ,  connection = None , attachments = None , headers = None , alternatives = None ,  cc = None ) :
def __init__ ( self , subject = '' , body = '' , from_email = None , to = None , bcc = None ,  connection = None , attachments = None , headers = None , cc = None ) :
def __init__ ( self , table , params ) :
def __init__ ( self , table ) :
def __init__ ( self , tagtype ) :
def __init__ ( self , takes_context , args , kwargs , target_var ) :
def __init__ ( self , takes_context , args , kwargs ) :
def __init__ ( self , target , expression , var_name ) :
def __init__ ( self , template , * args , ** kwargs ) :
def __init__ ( self , template , context = None , content_type = None , status = None ) :
def __init__ ( self , template_string , origin ) :
def __init__ ( self , template_string , origin = None , name = None ) :
def __init__ ( self , text , subtype , charset ) :
def __init__ ( self , text ) :
def __init__ ( self , timezone ) :
def __init__ ( self , title , link , description , language = None , author_email = None ,  author_name = None , author_link = None , subtitle = None , categories = None ,  feed_url = None , feed_copyright = None , feed_guid = None , ttl = None , ** kwargs ) :
def __init__ ( self , token , parser ) :
def __init__ ( self , token_type , contents ) :
def __init__ ( self , tokens ) :
def __init__ ( self , tokens ) :
def __init__ ( self , tup , hash = hash ) :
def __init__ ( self , url , length , mime_type ) :
def __init__ ( self , urlconf_name , default_kwargs = None , app_name = None , namespace = None ) :
def __init__ ( self , val_expr , max_expr , max_width , asvar = None ) :
def __init__ ( self , value , text ) :
def __init__ ( self , value ) :
def __init__ ( self , var , name , nodelist , extra_context = None ) :
def __init__ ( self , var ) :
def __init__ ( self , var1 , var2 , nodelist_true , nodelist_false , negate ) :
def __init__ ( self , variables ) :
def __init__ ( self , view_name , args , kwargs , asvar ) :
def __init__ ( self , widgets , attrs = None ) :
def __init__ ( self ) :
def __init__ ( self ) :
def __init__ ( self ) :
def __init__ ( self ) :
def __init__ ( self ) :
def __init__ ( self ) :
def __init__ ( self ) :
def __iter__ ( self ) :
def __iter__ ( self ) :
def __iter__ ( self ) :
def __iter__ ( self ) :
def __iter__ ( self ) :
def __len__ ( self ) :
def __len__ ( self ) :
def __lt__ ( self , other ) :
def __lt__ ( self , other ) :
def __mod__ ( self , rhs ) :
def __ne__ ( self , other ) :
def __ne__ ( self , other ) :
def __ne__ ( self , other ) :
def __ne__ ( self , other ) :
def __ne__ ( self , other ) :
def __new__ ( cls , * args , ** kwargs ) :
def __new__ ( cls , fget = None , fset = None , fdel = None , doc = None ) :
def __new__ ( cls , name , bases , attrs ) :
def __new__ ( cls , name , this_bases , d ) :
def __new__ ( mcs , name , bases , attrs ) :
def __new__ ( mcs , name , bases , attrs ) :
def __newobj__ ( cls , * args ) :
def __next__ ( self ) :
def __nonzero__ ( self ) :
def __nonzero__ ( self ) :
def __prepare_class__ ( cls ) :
def __promise__ ( cls , klass , funcname , method ) :
def __reduce__ ( self ) :
def __reduce_ex__ ( self , proto ) :
def __repr__ ( self ) :
def __repr__ ( self ) :
def __repr__ ( self ) :
def __repr__ ( self ) :
def __repr__ ( self ) :
def __repr__ ( self ) :
def __repr__ ( self ) :
def __reversed__ ( self ) :
def __setattr__ ( self , name , value ) :
def __setattr__ ( self , name , value ) :
def __setitem__ ( self , header , value ) :
def __setitem__ ( self , key , value ) :
def __setitem__ ( self , key , value ) :
def __setitem__ ( self , name , val ) :
def __setstate__ ( self , obj_dict ) :
def __setstate__ ( self , state ) :
def __str__ ( self ) :
def __str__ ( self ) :
def __str__ ( self ) :
def __str__ ( self ) :
def __str__ ( self ) :
def __str__ ( self ) :
def __str__ ( self ) :
def __str__ ( self ) :
def __text_cast ( self ) :
def __wrapper__ ( * args , ** kw ) :
def __wrapper__ ( self , * args , ** kw ) :
def _add_doc ( func , doc ) :
def _add_fallback ( self ) :
def _add_installed_apps_translations ( self ) :
def _add_local_translations ( self ) :
def _archive_cls ( file ) :
def _assert_mutable ( self ) :
def _base_set ( self , mode , key , value , timeout = DEFAULT_TIMEOUT ) :
def _BaseCookie__set ( self , key , real_value , coded_value ) :
def _bin_to_long ( x ) :
def _cache ( self ) :
def _cache ( self ) :
def _check_boolean_field_default_value ( app_configs = None , ** kwargs ) :
def _check_middleware_classes ( app_configs = None , ** kwargs ) :
def _check_test_runner ( app_configs = None , ** kwargs ) :
def _checkLevel ( level ) :
def _clean_fields ( self ) :
def _clean_form ( self ) :
def _close_files ( self ) :
def _coerce ( self , value ) :
def _coerce ( self , value ) :
def _construct_form ( self , i , ** kwargs ) :
def _convert_to_charset ( self , value , charset , mime_encode = False ) :
def _create_alternatives ( self , msg ) :
def _create_attachment ( self , filename , content , mimetype = None ) :
def _create_attachments ( self , msg ) :
def _create_cache ( backend , ** kwargs ) :
def _create_message ( self , msg ) :
def _create_mime_attachment ( self , content , mimetype ) :
def _createdir ( self ) :
def _cull ( self , db , cursor , now ) :
def _cull ( self ) :
def _curried ( * moreargs , ** morekwargs ) :
def _dec ( * args , ** kwargs ) :
def _dec ( func ) :
def _decorator ( view_func ) :
def _delete ( self , fname ) :
def _delete ( self , key ) :
def _existing_object ( self , pk ) :
def _explode_shorthand_ip_string ( ip_str ) :
def _fd ( f ) :
def _find_boundary ( self , data , eof = False ) :
def _findall ( text , substr ) :
def _format_value ( self , value ) :
def _generate_cache_header_key ( key_prefix , request ) :
def _generate_cache_key ( request , method , headerlist , key_prefix ) :
def _generator ( ) :
def _get_choices ( self ) :
def _get_closed ( self ) :
def _get_context_stack_frame ( self , context ) :
def _get_count ( self ) :
def _get_filename ( self ) :
def _get_files ( self ) :
def _get_foreign_key ( parent_model , model , fk_name = None , can_fail = False ) :
def _get_height ( self ) :
def _get_image_dimensions ( self ) :
def _get_media ( self ) :
def _get_model ( model_identifier ) :
def _get_model_from_node ( self , node , attr ) :
def _get_name ( self ) :
def _get_num_pages ( self ) :
def _get_page ( self , * args , ** kwargs ) :
def _get_page_range ( self ) :
def _get_post ( self ) :
def _get_queryset ( self ) :
def _get_regex ( self ) :
def _get_request ( self ) :
def _get_scheme ( self ) :
def _get_scheme ( self ) :
def _get_size ( self ) :
def _get_size_from_underlying_file ( self ) :
def _get_timezone_name ( timezone ) :
def _get_to_python ( self , field ) :
def _get_val ( ) :
def _get_validation_exclusions ( self ) :
def _get_width ( self ) :
def _handle_fk_field_node ( self , node , field ) :
def _handle_m2m_field_node ( self , node , field ) :
def _handle_object ( self , node ) :
def _has_changed ( self , initial , data ) :
def _has_changed ( self , initial , data ) :
def _has_changed ( self , initial , data ) :
def _has_changed ( self , initial , data ) :
def _has_changed ( self , initial , data ) :
def _has_expired ( self , key ) :
def _helper ( list_ , tabs = 1 ) :
def _html_output ( self , normal_row , error_row , row_ender , help_text_html , errors_on_separate_row ) :
def _i18n_cache_key_suffix ( request , cache_key ) :
def _import_module ( name ) :
def _init_translation_catalog ( self ) :
def _initialize_handlers ( self ) :
def _ipython ( self ) :
def _ipython_pre_011 ( self ) :
def _ipython_pre_100 ( self ) :
def _is_expired ( self , f ) :
def _is_shorthand_ip ( ip_str ) :
def _isdst ( self , dt ) :
def _isdst ( self , dt ) :
def _iteritems ( self ) :
def _iterkeys ( self ) :
def _iterlists ( self ) :
def _itervalues ( self ) :
def _key_to_file ( self , key , version = None ) :
def _lazy_proxy_unpickle ( func , args , kwargs , * resultclasses ) :
def _list_cache_files ( self ) :
def _load_post_and_files ( self ) :
def _load_serializers ( ) :
def _long_to_bin ( x , hex_format_string ) :
def _make_decorator ( * m_args , ** m_kwargs ) :
def _make_key ( args , kwds , typed ,  kwd_mark = ( object ( ) , ) ,  fasttypes = { int , str , frozenset , type ( None ) } ,  sorted = sorted , tuple = tuple , type = type , len = len ) :
def _make_parser ( self ) :
def _mark_post_parse_error ( self ) :
def _media ( self ) :
def _new_gnu_trans ( self , localedir , use_null_fallback = True ) :
def _new_instance ( cls , children = None , connector = None , negated = False ) :
def _open ( self , name , mode = 'rb' ) :
def _parse_date_fmt ( ) :
def _parse_header ( line ) :
def _parse_header_params ( s ) :
def _populate ( self ) :
def _post_clean ( self ) :
def _prepare_data ( self , data ) :
def _proxy_method ( self , * args , ** kwargs ) :
def _raw_value ( self , fieldname ) :
def _read_limited ( self , size = None ) :
def _render ( self , context ) :
def _replace_entity ( match ) :
def _reset_dicts ( self , value = None ) :
def _resolve ( self ) :
def _resolve_lookup ( self , context ) :
def _resolve_name ( name , package , level ) :
def _reverse_with_prefix ( self , lookup_view , _prefix , * args , ** kwargs ) :
def _samefile ( src , dst ) :
def _sanitize_ipv4_mapping ( ip_str ) :
def _save ( self , name , content ) :
def _send ( self , email_message ) :
def _set ( self , key , value , timeout = DEFAULT_TIMEOUT ) :
def _set_choices ( self , value ) :
def _set_name ( self , name ) :
def _set_post ( self , post ) :
def _set_queryset ( self , queryset ) :
def _set_regex ( self , regex ) :
def _set_response_etag ( response ) :
def _set_size ( self , size ) :
def _setup ( self ) :
def _setup ( self ) :
def _should_delete_form ( self , form ) :
def _split_statements ( content ) :
def _start_relational_field ( self , field ) :
def _string_concat ( * strings ) :
def _strip_once ( value ) :
def _text_chars ( self , length , truncate , text , truncate_len ) :
def _text_words ( self , length , truncate ) :
def _to_tuple ( s ) :
def _truncate_html ( self , length , truncate , text , truncate_len , words ) :
def _unpack_ipv4 ( ip_str ) :
def _update_errors ( self , errors ) :
def _update_unget_history ( self , num_bytes ) :
def _wrapped_view ( request , * args , ** kwargs ) :
def _wrapper ( self , * args , ** kwargs ) :
def a ( self ) :
def absolute_path ( self , path , prefix = None ) :
def abspathu ( path ) :
def accessed_time ( self , name ) :
def activate ( language ) :
def activate ( language ) :
def activate ( timezone ) :
def add ( self , data , conn_type , squash = True ) :
def add ( self , item ) :
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :
def add ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :
def add ( value , arg ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_arguments ( self , parser ) :
def add_blocks ( self , blocks ) :
def add_css ( self , data ) :
def add_error ( self , field , error ) :
def add_fields ( self , form , index ) :
def add_fields ( self , form , index ) :
def add_fields ( self , form , index ) :
def add_filters ( self , filterer , filters ) :
def add_handlers ( self , logger , handlers ) :
def add_initial_prefix ( self , field_name ) :
def add_item ( self , title , link , description , author_email = None ,  author_name = None , author_link = None , pubdate = None , comments = None ,  unique_id = None , unique_id_is_permalink = None , enclosure = None ,  categories = ( ) , item_copyright = None , ttl = None , updateddate = None , ** kwargs ) :
def add_item_elements ( self , handler , item ) :
def add_item_elements ( self , handler , item ) :
def add_js ( self , data ) :
def add_library ( self , lib ) :
def add_metaclass ( metaclass ) :
def add_move ( move ) :
def add_never_cache_headers ( response ) :
def add_post_render_callback ( self , callback ) :
def add_prefix ( self , field_name ) :
def add_prefix ( self , index ) :
def add_prefix ( self , prefix ) :
def add_root_elements ( self , handler ) :
def add_root_elements ( self , handler ) :
def add_to_builtins ( module ) :
def addQuickElement ( self , name , contents = None , attrs = None ) :
def address_string ( self ) :
def addslashes ( value ) :
def advance_iterator ( it ) :
def all ( self ) :
def all_locale_paths ( ) :
def all_valid ( formsets ) :
def allow_lazy ( func , * resultclasses ) :
def app_dict ( self ) :
def appendlist ( self , key , value ) :
def apply_response_fixes ( self , request , response ) :
def args_check ( name , func , provided ) :
def as_bytes ( self , unixfrom = False ) :
def as_data ( self ) :
def as_data ( self ) :
def as_hidden ( self , attrs = None , ** kwargs ) :
def as_json ( self , escape_html = False ) :
def as_json ( self , escape_html = False ) :
def as_p ( self ) :
def as_p ( self ) :
def as_string ( self , unixfrom = False ) :
def as_table ( self ) :
def as_text ( self , attrs = None , ** kwargs ) :
def as_text ( self ) :
def as_text ( self ) :
def as_textarea ( self , attrs = None , ** kwargs ) :
def as_tuple ( self , value ) :
def as_ul ( self ) :
def as_ul ( self ) :
def as_ul ( self ) :
def as_ul ( self ) :
def as_widget ( self , widget = None , attrs = None , only_initial = False ) :
def assertCountEqual ( self , * args , ** kwargs ) :
def assertRaisesRegex ( self , * args , ** kwargs ) :
def assertRegex ( self , * args , ** kwargs ) :
def assignment_tag ( self , func = None , takes_context = None , name = None ) :
def attach ( self , filename = None , content = None , mimetype = None ) :
def attach_alternative ( self , content , mimetype ) :
def attach_file ( self , path , mimetype = None ) :
def auto_id ( self ) :
def autocomplete ( self ) :
def autodiscover_modules ( * args , ** kwargs ) :
def autoescape ( parser , token ) :
def available_attrs ( fn ) :
def avoid_wrapping ( value ) :
def b ( s ) :
def B ( self ) :
def b ( self ) :
def b64_decode ( s ) :
def b64_encode ( s ) :
def back ( self ) :
def base36_to_int ( s ) :
def base64_hmac ( salt , value , key ) :
def become_daemon ( our_home_dir = '.' , out_log = '/dev/null' ,  err_log = '/dev/null' , umask = 0o022 ) :
def become_daemon ( our_home_dir = '.' , out_log = None , err_log = None , umask = 0o022 ) :
def blankout ( src , char ) :
def body ( self ) :
def boolean_check ( v ) :
def bound_data ( self , data , initial ) :
def bound_func ( * args2 , ** kwargs2 ) :
def bpython ( self ) :
def build_absolute_uri ( self , location = None ) :
def build_attrs ( self , extra_attrs = None , ** kwargs ) :
def build_instance ( Model , data , db ) :
def build_potfiles ( self ) :
def build_request_repr ( request , path_override = None , GET_override = None ,  POST_override = None , COOKIES_override = None ,  META_override = None ) :
def byte2int ( bs ) :
def bytes_to_text ( s , encoding ) :
def c ( self ) :
def cache_clear ( ) :
def cache_info ( ) :
def cache_key ( self , template_name , template_dirs ) :
def calculate_app_template_dirs ( ) :
def call_command ( name , * args , ** options ) :
def callable ( obj ) :
def callback ( self ) :
def camel_case_to_spaces ( value ) :
def capfirst ( value ) :
def catalog ( ) :
def center ( value , arg ) :
def cfg_convert ( self , value ) :
def changed_data ( self ) :
def chars ( self , num , truncate = None , html = False ) :
def check ( self , app_configs = None , tags = None , display_num_errors = False ) :
def check_1_6_compatibility ( ** kwargs ) :
def check_1_7_compatibility ( ** kwargs ) :
def check_all_models ( app_configs = None , ** kwargs ) :
def check_errors ( fn ) :
def check_for_language ( lang_code ) :
def check_for_migrations ( app_config , connection ) :
def check_migrations ( self ) :
def check_model_signals ( app_configs = None , ** kwargs ) :
def check_programs ( * programs ) :
def choice ( self , obj ) :
def chunks ( self , chunk_size = None ) :
def chunks ( self , chunk_size = None ) :
def clean ( self , data , initial = None ) :
def clean ( self , value ) :
def clean ( self , value ) :
def clean ( self , value ) :
def clean ( self , value ) :
def clean ( self ) :
def clean_ipv6_address ( ip_str , unpack_ipv4 = False ,  error_message = _ ( "This is not a valid IPv6 address." ) ) :
def cleaned_data ( self ) :
def cleanup_url ( url ) :
def clear ( self ) :
def clear ( self ) :
def clear ( self ) :
def clear ( self ) :
def clear ( self ) :
def clear_cdata_mode ( self ) :
def clear_checkbox_id ( self , name ) :
def clear_checkbox_name ( self , name ) :
def clear_script_prefix ( ) :
def clear_url_caches ( ) :
def close ( self , ** kwargs ) :
def close ( self , ** kwargs ) :
def close ( self ) :
def close ( self ) :
def close ( self ) :
def close ( self ) :
def close_caches ( ** kwargs ) :
def closed ( self ) :
def code_changed ( ) :
def color_style ( ) :
def colorize ( text = '' , opts = ( ) , ** kwargs ) :
def combine ( cls , date , time ) :
def comment ( parser , token ) :
def common_logger_config ( self , logger , config , incremental = False ) :
def compare_ordering_key ( k ) :
def compile_filter ( self , token ) :
def compile_filter_error ( self , token , e ) :
def compile_filter_error ( self , token , e ) :
def compile_func ( parser , token ) :
def compile_function_error ( self , token , e ) :
def compile_messages ( self , locations ) :
def compile_string ( template_string , origin ) :
def complain ( self , * wargs , ** kwargs ) :
def compress ( self , data_list ) :
def compress_sequence ( sequence ) :
def compress_string ( s ) :
def conditional_content_removal ( request , response ) :
def conditional_escape ( text ) :
def configure ( self ) :
def configure_custom ( self , config ) :
def configure_filter ( self , config ) :
def configure_formatter ( self , config ) :
def configure_handler ( self , config ) :
def configure_logger ( self , name , config , incremental = False ) :
def configure_logging ( logging_config , logging_settings ) :
def configure_root ( self , config , incremental = False ) :
def connection ( self ) :
def constant_time_compare ( val1 , val2 ) :
def constant_time_compare ( val1 , val2 ) :
def construct_instance ( form , instance , fields = None , exclude = None ) :
def contains ( source , inst ) :
def content ( self , value ) :
def content ( self , value ) :
def content ( self ) :
def convert ( self , number , from_digits , to_digits , sign ) :
def convert ( self , value ) :
def convert_old_style_list ( list_ ) :
def cookie_date ( epoch_seconds = None ) :
def COOKIES ( self ) :
def copy ( self ) :
def copy_plural_forms ( self , msgs , locale ) :
def copystat ( src , dst ) :
def create_bound_method ( func , obj ) :
def create_nodelist ( self ) :
def create_parser ( self , prog_name , subcommand ) :
def create_select ( self , name , field , value , val , choices , none_value ) :
def create_table ( self , database , tablename ) :
def create_token ( self , token_string , in_tag ) :
def create_token ( self , token_string , source , in_tag ) :
def create_var ( self , value ) :
def create_variable_node ( self , contents ) :
def create_variable_node ( self , filter_expression ) :
def created_time ( self , name ) :
def created_time ( self , name ) :
def csrf ( request ) :
def csrf_token ( parser , token ) :
def css_classes ( self , extra_classes = None ) :
def curry ( _curried_func , * args , ** kwargs ) :
def custom_sql_for_model ( model , style , connection ) :
def cut ( value , arg ) :
def cycle ( parser , token ) :
def d ( self ) :
def data ( self ) :
def date ( self ) :
def date ( value , arg = None ) :
def date_format ( value , format = None , use_l10n = None ) :
def deactivate ( ) :
def deactivate_all ( ) :
def debug ( parser , token ) :
def debug ( request ) :
def dec ( func ) :
def dec ( func ) :
def dec ( func ) :
def decode ( self , s ) :
def decompress ( self , value ) :
def deconstruct ( obj ) :
def deconstructible ( * args , ** kwargs ) :
def decorating_function ( user_function ) :
def decorator ( klass ) :
def decorator_from_middleware ( middleware_class ) :
def decorator_from_middleware_with_args ( middleware_class ) :
def decr ( self , key , delta = 1 , version = None ) :
def decr ( self , key , delta = 1 , version = None ) :
def decr_version ( self , key , delta = 1 , version = None ) :
def default ( self , o ) :
def default ( value , arg ) :
def default_if_none ( value , arg ) :
def default_key_func ( key , key_prefix , version ) :
def delete ( self , key , version = None ) :
def delete ( self , key , version = None ) :
def delete ( self , key , version = None ) :
def delete ( self , key , version = None ) :
def delete ( self , key , version = None ) :
def delete ( self , name ) :
def delete_cookie ( self , key , path = '/' , domain = None ) :
def delete_first_token ( self ) :
def delete_many ( self , keys , version = None ) :
def delete_many ( self , keys , version = None ) :
def delete_many ( self , keys , version = None ) :
def deleted_forms ( self ) :
def deserialize ( format , stream_or_string , ** options ) :
def Deserializer ( object_list , ** options ) :
def Deserializer ( stream_or_string , ** options ) :
def Deserializer ( stream_or_string , ** options ) :
def dict ( self ) :
def dictConfig ( config ) :
def dictitem ( s ) :
def dictsort ( value , arg ) :
def dictsortreversed ( value , arg ) :
def dictvalue ( t ) :
def discard ( self , item ) :
def display ( self ) :
def display ( self ) :
def divisibleby ( value , arg ) :
def do_block ( parser , token ) :
def do_extends ( parser , token ) :
def do_filter ( parser , token ) :
def do_for ( parser , token ) :
def do_if ( parser , token ) :
def do_ifequal ( parser , token , negate ) :
def do_include ( parser , token ) :
def do_ntranslate ( singular , plural , number , translation_function ) :
def do_translate ( message , translation_function ) :
def do_with ( parser , token ) :
def download ( self , url ) :
def dst ( self , dt ) :
def dst ( self , dt ) :
def dst ( self , dt ) :
def dummy ( * args , ** kwargs ) :
def dumps ( obj , key = None , salt = 'django.core.signing' , serializer = JSONSerializer , compress = False ) :
def dumps ( self , obj ) :
def e ( self ) :
def emit ( self , record ) :
def emit_post_migrate ( verbosity , interactive , database ) :
def emit_post_migrate_signal ( created_models , verbosity , interactive , db ) :
def emit_pre_migrate_signal ( create_models , verbosity , interactive , db ) :
def empty_block_tag ( self , token ) :
def empty_form ( self ) :
def empty_variable ( self , token ) :
def encode ( self , i ) :
def encoding ( self , val ) :
def encoding ( self , value ) :
def encoding ( self ) :
def end_index ( self ) :
def end_object ( self , obj ) :
def end_object ( self , obj ) :
def end_serialization ( self ) :
def endChannelElement ( self , handler ) :
def ensure_echo_on ( ) :
def enter_command ( self , command , token ) :
def entity_decl ( self , name , is_parameter_entity , value , base ,  sysid , pubid , notation_name ) :
def error ( self , message ) :
def error ( self , token , msg ) :
def error ( self , token , msg ) :
def errors ( self ) :
def escape ( text ) :
def escape_filter ( value ) :
def escape_quotes ( m ) :
def escapejs ( value ) :
def escapejs_filter ( value ) :
def eval ( self , context ) :
def eval ( self , context ) :
def eval ( self , context ) :
def exec_ ( _code_ , _globs_ = None , _locs_ = None ) :
def execute ( self , * args , ** options ) :
def execute ( self , * args , ** options ) :
def execute ( self ) :
def execute_from_command_line ( argv = None ) :
def exhaust ( stream_or_iterable ) :
def exists ( self , name ) :
def exit_command ( self ) :
def expression ( self , rbp = 0 ) :
def ext_convert ( self , value ) :
def extend_nodelist ( self , nodelist , node , token ) :
def external_entity_ref_handler ( self , context , base , sysid , pubid ) :
def extra_forms ( self ) :
def extract ( path , to_path = '' ) :
def extract ( self , filename ) :
def extract ( self , to_path ) :
def extract ( self , to_path = '' ) :
def extract ( self ) :
def F ( i ) :
def f ( self ) :
def fastcgi_help ( message = None ) :
def fdel ( instance , name = fdel . __name__ ) :
def fetch_command ( self , subcommand ) :
def fget ( instance , instance_type = None , name = fget . __name__ ) :
def fields_for_model ( model , fields = None , exclude = None , widgets = None ,  formfield_callback = None , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ) :
def file_complete ( self , file_size ) :
def file_complete ( self , file_size ) :
def file_complete ( self , file_size ) :
def file_move_safe ( old_file_name , new_file_name , chunk_size = 1024 * 64 , allow_overwrite = False ) :
def filepath_to_uri ( path ) :
def filesizeformat ( bytes ) :
def filter ( self , name = None , filter_func = None , ** flags ) :
def filter ( self , record ) :
def filter_function ( self , func , ** flags ) :
def find_command ( cmd , path = None , pathext = None ) :
def find_commands ( management_dir ) :
def find_files ( self , root ) :
def find_filter ( self , filter_name ) :
def find_fixtures ( self , fixture_label ) :
def find_template ( name , dirs = None ) :
def find_template ( self , name , dirs = None ) :
def firstof ( parser , token ) :
def fix ( match ) :
def fix_location_header ( request , response ) :
def fixture_dirs ( self ) :
def flatatt ( attrs ) :
def flatten ( self ) :
def flatten_result ( source ) :
def floatformat ( text , arg = - 1 ) :
def flush ( self ) :
def flush ( self ) :
def foo(a, b):
def forbid_multi_line_headers ( name , val , encoding ) :
def force_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
def force_escape ( value ) :
def force_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
def format ( number , decimal_sep , decimal_pos = None , grouping = 0 , thousand_sep = '' ,  force_grouping = False ) :
def format ( self , formatstr ) :
def format ( value , format_string ) :
def format_html ( format_string , * args , ** kwargs ) :
def format_html_join ( sep , format_string , args_generator ) :
def format_output ( self , rendered_widgets ) :
def format_subject ( self , subject ) :
def forms ( self ) :
def formset_factory ( form , formset = BaseFormSet , extra = 1 , can_order = False ,  can_delete = False , max_num = None , validate_max = False ,  min_num = None , validate_min = False ) :
def from_current_timezone ( value ) :
def from_dict ( cls , file_dict ) :
def fset ( instance , value , name = fset . __name__ ) :
def full_clean ( self ) :
def g ( self ) :
def gen_filenames ( only_new = False ) :
def generic_tag_compiler ( parser , token , params , varargs , varkw , defaults ,  name , takes_context , node_class ) :
def get ( self , header , alternate = None ) :
def get ( self , key , default = None , version = None ) :
def get ( self , key , default = None , version = None ) :
def get ( self , key , default = None , version = None ) :
def get ( self , key , default = None , version = None ) :
def get ( self , key , default = None ) :
def get ( self , key , otherwise = None ) :
def get ( self , key , otherwise = None ) :
def GET ( self ) :
def get_available_name ( self , name ) :
def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :
def get_backend_timeout ( self , timeout = DEFAULT_TIMEOUT ) :
def get_block ( self , name ) :
def get_bytes_from_wsgi ( environ , key , default ) :
def get_cache ( backend , ** kwargs ) :
def get_cache_key ( request , key_prefix = None , method = 'GET' , cache = None ) :
def get_callable ( lookup_view , can_fail = False ) :
def get_commands ( ) :
def get_complete_version ( version = None ) :
def get_connection ( backend = None , fail_silently = False , ** kwds ) :
def get_connection ( self , fail_silently = False ) :
def get_cookie_signer ( salt = 'django.core.signing.get_cookie_signer' ) :
def get_current_timezone ( ) :
def get_current_timezone_name ( ) :
def get_data ( self ) :
def get_date_error_message ( self , date_check ) :
def get_declared_fields ( bases , attrs , with_base_fields = True ) :
def get_default_prefix ( cls ) :
def get_default_timezone ( ) :
def get_default_timezone_name ( ) :
def get_deserializer ( format ) :
def get_digit ( value , arg ) :
def get_dump_object ( self , obj ) :
def get_exception_response ( self , request , resolver , status_code ) :
def get_field_type ( self , connection , table_name , row ) :
def get_fixed_timezone ( offset ) :
def get_form_error ( self ) :
def get_format ( format_type , lang = None , use_l10n = None ) :
def get_format_modules ( lang = None , reverse = False ) :
def get_fqdn ( self ) :
def get_full_path ( self ) :
def get_git_changeset ( ) :
def get_handler ( self , * args , ** options ) :
def get_host ( self ) :
def get_image_dimensions ( file_or_path , close = False ) :
def get_internal_wsgi_application ( ) :
def get_json_data ( self , escape_html = False ) :
def get_key_func ( key_func ) :
def get_language ( ) :
def get_language_bidi ( ) :
def get_language_from_path ( path , strict = False ) :
def get_language_from_path ( path ) :
def get_language_from_path ( request ) :
def get_language_from_request ( request , check_path = False ) :
def get_language_info ( lang_code ) :
def get_library ( library_name ) :
def get_limit_choices_to ( self ) :
def get_major_version ( version = None ) :
def get_many ( self , keys , version = None ) :
def get_many ( self , keys , version = None ) :
def get_many ( self , keys , version = None ) :
def get_max_age ( response ) :
def get_meta ( self , table_name ) :
def get_mod_func ( callback ) :
def get_nodes_by_type ( self , nodetype ) :
def get_ns_resolver ( ns_pattern , resolver ) :
def get_objects ( ) :
def get_parent ( self , context ) :
def get_path_info ( environ ) :
def get_public_serializer_formats ( ) :
def get_quantifier ( ch , input_iter ) :
def get_queryset ( self ) :
def get_random_string ( length = 12 ,  allowed_chars = 'abcdefghijklmnopqrstuvwxyz'  'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' ) :
def get_renderer ( self , name , value , attrs = None , choices = ( ) ) :
def get_resolved_arguments ( self , context ) :
def get_resolver ( urlconf ) :
def get_response ( self , request ) :
def get_script_name ( environ ) :
def get_script_prefix ( ) :
def get_serializer ( format ) :
def get_serializer_formats ( ) :
def get_signed_cookie ( self , key , default = RAISE_ERROR , salt = '' , max_age = None ) :
def get_standard_processors ( ) :
def get_storage_class ( import_path = None ) :
def get_str_from_wsgi ( environ , key , default ) :
def get_supported_language_variant ( lang_code , strict = False ) :
def get_system_encoding ( ) :
def get_tag_uri ( url , date ) :
def get_template ( template_name , dirs = None ) :
def get_template_from_string ( source , origin = None , name = None ) :
def get_template_sources ( self , template_name , template_dirs = None ) :
def get_template_sources ( self , template_name , template_dirs = None ) :
def get_templatetags_modules ( ) :
def get_text_list ( list_ , last_word = ugettext_lazy ( 'or' ) ) :
def get_unbound_function ( unbound ) :
def get_unique_error_message ( self , unique_check ) :
def get_urlconf ( default = None ) :
def get_valid_filename ( s ) :
def get_valid_name ( self , name ) :
def get_version ( self ) :
def get_version ( version = None ) :
def get_wsgi_application ( ) :
def getInnerText ( node ) :
def getlist ( self , key , default = None ) :
def getlist ( self , key ) :
def gettext ( message ) :
def gettext ( message ) :
def gettext_noop ( message ) :
def gettext_noop ( message ) :
def getvalue ( self ) :
def getvalue ( self ) :
def h ( self ) :
def handle ( self , * app_labels , ** options ) :
def handle ( self , * app_labels , ** options ) :
def handle ( self , * app_labels , ** options ) :
def handle ( self , * app_labels , ** options ) :
def handle ( self , * args , ** options ) :
def handle ( self , * args , ** options ) :
def handle ( self , * args , ** options ) :
def handle ( self , * args , ** options ) :
def handle ( self , * args , ** options ) :
def handle ( self , * fixture_labels , ** options ) :
def handle ( self , * fixture_labels , ** options ) :
def handle ( self , * labels , ** options ) :
def handle ( self , * tablenames , ** options ) :
def handle ( self , * test_labels , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , ** options ) :
def handle ( self , app_or_project , name , target = None , ** options ) :
def handle_app_config ( self , app_config , ** options ) :
def handle_app_config ( self , app_config , ** options ) :
def handle_app_config ( self , app_config , ** options ) :
def handle_app_config ( self , app_config , ** options ) :
def handle_app_config ( self , app_config , ** options ) :
def handle_app_config ( self , app_config , ** options ) :
def handle_charref ( self , name ) :
def handle_data ( self , d ) :
def handle_default_options ( options ) :
def handle_entityref ( self , name ) :
def handle_extensions ( extensions = ( 'html' , ) , ignored = ( 'py' , ) ) :
def handle_field ( self , obj , field ) :
def handle_field ( self , obj , field ) :
def handle_field ( self , obj , field ) :
def handle_file_complete ( self , old_field_name , counters ) :
def handle_fk_field ( self , obj , field ) :
def handle_fk_field ( self , obj , field ) :
def handle_fk_field ( self , obj , field ) :
def handle_inspection ( self , options ) :
def handle_label ( self , label , ** options ) :
def handle_m2m ( value ) :
def handle_m2m_field ( self , obj , field ) :
def handle_m2m_field ( self , obj , field ) :
def handle_m2m_field ( self , obj , field ) :
def handle_merge ( self , loader , conflicts ) :
def handle_noargs ( self , ** options ) :
def handle_raw_input ( self , input_data , META , content_length , boundary , encoding = None ) :
def handle_template ( self , template , subdir ) :
def handle_uncaught_exception ( self , request , resolver , exc_info ) :
def has_bom ( fn ) :
def has_changed ( self ) :
def has_error ( self , field , code = None ) :
def has_header ( self , header ) :
def has_key ( self , key , version = None ) :
def has_key ( self , key , version = None ) :
def has_key ( self , key , version = None ) :
def has_key ( self , key , version = None ) :
def has_key ( self , key ) :
def has_leading_dir ( self , paths ) :
def has_next ( self ) :
def has_other_pages ( self ) :
def has_previous ( self ) :
def has_vary_header ( response , header_query ) :
def hidden_fields ( self ) :
def http_date ( epoch_seconds = None ) :
def humanize ( dirname ) :
def i ( self ) :
def i18n ( request ) :
def id_for_label ( self , id_ ) :
def id_for_label ( self , id_ ) :
def id_for_label ( self , id_ ) :
def id_for_label ( self , id_ ) :
def id_for_label ( self ) :
def IE_sanitize ( self , filename ) :
def ifchanged ( parser , token ) :
def ifequal ( parser , token ) :
def ifnotequal ( parser , token ) :
def import_by_path ( dotted_path , error_prefix = '' ) :
def import_library ( taglib_module ) :
def import_module ( name , package = None ) :
def import_string ( dotted_path ) :
def include_is_allowed ( filepath ) :
def inclusion_tag ( self , file_name , context_class = Context , takes_context = False , name = None ) :
def incr ( self , key , delta = 1 , version = None ) :
def incr ( self , key , delta = 1 , version = None ) :
def incr ( self , key , delta = 1 , version = None ) :
def incr_version ( self , key , delta = 1 , version = None ) :
def indent ( self , level ) :
def indexbytes ( buf , i ) :
def infix ( bp , func ) :
def initial_form_count ( self ) :
def initial_form_count ( self ) :
def initial_forms ( self ) :
def inlineformset_factory ( parent_model , model , form = ModelForm ,  formset = BaseInlineFormSet , fk_name = None ,  fields = None , exclude = None , extra = 3 , can_order = False ,  can_delete = True , max_num = None , formfield_callback = None ,  widgets = None , validate_max = False , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ,  min_num = None , validate_min = False ) :
def inner ( check ) :
def inner ( self , * args ) :
def inner_run ( self , * args , ** options ) :
def inotify_code_changed ( ) :
def int_to_base36 ( i ) :
def int2byte ( i ) :
def invalid_block_tag ( self , token , command , parse_until = None ) :
def ip_address_validators ( protocol , unpack_ipv4 ) :
def ipython ( self ) :
def iri_to_uri ( iri ) :
def iriencode ( value ) :
def is_ajax ( self ) :
def is_aware ( value ) :
def is_checked ( self ) :
def is_checked ( self ) :
def is_hidden ( self ) :
def is_ignored ( path , ignore_patterns ) :
def is_iterable ( x ) :
def is_library_missing ( name ) :
def is_multipart ( self ) :
def is_naive ( value ) :
def is_protected_type ( obj ) :
def is_rendered ( self ) :
def is_safe_url ( url , host = None ) :
def is_secure ( self ) :
def is_serious ( self ) :
def is_silenced ( self ) :
def is_url ( self , template ) :
def is_valid ( self ) :
def is_valid_ipv6_address ( ip_str ) :
def is_valid_path ( path , urlconf = None ) :
def is_writable ( path ) :
def item_attributes ( self , item ) :
def items ( self ) :
def iter_format_modules ( lang , format_module_path = None ) :
def iterbytes ( buf ) :
def iteritems ( d , ** kw ) :
def iterkeys ( d , ** kw ) :
def iterlists ( d , ** kw ) :
def itervalues ( d , ** kw ) :
def j ( self ) :
def javascript_quote ( s , quote_double_quotes = False ) :
def join ( value , arg , autoescape = None ) :
def join_tokens ( tokens , trim = False ) :
def jython_reloader ( main_func , args , kwargs ) :
def keys ( self ) :
def keys ( self ) :
def l ( self ) :
def label_from_instance ( self , obj ) :
def label_tag ( self , contents = None , attrs = None , label_suffix = None ) :
def language ( self ) :
def last ( value ) :
def latest_post_date ( self ) :
def lazy ( func , * resultclasses ) :
def lazy_number ( func , resultclass , number = None , ** kwargs ) :
def learn_cache_key ( request , response , cache_timeout = None , key_prefix = None , cache = None ) :
def led ( self , left , parser ) :
def led ( self , left , parser ) :
def length ( value ) :
def length_is ( value , arg ) :
def lex ( self , text ) :
def linebreaks ( value , autoescape = False ) :
def linebreaks_filter ( value , autoescape = None ) :
def linebreaksbr ( value , autoescape = None ) :
def linenumbers ( value , autoescape = None ) :
def list ( self , * args , ** kwargs ) :
def list ( self , * args , ** kwargs ) :
def list ( self ) :
def listdir ( self , path ) :
def lists ( self ) :
def literals ( choices , prefix = "" , suffix = "" ) :
def ljust ( value , arg ) :
def load ( parser , token ) :
def load ( self , rawdata ) :
def load_command_class ( app_name , name ) :
def load_handler ( path , * args , ** kwargs ) :
def load_label ( self , fixture_label ) :
def load_middleware ( self ) :
def load_template ( self , template_name , template_dirs = None ) :
def load_template ( self , template_name , template_dirs = None ) :
def load_template_source ( self , template_name , template_dirs = None ) :
def load_template_source ( self , template_name , template_dirs = None ) :
def loaddata ( self , fixture_labels ) :
def loaders ( self ) :
def loads ( s , key = None , salt = 'django.core.signing' , serializer = JSONSerializer , max_age = None ) :
def loads ( self , data ) :
def localize ( value , use_l10n = None ) :
def localize_input ( value , default = None ) :
def localtime ( value , timezone = None ) :
def lock ( f , flags ) :
def log_message ( self , format , * args ) :
def lower ( value ) :
def lru_cache ( maxsize = 100 , typed = False ) :
def luhn ( candidate ) :
def m ( self ) :
def m2m_convert ( n ) :
def m2m_convert ( value ) :
def mail_admins ( subject , message , fail_silently = False , connection = None ,  html_message = None ) :
def mail_managers ( subject , message , fail_silently = False , connection = None ,  html_message = None ) :
def main ( main_func , args = None , kwargs = None ) :
def main_help_text ( self , commands_only = False ) :
def make_aware ( value , timezone ) :
def make_bytes ( self , value ) :
def make_key ( self , key , version = None ) :
def make_key ( self , key , version = None ) :
def make_list ( value ) :
def make_middleware_decorator ( middleware_class ) :
def make_msgid ( idstring = None ) :
def make_naive ( value , timezone ) :
def make_origin ( display_name , loader , name , dirs ) :
def make_style ( opts = ( ) , ** kwargs ) :
def make_template_fragment_key ( fragment_name , vary_on = None ) :
def make_view_atomic ( self , view ) :
def make_writeable ( self , filename ) :
def management_form ( self ) :
def mark_for_escaping ( s ) :
def media ( self ) :
def media_property ( cls ) :
def memoize ( func , cache , num_args ) :
def merge ( self , other ) :
def message ( self ) :
def message_dict ( self ) :
def messages ( self ) :
def method_decorator ( decorator ) :
def migration_progress_callback ( self , action , migration , fake = False ) :
def model_installed ( model ) :
def model_to_dict ( instance , fields = None , exclude = None ) :
def modelform_defines_fields ( form_class ) :
def modelform_factory ( model , form = ModelForm , fields = None , exclude = None ,  formfield_callback = None , widgets = None , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ) :
def modelformset_factory ( model , form = ModelForm , formfield_callback = None ,  formset = BaseModelFormSet , extra = 1 , can_delete = False ,  can_order = False , max_num = None , fields = None , exclude = None ,  widgets = None , validate_max = False , localized_fields = None ,  labels = None , help_texts = None , error_messages = None ,  min_num = None , validate_min = False ) :
def modified_time ( self , name ) :
def modified_time ( self , name ) :
def module_has_submodule ( package , module_name ) :
def module_to_dict ( module , omittable = lambda k : k . startswith ( '_' ) ) :
def more ( self ) :
def multiple_chunks ( self , chunk_size = None ) :
def multiple_chunks ( self , chunk_size = None ) :
def n ( self ) :
def namespace_dict ( self ) :
def needs_multipart_form ( self ) :
def negate ( self ) :
def new ( self , values = None ) :
def new_date ( d ) :
def new_datetime ( d ) :
def new_file ( self , * args , ** kwargs ) :
def new_file ( self , field_name , file_name , content_type , content_length , charset = None , content_type_extra = None ) :
def new_file ( self , file_name , * args , ** kwargs ) :
def new_method_proxy ( func ) :
def next ( self ) :
def next_char ( input_iter ) :
def next_page_number ( self ) :
def next_space_index ( subject , i ) :
def next_token ( self ) :
def ngettext ( singular , plural , number ) :
def ngettext_lazy ( singular , plural , number = None ) :
def no_style ( ) :
def nodelist ( self ) :
def non_field_errors ( self ) :
def non_form_errors ( self ) :
def normalize ( pattern ) :
def normalize_col_name ( self , col_name , used_column_names , is_relation ) :
def normalize_newlines ( text ) :
def now ( ) :
def now ( parser , token ) :
def npath ( path ) :
def npgettext ( context , singular , plural , number ) :
def npgettext ( context , singular , plural , number ) :
def npgettext_lazy ( context , singular , plural , number = None ) :
def nud ( self , parser ) :
def nud ( self , parser ) :
def num_items ( self ) :
def number_format ( value , decimal_pos = None , use_l10n = None , force_grouping = False ) :
def O ( self ) :
def open ( self , mode = None ) :
def open ( self , mode = None ) :
def open ( self , name , mode = 'rb' ) :
def open ( self ) :
def ordered_forms ( self ) :
def P ( self ) :
def page ( self , number ) :
def parse ( self , parse_until = None ) :
def parse ( self ) :
def parse_accept_lang_header ( lang_string ) :
def parse_args ( self , args = None , namespace = None ) :
def parse_bits ( parser , bits , params , varargs , varkw , defaults ,  takes_context , name ) :
def parse_boundary_stream ( stream , max_header_size ) :
def parse_color_setting ( config_string ) :
def parse_cookie ( cookie ) :
def parse_date ( value ) :
def parse_datetime ( value ) :
def parse_endtag ( self , i ) :
def parse_etags ( etag_str ) :
def parse_file_upload ( self , META , post_data ) :
def parse_header ( line ) :
def parse_http_date ( date ) :
def parse_http_date_safe ( date ) :
def parse_name ( self , fixture_name ) :
def parse_starttag ( self , i ) :
def parse_time ( value ) :
def partition ( predicate , values ) :
def parts ( ) :
def patch_cache_control ( response , ** kwargs ) :
def patch_response_headers ( response , cache_timeout = None ) :
def patch_vary_headers ( response , newheaders ) :
def path ( self , name ) :
def path ( self ) :
def pbkdf2 ( password , salt , iterations , dklen = 0 , digest = None ) :
def pgettext ( context , message ) :
def pgettext ( context , message ) :
def phone2numeric ( phone ) :
def phone2numeric_filter ( value ) :
def pk_is_not_editable ( pk ) :
def pluralize ( value , arg = 's' ) :
def pop ( self , idx = - 1 ) :
def pop ( self , k , * args ) :
def pop ( self , key , * args ) :
def pop ( self , key , default = None ) :
def pop ( self , name ) :
def pop ( self ) :
def popen_wrapper ( args , os_err_exc_type = CommandError ) :
def popitem ( self ) :
def pprint ( value ) :
def prefix ( bp , func ) :
def prepare_js_for_gettext ( js ) :
def prepare_value ( self , value ) :
def prepare_value ( self , value ) :
def prepare_value ( self , value ) :
def prepend_token ( self , token ) :
def pretty_name ( name ) :
def previous_page_number ( self ) :
def print_ ( * args , ** kwargs ) :
def print_help ( self , prog_name , subcommand ) :
def process ( self , command , domain ) :
def process_default ( self , event ) :
def push ( self , * args , ** kwargs ) :
def push ( self , name , block ) :
def python_2_unicode_compatible ( klass ) :
def python_reloader ( main_func , args , kwargs ) :
def quote_etag ( etag ) :
def r ( self ) :
def random ( value ) :
def read ( self , * args , ** kwargs ) :
def read ( self , size = None ) :
def read ( self , size = None ) :
def read ( self ) :
def reader ( self ) :
def reader_enters ( self ) :
def reader_leaves ( self ) :
def readline ( self , * args , ** kwargs ) :
def readline ( self , size = None ) :
def readlines ( self ) :
def receive_data_chunk ( self , raw_data , start ) :
def receive_data_chunk ( self , raw_data , start ) :
def receive_data_chunk ( self , raw_data , start ) :
def recipients ( self ) :
def regex ( self ) :
def register ( self , * tags ) :
def register_serializer ( format , serializer_module , serializers = None ) :
def regroup ( parser , token ) :
def reload ( self ) :
def reload ( self ) :
def reloader_thread ( ) :
def remove ( self , item ) :
def remove_move ( name ) :
def remove_potfiles ( self ) :
def remove_tags ( html , tags ) :
def removetags ( value , tags ) :
def render ( self , context ) :
def render ( self , context ) :
def render ( self , context ) :
def render ( self , context ) :
def render ( self , context ) :
def render ( self , name , value , attrs = None , choices = ( ) ) :
def render ( self , name , value , attrs = None ) :
def render ( self , name = None , value = None , attrs = None , choices = ( ) ) :
def render ( self ) :
def render_css ( self ) :
def render_js ( self ) :
def render_node ( self , node , context ) :
def render_option ( self , selected_choices , option_value , option_label ) :
def render_options ( self , choices , selected_choices ) :
def render_to_string ( template_name , dictionary = None , context_instance = None ,  dirs = None ) :
def render_value_in_context ( value , context ) :
def rendered_content ( self ) :
def represent_decimal ( self , data ) :
def request ( request ) :
def reraise ( tp , value , tb = None ) :
def reset ( self ) :
def reset_cache ( ** kwargs ) :
def reset_format_cache ( ) :
def reset_translations ( ) :
def resolve ( path , urlconf = None ) :
def resolve ( self , context , ignore_failures = False ) :
def resolve ( self , context ) :
def resolve ( self , path ) :
def resolve ( self , path ) :
def resolve ( self , s ) :
def resolve_context ( self , context ) :
def resolve_error_handler ( self , view_type ) :
def resolve_expression ( self , obj , context ) :
def resolve_template ( self , template ) :
def resolve_variable ( path , context ) :
def restart_with_reloader ( ) :
def reverse ( self , lookup_view , * args , ** kwargs ) :
def reverse ( viewname , urlconf = None , args = None , kwargs = None , prefix = None , current_app = None ) :
def reverse_dict ( self ) :
def rfc2822_date ( date ) :
def rfc3339_date ( date ) :
def rjust ( value , arg ) :
def run ( addr , port , wsgi_handler , ipv6 = False , threading = False ) :
def run ( self , ** options ) :
def run_checks ( self , app_configs = None , tags = None ) :
def run_from_argv ( self , argv ) :
def run_shell ( self , shell = None ) :
def run_validators ( self , value ) :
def runfastcgi ( argset = [ ] , ** kwargs ) :
def s ( self ) :
def safe ( value ) :
def safe_join ( base , * paths ) :
def safeseq ( value ) :
def salted_hmac ( key_salt , value , secret = None ) :
def same_origin ( url1 , url2 ) :
def sanitize_address ( addr , encoding ) :
def sanitize_separators ( value ) :
def save ( self , commit = True ) :
def save ( self , name , content ) :
def save ( self , save_m2m = True , using = None ) :
def save_existing ( self , form , instance , commit = True ) :
def save_existing_objects ( self , commit = True ) :
def save_instance ( form , instance , fields = None , fail_message = 'saved' ,  commit = True , exclude = None , construct = True ) :
def save_m2m ( ) :
def save_m2m ( ) :
def save_new ( self , form , commit = True ) :
def save_new ( self , form , commit = True ) :
def save_new_objects ( self , commit = True ) :
def scheme ( self ) :
def select_template ( template_name_list , dirs = None ) :
def send ( self , fail_silently = False ) :
def send_mail ( subject , message , from_email , recipient_list ,  fail_silently = False , auth_user = None , auth_password = None ,  connection = None , html_message = None ) :
def send_mass_mail ( datatuple , fail_silently = False , auth_user = None ,  auth_password = None , connection = None ) :
def send_messages ( self , email_messages ) :
def send_messages ( self , email_messages ) :
def send_messages ( self , messages ) :
def serialize ( format , queryset , ** options ) :
def serialize ( self , queryset , ** options ) :
def serialize ( self ) :
def serialize_headers ( self ) :
def server_bind ( self ) :
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :
def set ( self , key , value , timeout = DEFAULT_TIMEOUT , version = None ) :
def set_cdata_mode ( self , tag ) :
def set_cookie ( self , key , value = '' , max_age = None , expires = None , path = '/' ,  domain = None , secure = False , httponly = False ) :
def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :
def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :
def set_many ( self , data , timeout = DEFAULT_TIMEOUT , version = None ) :
def set_script_prefix ( prefix ) :
def set_signed_cookie ( self , key , value , salt = '' , ** kwargs ) :
def set_urlconf ( urlconf_name ) :
def setdefault ( self , key , default ) :
def setdefault ( self , key , default = None ) :
def setlist ( self , key , list_ ) :
def setlistdefault ( self , key , default_list = None ) :
def show_migration_list ( self , connection , app_names = None ) :
def sign ( self , value ) :
def signature ( self , value ) :
def simple_tag ( self , func = None , takes_context = None , name = None ) :
def size ( self , name ) :
def skip_past ( self , endtag ) :
def slice_filter ( value , arg ) :
def slugify ( value ) :
def smart_bytes ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
def smart_split ( text ) :
def smart_text ( s , encoding = 'utf-8' , strings_only = False , errors = 'strict' ) :
def smart_urlquote ( url ) :
def sort_dependencies ( app_list ) :
def source_error ( self , source , msg ) :
def spaceless ( parser , token ) :
def split_contents ( self ) :
def split_domain_port ( host ) :
def split_leading_dir ( self , path ) :
def split_url ( url ) :
def splitext ( self , the_path ) :
def sql_all ( app_config , style , connection ) :
def sql_create ( app_config , style , connection ) :
def sql_custom ( app_config , style , connection ) :
def sql_delete ( app_config , style , connection , close_connection = True ) :
def sql_destroy_indexes ( app_config , style , connection ) :
def sql_flush ( style , connection , only_django = False , reset_sequences = True , allow_cascade = False ) :
def sql_indexes ( app_config , style , connection ) :
def ssi ( parser , token ) :
def start_doctype_decl ( self , name , sysid , pubid , has_internal_subset ) :
def start_index ( self ) :
def start_object ( self , obj ) :
def start_object ( self , obj ) :
def start_serialization ( self ) :
def static ( request ) :
def streaming_content ( self , value ) :
def streaming_content ( self ) :
def strftime ( dt , fmt ) :
def strftime ( self , fmt ) :
def stringfilter ( func ) :
def stringformat ( value , arg ) :
def strip_entities ( value ) :
def strip_spaces_between_tags ( value ) :
def strip_tags ( value ) :
def striptags ( value ) :
def strptime ( self , value , format ) :
def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :
def subwidgets ( self , name , value , attrs = None , choices = ( ) ) :
def super ( self ) :
def supports_color ( ) :
def symlinks_supported ( ) :
def sync_apps ( self , connection , app_labels ) :
def T ( self ) :
def tag ( self , name = None , compile_function = None ) :
def tag ( self ) :
def tag_exists ( self , tag ) :
def tag_function ( self , func ) :
def tags_available ( self ) :
def tell ( self ) :
def template_localtime ( value , use_tz = None ) :
def templatetag ( parser , token ) :
def templatize ( src , origin = None ) :
def temporary_file_path ( self ) :
def time ( value , arg = None ) :
def time_format ( value , format = None , use_l10n = None ) :
def time_format ( value , format_string ) :
def timesince ( d , now = None , reversed = False ) :
def timesince_filter ( value , arg = None ) :
def timestamp ( self ) :
def timeuntil ( d , now = None ) :
def timeuntil_filter ( value , arg = None ) :
def title ( value ) :
def to_bytes ( val , encoding ) :
def to_current_timezone ( value ) :
def to_language ( locale ) :
def to_language ( self ) :
def to_locale ( language , to_lower = False ) :
def to_locale ( language ) :
def to_python ( self , data ) :
def to_python ( self , data ) :
def to_python ( self , value ) :
def to_python ( self , value ) :
def to_python ( self , value ) :
def to_python ( self , value ) :
def to_python ( self , value ) :
def to_python ( self , value ) :
def to_python ( self , value ) :
def token_kwargs ( bits , parser , support_legacy = False ) :
def tokenize ( self ) :
def top ( self ) :
def total_error_count ( self ) :
def total_form_count ( self ) :
def total_ordering ( cls ) :
def transform ( self , node , results ) :
def translate_token ( self , token ) :
def translation ( language ) :
def trim_url ( x , limit = trim_url_limit ) :
def trim_whitespace ( s ) :
def truncatechars ( value , arg ) :
def truncatechars_html ( value , arg ) :
def truncatewords ( value , arg ) :
def truncatewords_html ( value , arg ) :
def tz ( request ) :
def tzname ( self , dt ) :
def tzname ( self , dt ) :
def u ( s ) :
def u ( self ) :
def U ( self ) :
def ugettext ( message ) :
def ugettext ( message ) :
def unclosed_block_tag ( self , parse_until ) :
def unclosed_block_tag ( self , parse_until ) :
def unescape_entities ( text ) :
def unescape_string_literal ( s ) :
def unget ( self , bytes ) :
def ungettext ( singular , plural , number ) :
def ungettext_lazy ( singular , plural , number = None ) :
def unlock ( f ) :
def unordered_list ( value , autoescape = None ) :
def unparsed_entity_decl ( self , name , base , sysid , pubid , notation_name ) :
def unregister_serializer ( format ) :
def unsign ( self , signed_value ) :
def unsign ( self , value , max_age = None ) :
def upath ( path ) :
def update ( self , * args , ** kwargs ) :
def update ( self , dict_ ) :
def update ( self , other_dict ) :
def update_error_dict ( self , error_dict ) :
def update_watch ( sender = None , ** kwargs ) :
def upload_complete ( self ) :
def upload_handlers ( self , upload_handlers ) :
def upload_handlers ( self ) :
def upper ( value ) :
def url ( parser , token ) :
def url ( self , name ) :
def url_patterns ( self ) :
def urlconf_module ( self ) :
def urlencode ( query , doseq = 0 ) :
def urlencode ( self , safe = None ) :
def urlencode ( value , safe = None ) :
def urlize ( text , trim_url_limit = None , nofollow = False , autoescape = False ) :
def urlize ( value , autoescape = None ) :
def urlizetrunc ( value , limit , autoescape = None ) :
def urlquote ( url , safe = '/' ) :
def urlquote_plus ( url , safe = '' ) :
def urlsafe_base64_decode ( s ) :
def urlsafe_base64_encode ( s ) :
def urlunquote ( quoted_url ) :
def urlunquote_plus ( quoted_url ) :
def usage ( self , subcommand ) :
def usage ( self , subcommand ) :
def use_argparse ( self ) :
def utcoffset ( self , dt ) :
def utcoffset ( self , dt ) :
def valid_ident ( s ) :
def valid_value ( self , value ) :
def validate ( self , app_config = None , display_num_errors = False ) :
def validate ( self , value ) :
def validate ( self , value ) :
def validate ( self , value ) :
def validate_domain_part ( self , domain_part ) :
def validate_host ( host , allowed_hosts ) :
def validate_integer ( value ) :
def validate_ipv46_address ( value ) :
def validate_ipv6_address ( value ) :
def validate_key ( self , key ) :
def validate_name ( self , name , app_or_project ) :
def validate_number ( self , number ) :
def validate_unique ( self ) :
def value ( self ) :
def value_encode ( self , val ) :
def value_from_datadict ( self , data , files , name ) :
def value_from_datadict ( self , data , files , name ) :
def value_from_datadict ( self , data , files , name ) :
def value_from_datadict ( self , data , files , name ) :
def value_from_datadict ( self , data , files , name ) :
def value_from_datadict ( self , data , files , name ) :
def value_from_datadict ( self , data , files , name ) :
def values ( self ) :
def verbatim ( parser , token ) :
def visible_fields ( self ) :
def w ( self ) :
def W ( self ) :
def walk_to_end ( ch , input_iter ) :
def widget_attrs ( self , widget ) :
def widthratio ( parser , token ) :
def with_metaclass ( meta , * bases ) :
def wordcount ( value ) :
def words ( self , num , truncate = None , html = False ) :
def wordwrap ( value , arg ) :
def wrap ( text , width ) :
def wrapped ( * args , ** kwargs ) :
def wrapper ( * args , ** kwargs ) :
def wrapper ( * args , ** kwargs ) :
def wrapper ( * args , ** kwds ) :
def wrapper ( * args ) :
def wrapper ( cls ) :
def write ( data ) :
def write ( self , content ) :
def write ( self , content ) :
def write ( self , msg , style_func = None , ending = None ) :
def write ( self , outfile , encoding ) :
def write ( self , outfile , encoding ) :
def write ( self , s ) :
def write ( self , val ) :
def write_items ( self , handler ) :
def write_message ( self , message ) :
def write_migration_files ( self , changes ) :
def write_po_file ( self , potfile , locale ) :
def write_pot_file ( potfile , msgs ) :
def writer ( self ) :
def writer_enters ( self ) :
def writer_leaves ( self ) :
def writeString ( self , encoding ) :
def xreadlines ( self ) :
def y ( self ) :
def yesno ( value , arg = None ) :
def Z ( self ) :
default = 'DEFAULT'
default = bytes_to_text ( default , self . encoding )
DEFAULT_ATTACHMENT_MIME_TYPE = 'application/octet-stream'
default_attrs . update ( attrs )
default_attrs = { 'cols' : '40' , 'rows' : '10' }
DEFAULT_CACHE_ALIAS = 'default'
DEFAULT_CHUNK_SIZE = 64 * 2 ** 10
DEFAULT_CHUNK_SIZE = 64 * 2 ** 10
default_error_messages = {  'invalid_choice' : _ ( 'Select a valid choice. %(value)s is not one of the available choices.' ) ,  'invalid_list' : _ ( 'Enter a list of values.' ) ,  }
default_error_messages = {  'invalid_choice' : _ ( 'Select a valid choice. %(value)s is not one of the available choices.' ) ,  }
default_error_messages = {  'invalid_choice' : _ ( 'Select a valid choice. That choice is not one of'  ' the available choices.' ) ,  }
default_error_messages = {  'invalid_choice' : _ ( 'The inline foreign key did not match the parent instance primary key.' ) ,  }
default_error_messages = {  'invalid_date' : _ ( 'Enter a valid date.' ) ,  'invalid_time' : _ ( 'Enter a valid time.' ) ,  }
default_error_messages = {  'invalid_image' : _ ( "Upload a valid image. The file you uploaded was either not an image or a corrupted image." ) ,  }
default_error_messages = {  'invalid' : _ ( 'Enter a list of values.' ) ,  'incomplete' : _ ( 'Enter a complete value.' ) ,  }
default_error_messages = {  'invalid' : _ ( 'Enter a number.' ) ,  'max_digits' : ungettext_lazy (  'Ensure that there are no more than %(max)s digit in total.' ,  'Ensure that there are no more than %(max)s digits in total.' ,  'max' ) ,  'max_decimal_places' : ungettext_lazy (  'Ensure that there are no more than %(max)s decimal place.' ,  'Ensure that there are no more than %(max)s decimal places.' ,  'max' ) ,  'max_whole_digits' : ungettext_lazy (  'Ensure that there are no more than %(max)s digit before the decimal point.' ,  'Ensure that there are no more than %(max)s digits before the decimal point.' ,  'max' ) ,  }
default_error_messages = {  'invalid' : _ ( 'Enter a number.' ) ,  }
default_error_messages = {  'invalid' : _ ( 'Enter a valid date.' ) ,  }
default_error_messages = {  'invalid' : _ ( 'Enter a valid date/time.' ) ,  }
default_error_messages = {  'invalid' : _ ( 'Enter a valid time.' )  }
default_error_messages = {  'invalid' : _ ( 'Enter a valid URL.' ) ,  }
default_error_messages = {  'invalid' : _ ( 'Enter a whole number.' ) ,  }
default_error_messages = {  'invalid' : _ ( "No file was submitted. Check the encoding type on the form." ) ,  'missing' : _ ( "No file was submitted." ) ,  'empty' : _ ( "The submitted file is empty." ) ,  'max_length' : ungettext_lazy (  'Ensure this filename has at most %(max)d character (it has %(length)d).' ,  'Ensure this filename has at most %(max)d characters (it has %(length)d).' ,  'max' ) ,  'contradiction' : _ ( 'Please either submit a file or check the clear checkbox, not both.' )  }
default_error_messages = {  'list' : _ ( 'Enter a list of values.' ) ,  'invalid_choice' : _ ( 'Select a valid choice. %(value)s is not one of the'  ' available choices.' ) ,  'invalid_pk_value' : _ ( '"%(pk)s" is not a valid value for a primary key.' )  }
default_error_messages = {  'required' : _ ( 'This field is required.' ) ,  }
default_list = [ ]
DEFAULT_LOCALE_ENCODING = get_system_encoding ( )
DEFAULT_LOGGING = {  'version' : 1 ,  'disable_existing_loggers' : False ,  'filters' : {  'require_debug_false' : {  '()' : 'django.utils.log.RequireDebugFalse' ,  } ,  'require_debug_true' : {  '()' : 'django.utils.log.RequireDebugTrue' ,  } ,  } ,  'handlers' : {  'console' : {  'level' : 'INFO' ,  'filters' : [ 'require_debug_true' ] ,  'class' : 'logging.StreamHandler' ,  } ,  'null' : {  'class' : 'logging.NullHandler' ,  } ,  'mail_admins' : {  'level' : 'ERROR' ,  'filters' : [ 'require_debug_false' ] ,  'class' : 'django.utils.log.AdminEmailHandler'  }  } ,  'loggers' : {  'django' : {  'handlers' : [ 'console' ] ,  } ,  'django.request' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'django.security' : {  'handlers' : [ 'mail_admins' ] ,  'level' : 'ERROR' ,  'propagate' : False ,  } ,  'py.warnings' : {  'handlers' : [ 'console' ] ,  } ,  }  }
DEFAULT_MAX_NUM = 1000
DEFAULT_MIN_NUM = 0
DEFAULT_PALETTE = DARK_PALETTE
DEFAULT_PORT = "8000"
default_settings = module_to_dict ( global_settings )
default_storage = DefaultStorage ( )
DEFAULT_TIMEOUT = object ( )
default_translation = translation ( settings . LANGUAGE_CODE )
default_validators = [ ]
default_validators = [ validators . URLValidator ( ) ]
default_validators = [ validators . validate_email ]
default_validators = [ validators . validate_ipv4_address ]
default_validators = [ validators . validate_slug ]
DefaultFeed = Rss201rev2Feed
defaults , _ = parser . parse_args ( args = [ ] )
defaults . update ( kwargs )
defaults [ 'data' ] = self . data
defaults [ 'empty_permitted' ] = True
defaults [ 'files' ] = self . files
defaults [ 'initial' ] = self . initial [ i ]
defaults = {  'auto_id' : self . auto_id ,  'prefix' : self . add_prefix ( i ) ,  'error_class' : self . error_class ,  }
defaults = { 'data' : data , 'files' : files , 'auto_id' : auto_id , 'prefix' : prefix }
defaults = dict ( defaults . __dict__ , ** options )
defaults = dict ( defaults . _get_kwargs ( ) , ** options )
defaults = parser . parse_args ( args = args )
definition [ 'bg' ] = colors [ - 1 ]
definition [ 'fg' ] = fg
definition [ 'opts' ] = opts
definition = { }
definition = getattr ( cls , 'Media' , None )
del _active . value
del _error_files [ _error_files . index ( filename ) ]
del _prefixes . value
del _serializers [ format ]
del _urlconfs . value
del attr
del attr
del attrs [ attr ]
del bits [ : 1 ]
del bits [ : 3 ]
del cache [ oldkey ]
del cc [ 'private' ]
del cc [ 'public' ]
del cmd_options [ 'args' ]
del form . cleaned_data [ field ]
del form . cleaned_data [ field ]
del frame
del kwargs [ 'warning' ]
del logging . _handlerList [ : ]
del moves . __dict__ [ name ]
del obj_dict [ attr ]
del options [ 'liveserver' ]
del self . _cache [ key ]
del self . _cache [ key ]
del self . _expire_info [ key ]
del self . _expire_info [ key ]
del self . _expire_info [ key ]
del self . _get
del self . _headers [ header . lower ( ) ]
del self . _post
del self . cleaned_data [ field ]
del self . dict [ item ]
del self . dicts [ - 1 ] [ key ]
del self . tokens [ 0 ]
del self [ 'Content-Transfer-Encoding' ]
del self [ 'content-type' ]
del self [ key ]
del Trans
del X
delattr ( _MovedItems , name )
delattr ( obj . __class__ , self . name )
delattr ( self . _wrapped , name )
DELETION_FIELD_NAME = 'DELETE'
delta = ( d - now ) if reversed else ( now - d )
delta = 2000 - year
delta = delta + datetime . timedelta ( seconds = 1 )
delta = expires - expires . utcnow ( )
deprecation_warning = renamed_method [ 2 ]
deps . append ( rel_model )
deps = [ ]
deps = [ apps . get_model ( dep ) for dep in deps ]
deps = getattr ( model . natural_key , 'dependencies' , [ ] )
description = "An instance of the '%s' class" % receiver . __class__ . __name__
description = "The '%s' function" % receiver . __name__
df = DateFormat ( value )
dfmt = config . get ( 'datefmt' , None )
dict . __setitem__ ( result , copy . deepcopy ( key , memo ) ,  copy . deepcopy ( value , memo ) )
dict . __setitem__ ( self , key , http_cookies . Morsel ( ) )
dict . __setitem__ ( self , key , M )
dictConfigClass ( config ) . configure ( )
dictConfigClass = DictConfigurator
dictreprs = ', ' . join ( repr ( d ) for d in self . dicts )
dig1 , dig2 = inner . copy ( ) , outer . copy ( )
dig1 . update ( u )
dig2 . update ( dig1 . digest ( ) )
digest = hashlib . sha256
digit = x % len ( to_digits )
DIGIT_PATTERN = re . compile ( r'^\d+$' )
digits . append ( '-' )
digits . append ( '0' )
digits . insert ( - exponent , '.' )
digits = "0123456789abcdefghijklmnopqrstuvwxyz"
digits = [ six . text_type ( digit ) for digit in reversed ( digits ) ]
digits = decimals
digits = len ( digittuple )
dir_name , file_name = os . path . split ( name )
dir_suffix = '%s*' % os . sep
directories , files = [ ] , [ ]
directories . append ( entry )
directory = os . path . dirname ( full_path )
directory_created [ app_label ] = True
directory_created = { }
dirname = os . path . dirname ( filename )
dirname = os . path . dirname ( filename )
dirnames . remove ( dirname )
dirnames . remove ( dirname )
dirs . append ( '' )
dirs . append ( app_dir )
dirs . extend ( list ( settings . FIXTURE_DIRS ) )
dirs . remove ( dirname )
dirs = [ ]
dirs = [ basedir ]
dirs = [ os . path . join ( basedir , l , 'LC_MESSAGES' ) for l in locales ]
dirs = [ upath ( os . path . abspath ( os . path . realpath ( d ) ) ) for d in dirs ]
disable_existing = config . pop ( 'disable_existing_loggers' , True )
display_url = tmp + '/'
display_url = url
disposition = meta_data [ 'content-disposition' ] [ 1 ]
django . setup ( )
django . setup ( )
DJANGO_COLORS = os . environ . get ( 'DJANGO_COLORS' , '' )
django_dir = os . path . normpath ( os . path . join ( os . path . dirname ( django . __file__ ) ) )
django_po = os . path . join ( django_dir , 'conf' , 'locale' , locale , 'LC_MESSAGES' , '%s.po' % domain )
DjangoSafeDumper . add_representer ( decimal . Decimal , DjangoSafeDumper . represent_decimal )
dklen = hlen
dklen = None
dlen = len ( defaults or [ ] )
DNS_NAME = CachedDnsName ( )
docs_version = '%d.%d' % django . VERSION [ : 2 ]
docs_version = 'dev'
domain , port = split_domain_port ( host )
domain = domain . encode ( 'idna' ) . decode ( 'ascii' )
domain = domain . encode ( 'idna' ) . decode ( 'ascii' )
domain_part = domain_part . encode ( 'idna' ) . decode ( 'ascii' )
domain_regex = re . compile (    r'(?:[A-Z0-9](?:[A-Z0-9-]{0,247}[A-Z0-9])?\.)+(?:[A-Z]{2,6}|[A-Z0-9-]{2,}(?<!-))$' ,  re . IGNORECASE )
domain_whitelist = [ 'localhost' ]
domains = ( 'django' , )
domains = ( 'djangojs' , 'django' )
doomed = [ k for ( i , k ) in enumerate ( self . _cache ) if i % self . _cull_frequency == 0 ]
dot = callback . rindex ( '.' )
dot = len ( package )
dot = package . rindex ( '.' , 0 , dot )
DOT_PATTERN = re . compile ( r'^\.\s*(\w+)\s*' )
dot_re = re . compile ( r'\S' )
DOTS = [ '&middot;' , '*' , '\u2022' , '&#149;' , '&bull;' , '&#8226;' ]
doublecolon_len += 1
doublecolon_len = 0
doublecolon_len = 0
doublecolon_start = - 1
doublecolon_start = - 1
doublecolon_start = index
dow = days [ date . weekday ( ) ]
doy += 1
doy = self . year_days [ self . data . month ] + self . data . day
duplicate . dicts = self . dicts [ : ]
duplicate . render_context = copy ( self . render_context )
duplicate = copy ( super ( BaseContext , self ) )
duplicate = super ( Context , self ) . __copy__ ( )
e , tb = sys . exc_info ( ) [ 1 : ]
e . args = ( "Could not load %(app_label)s.%(object_name)s(pk=%(pk)s): %(error_msg)s" % {  'app_label' : obj . object . _meta . app_label ,  'object_name' : obj . object . _meta . object_name ,  'pk' : obj . object . pk ,  'error_msg' : force_text ( e )  } , )
e . args = ( "Problem installing fixture '%s': %s" % ( fixture_file , e ) , )
e . args = ( "Problem installing fixtures: %s" % e , )
e . django_template_source = node . source
e . django_template_source = self . source
e . django_template_source = source
e . django_template_source = token . source
e . message = self . error_messages [ e . code ]
e . reason += ', HTTP response headers must be in %s format' % charset
e = TemplateSyntaxError ( msg )
elif _len ( cache ) >= maxsize :
elif _locs_ is None :
elif ':' not in middle and simple_email_re . match ( middle ) :
elif '\\' in path :
elif '=' in part :
elif 'HTTP_HOST' in self . META :
elif 'public' in cc and 'private' in kwargs :
elif ( attrvalue [ : 1 ] == '\'' == attrvalue [ - 1 : ] or  attrvalue [ : 1 ] == '"' == attrvalue [ - 1 : ] ) :
elif action == "apply_success" :
elif action == "unapply_start" :
elif action == "unapply_success" :
elif args [ - 2 ] == "as" :
elif args [ 1 ] [ 0 ] == '1' :
elif args [ 1 ] [ 0 ] == '3' :
elif args [ 1 ] [ 0 ] == '4' :
elif args [ 1 ] == '304' :
elif args [ 1 ] == '404' :
elif auto_id :
elif autoescape :
elif basetype == 'message' and subtype == 'rfc822' :
elif bmatch :
elif bytes < GB :
elif bytes < MB :
elif bytes < PB :
elif bytes < TB :
elif callable ( func ) :
elif callable ( func ) :
elif ch != 'P' :
elif ch == ':' :
elif ch == '.' :
elif ch == '(' :
elif ch == ')' :
elif ch == '[' :
elif ch == '|' :
elif ch == '$' :
elif ch == "^" :
elif ch in "*?+{" :
elif change == I18N_MODIFIED :
elif char == '\\' :
elif char in 'bEFMmNn' :
elif char in 'dj' :
elif char in 'Yy' :
elif child . nodeType == child . ELEMENT_NODE :
elif closing_tag :
elif cls . _delegate_bytes :
elif cmatches :
elif command . verbosity > 0 :
elif common_prefix is None :
elif count > 1 :
elif cwords [ 0 ] in ( 'dumpdata' , 'sql' , 'sqlall' , 'sqlclear' ,  'sqlcustom' , 'sqlindexes' , 'sqlsequencereset' , 'test' ) :
elif cwords [ 0 ] in subcommands and cwords [ 0 ] != 'help' :
elif dirname == 'locale' :
elif disable_existing :
elif domain == 'django' and ( file_ext == '.py' or file_ext in command . extensions ) :
elif f . unique :
elif field . rel and isinstance ( field . rel , models . ManyToOneRel ) :
elif field . rel and isinstance ( field . rel , models . ManyToOneRel ) :
elif field . required :
elif field in self . _errors . keys ( ) :
elif field in self . fields :
elif field_type == 'IntegerField(' and not connection . features . can_introspect_autofield :
elif finder . find_module ( name ) :
elif form . has_changed ( ) :
elif g [ 0 ] == "'" :
elif getattr ( current , 'alters_data' , False ) :
elif hasattr ( pattern , '_callback' ) :
elif hasattr ( query , 'items' ) :
elif hasattr ( s , '__unicode__' ) :
elif i < list_length - 1 :
elif indexes [ column_name ] [ 'unique' ] :
elif int ( timeout ) == 0 :
elif intrans :
elif isinstance ( message , list ) :
elif isinstance ( o , datetime . date ) :
elif isinstance ( o , datetime . time ) :
elif isinstance ( o , decimal . Decimal ) :
elif isinstance ( obj , EscapeData ) :
elif isinstance ( rhs , SafeBytes ) :
elif isinstance ( self . obj , models . base . ModelBase ) :
elif isinstance ( template , six . string_types ) :
elif isinstance ( timezone , six . string_types ) and pytz is not None :
elif isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
elif isinstance ( value , datetime . date ) :
elif isinstance ( value , datetime . datetime ) :
elif isinstance ( value , datetime . time ) :
elif isinstance ( value , six . string_types ) :
elif issubclass ( klass , logging . handlers . SMTPHandler ) and 'mailhost' in config :
elif issubclass ( klass , logging . handlers . SysLogHandler ) and 'address' in config :
elif item [ "author_email" ] :
elif item [ "author_name" ] :
elif item_type == FILE :
elif k == 'bg' :
elif len ( app_labels ) > 1 :
elif len ( bits ) == 6 :
elif len ( fks_to_parent ) == 0 :
elif len ( fks_to_parent ) == 0 :
elif len ( key ) == 1 and type ( key [ 0 ] ) in fasttypes :
elif len ( options . args ) < 1 :
elif maxsize is None :
elif message_context [ 0 ] == "'" :
elif message_context [ 0 ] == "'" :
elif msg :
elif msg and visible_issue_count :
elif name == 'abcd':
elif name == 'id' :
elif name == 'string' :
elif name in lib . filters :
elif name is not None and compile_function is None :
elif name is not None and compile_function is not None :
elif name is not None and filter_func is None :
elif name is not None and filter_func is not None :
elif not base_url . endswith ( '/' ) :
elif not callable ( formfield_callback ) :
elif not hasattr ( message , 'message' if six . PY3 else 'code' ) :
elif not isinstance ( content , Message ) :
elif not isinstance ( end , str ) :
elif not isinstance ( file_name , six . string_types ) and is_iterable ( file_name ) :
elif not isinstance ( sep , str ) :
elif not isinstance ( value , ( list , tuple ) ) :
elif not isinstance ( value , ConvertingList ) and isinstance ( value , list ) :
elif not isinstance ( value , ConvertingTuple ) and isinstance ( value , tuple ) :
elif not options [ "socket" ] and not options [ "host" ] and not options [ "port" ] :
elif not os . path . exists ( self . file_path ) :
elif not self . required and not value :
elif ns not in app_list :
elif option == 'only' :
elif options [ 'all' ] :
elif options [ 'app_label' ] :
elif options [ 'method' ] in ( 'thread' , 'threaded' ) :
elif options [ "daemonize" ] . lower ( ) in ( 'false' , 'no' , 'f' ) :
elif options [ "socket" ] and not options [ "host" ] and not options [ "port" ] :
elif param in kwargs :
elif piece :
elif pluralmatch :
elif prefix != common_prefix :
elif safe_input :
elif self . _delegate_text :
elif self . _meta . exclude and field in self . _meta . exclude :
elif self . _meta . fields and field not in self . _meta . fields :
elif self . argv [ 1 : ] in ( [ '--help' ] , [ '-h' ] ) :
elif self . fixture_object_count == self . loaded_object_count :
elif self . META . get ( 'CONTENT_TYPE' , '' ) . startswith ( 'application/x-www-form-urlencoded' ) :
elif self . name and os . path . exists ( self . name ) :
elif self . nodelist_false :
elif self . reason_phrase is None :
elif self . required :
elif self . use_ipv6 and not _fqdn :
elif self . verbosity == 3 :
elif self . verbosity > 0 :
elif self . waiting_readers != 0 :
elif settings . USE_TZ :
elif simple_url_2_re . match ( middle ) :
elif size < len ( self . buffer ) :
elif str ( level ) == level :
elif subcommand == 'version' or self . argv [ 1 : ] == [ '--version' ] :
elif t . contents == 'comment' :
elif t . token_type == TOKEN_COMMENT :
elif t . token_type == TOKEN_TEXT :
elif t . token_type == TOKEN_VAR :
elif t . token_type == TOKEN_VAR :
elif template_tuple is None :
elif timeout == 0 :
elif token . token_type == 1 :
elif token . token_type == 2 :
elif token_string . startswith ( BLOCK_TAG_START ) :
elif token_string . startswith ( COMMENT_TAG_START ) :
elif total_forms > self . max_num >= 0 :
elif type ( s ) != six . text_type :
elif tzinfo is not None :
elif user_settings [ key ] != default_settings [ key ] :
elif value in ( False , 'False' , '0' ) :
elif value is False :
elif var is None :
elif var_arg :
elif x == 5:
elif x == y:
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
else :
emit_post_migrate_signal ( created_models , self . verbosity , self . interactive , connection . alias )
emit_post_migrate_signal ( set ( all_models ) , verbosity , interactive , database )
emit_pre_migrate_signal ( create_models , self . verbosity , self . interactive , connection . alias )
emitting = chunk [ : remaining ]
empty = object ( )
EMPTY_DICT = { }
en_byte = ""
en_byte = chars[random.randint(0, len(chars)-1)]
enc = hex(dec)[::-1]
encode = lambda k , v : urlencode ( { k : v } )
encoded += '\\x'
encoded += '\\x%02x' % random.randint(1,255)
encoded += '\\x%s' % en_byte
encoded += '\n'
encoded += '%02x,' % y
encoded += '%02x' % x
encoded += '%02x' %xor_rot
encoded += '%02x'% repeat
encoded = '"' + encoded + '"'
encoded = encoded . replace ( ";" , "\\073" ) . replace ( "," , "\\054" )
encoded = val1 | val2
encoded1 += '%02x, ' %z
encoded1 += '%02x,' % (z & 0xaa)
encoded1 += '%02x,' % w
encoded1 += '%02x,' % z
encoded1 += '%02x,' % z
encoded1 += '%02x,' % z
encoded1 += '%02x,' %(8 +(128 + z))
encoded1 += '%02x,' %(z & 0x1f)
encoded1 += '%02x,' %(z-7)
encoded1 += '%02x,' %z
encoded1 += '0x%02x,' % 0xff
encoded1 += '0x%02x,' % tmp
encoded1 = "0x%02x," % len(bytearray(str1))
encoded2 += '%02x,' % repeat
encoded2 += '%02x,' % x
encoded2 += '%02x,' %xor_rot
encoded2 += '0x'
encoded2 += '0x%02x,' % random.randint(1,255)
encoded2 += '0x%s,' % en_byte
encoded3 += '\\x'
encoded3 += '0x'
encoded3 += '0x'
encoded3 = ""
encoding = locale . getdefaultlocale ( ) [ 1 ] or 'ascii'
encoding = None
encoding = property ( lambda self : self . file . encoding )
encoding = self . _encoding
encoding = self . encoding or settings . DEFAULT_CHARSET
encoding = settings . DEFAULT_CHARSET
end -= 1
end = index
end = kwargs . pop ( "end" , None )
end = len ( s )
end = len ( text )
end = newline
end = rawdata [ k : endpos ] . strip ( )
end = s . find ( b';' , end + 1 )
end = s . find ( b';' )
end_index = i
end_index = None
end_tag = 'end' + bits [ 0 ]
end_text_pos = 0
end_text_pos = pos
endblock = parser . next_token ( )
endblock_re = re . compile ( r"""^\s*endblocktrans$""" )
endbmatch = endblock_re . match ( t . contents )
ending = self . ending if ending is None else ending
endpos = self . check_for_whole_start_tag ( i )
endtag_re = re . compile ( '</%s>' % tags_re )
EndToken = EndToken ( )
ensure_echo_on ( )
entropy = int(sys.argv[1])
eol_message = message . replace ( str ( '\r\n' ) , str ( '\n' ) ) . replace ( str ( '\r' ) , str ( '\n' ) )
error = { field or NON_FIELD_ERRORS : error . error_list }
ERROR = 40
error = error . error_dict
error = self . data [ i ]
error = sys . modules [ __name__ + ".moves.urllib_error" ]
error = ValidationError ( error )
error_class = TemplateSyntaxError
error_class = ValueError
error_dict . setdefault ( field , [ ] ) . extend ( error_list )
error_dict . setdefault ( NON_FIELD_ERRORS , [ ] ) . extend ( self . error_list )
error_messages [ 'invalid' ] = error_message
error_messages = kwargs . get ( 'error_messages' ) or { }
error_messages = opts . error_messages [ NON_FIELD_ERRORS ]
error_messages = self . fields [ field ] . error_messages
error_msg += " Got this from the '%s' variable." % self . parent_name . token
error_msg = "Invalid template name in 'extends' tag: %r." % parent
error_msg = "Tried %s" % tried
error_msg = "Your TEMPLATE_DIRS setting is empty. Change it to point to at least one template directory."
error_text = ERRORS [ e . errno ]
error_text = str ( e )
errors . append (  Error (  "%s was connected to the '%s' signal "  "with a lazy reference to the '%s' sender, "  "which has not been installed." % (  description , name , '.' . join ( reference )  ) ,  obj = receiver . __module__ ,  hint = None ,  id = 'signals.E001'  )  )
errors . append ( {  'message' : escape ( message ) if escape_html else message ,  'code' : error . code or '' ,  } )
errors . append ( field . error_messages [ 'incomplete' ] )
errors . append ( self . get_date_error_message ( date_check ) )
errors . append ( self . get_unique_error_message ( unique_check ) )
errors . extend ( _check_boolean_field_default_value ( ** kwargs ) )
errors . extend ( _check_middleware_classes ( ** kwargs ) )
errors . extend ( _check_test_runner ( ** kwargs ) )
errors . extend ( e . error_list )
errors . extend ( m for m in e . error_list if m not in errors )
errors . extend ( new_errors )
errors . update ( kwargs [ 'error_messages' ] )
errors = "strict"
errors = [ ]
errors = [ ]
errors = [ e for e in all_issues if checks . ERROR <= e . level < checks . CRITICAL ]
errors = [ model . check ( ** kwargs )  for model in apps . get_models ( )  if app_configs is None or model . _meta . app_config in app_configs ]
ERRORS = {  errno . EACCES : "You don't have permission to access that port." ,  errno . EADDRINUSE : "That port is already in use." ,  errno . EADDRNOTAVAIL : "That IP address can't be assigned-to." ,  }
errors = getattr ( fp , "errors" , None )
errors = self . default_error_messages . copy ( )
escape = allow_lazy ( escape , six . text_type )
ESCAPE_MAPPINGS = {  "A" : None ,  "b" : None ,  "B" : None ,  "d" : "0" ,  "D" : "x" ,  "s" : " " ,  "S" : "x" ,  "w" : "x" ,  "W" : "!" ,  "Z" : None ,  }
escaped = False
escaped = True
escapejs = allow_lazy ( escapejs , six . text_type )
escaper = conditional_escape
escaper = lambda x : x
EscapeString = EscapeBytes
EscapeString = EscapeText
EscapeUnicode = EscapeText
et , ev , tb = sys . exc_info ( )
ETAG_MATCH = re . compile ( r'(?:W/)?"((?:\\.|[^"])*)"' )
etags = [ e . encode ( 'ascii' ) . decode ( 'unicode_escape' ) for e in etags ]
etags = ETAG_MATCH . findall ( etag_str )
evens = sum ( int ( c ) for c in candidate [ - 1 : : - 2 ] )
EventHandler . modified_code = FILE_MODIFIED
EventHandler . modified_code = I18N_MODIFIED
exc_info = ( None , record . getMessage ( ) , None )
exc_info = record . exc_info
exc_info = sys . exc_info ( )
exc_type = type ( exc )
exc_value . __cause__ = exc
exc_value = exc_type (  "Unsupported value: %r. You should install pytz." % dt )
except _BASE64_DECODE_ERROR :
except :
except :
except :
except :
except :
except ( archive . ArchiveException , IOError ) as e :
except ( AttributeError , TypeError ) :
except ( AttributeError , UnsupportedOperation ) :
except ( DatabaseError , IntegrityError ) as e :
except ( HTMLParseError , UnboundLocalError ) :
except ( ImportError , AttributeError ) :
except ( ImportError , AttributeError ) as e :
except ( ImportError , IndentationError , NameError , SyntaxError ,  TypeError , AttributeError ) :
except ( IndexError ,  ValueError ,  KeyError ,  TypeError ) :
except ( IndexError , TypeError , ValueError ) :
except ( IOError , OSError ) :
except ( KeyError , AttributeError ) as exc :
except ( KeyError , IndexError , AttributeError ) :
except ( KeyError , TypeError ) :
except ( LookupError , BinasciiError ) as e :
except ( LookupError , ImportError ) as e :
except ( LookupError , TypeError ) :
except ( OSError , IOError ) :
except ( OSError , NotImplementedError , AttributeError ) :
except ( OSError , TypeError ) :
except ( OSError ) :
except ( OverflowError , ValueError ) :
except ( OverflowError , ValueError ) as exc :
except ( ssl . SSLError , smtplib . SMTPServerDisconnected ) :
except ( TypeError , AttributeError , KeyError , ValueError ) :
except ( TypeError , AttributeError ) :
except ( TypeError , ValueError , UnicodeDecodeError ) :
except ( TypeError , ValueError ) :
except ( TypeError , VariableDoesNotExist ) :
except ( ValueError , InvalidOperation , TypeError , UnicodeEncodeError ) :
except ( ValueError , KeyError ) :
except ( ValueError , OverflowError , InvalidOperation ) :
except ( ValueError , self . queryset . model . DoesNotExist ) :
except ( ValueError , TypeError , OverflowError ) :
except ( ValueError , TypeError , ValidationError ) :
except ( ValueError , TypeError ) :
except ( ValueError , TypeError ) :
except ( ValueError , TypeError ) :
except ( ValueError , TypeError ) :
except ( ValueError , TypeError ) :
except ( ValueError , TypeError ) :
except AmbiguityError :
except AmbiguityError :
except AppRegistryNotReady :
except AttributeError :
except AttributeError :
except AttributeError :
except AttributeError :
except AttributeError :
except base . DeserializationError :
except CommandError :
except DatabaseError :
except DatabaseError as e :
except DecimalException :
except Exception :
except Exception :
except Exception :
except Exception :
except Exception :
except Exception :
except Exception :
except Exception as e :
except Exception as e :
except Exception as e :
except Exception as e :
except GeneratorExit :
except GeneratorExit :
except HTMLParseError :
except http . Http404 as e :
except http_cookies . CookieError :
except http_cookies . CookieError :
except http_cookies . CookieError :
except ImportError :
except ImportError :
except ImportError :
except ImportError :
except ImportError :
except ImportError :
except ImportError as e :
except ImportError as e :
except ImportError as e :
except ImportError as exc :
except ImproperlyConfigured :
except ImproperlyConfigured as exc :
except IndexError :
except IndexError :
except IndexError :
except InputStreamExhausted :
except InvalidOperation :
except InvalidOperation :
except InvalidTemplateLibrary as e :
except IOError :
except IOError :
except IOError as e :
except IOError as e :
except IOError as e :
except KeyboardInterrupt :
except KeyError :
except KeyError :
except KeyError :
except KeyError :
except KeyError :
except KeyError :
except KeyError :
except KeyError :
except KeyError as key :
except LookupError :
except LookupError :
except LookupError :
except MiddlewareNotUsed :
except Model . DoesNotExist :
except MultiPartParserError :
except NameError :
except NoReverseMatch :
except NoReverseMatch :
except NotImplementedError :
except NotImplementedError :
except OSError :
except OSError :
except OSError as e :
except OSError as e :
except OSError as e :
except OSError as e :
except OSError as e :
except OSError as e :
except OSError as err :
except OverflowError :
except PermissionDenied :
except pickle . PickleError :
except re . error as e :
except Resolver404 :
except Resolver404 as e :
except self . LibraryValueNotFoundException :
except serializers . SerializerDoesNotExist :
except signing . BadSignature :
except SkipFile :
except smtplib . SMTPException :
except socket . error as e :
except StandardError as e :
except StandardError as e :
except StandardError as e :
except StandardError as e :
except StandardError as e :
except StopFutureHandlers :
except StopIteration :
except StopUpload as e :
except SuspiciousOperation as e :
except SystemExit :
except TemplateDoesNotExist :
except TemplateDoesNotExist :
except TemplateDoesNotExist as e :
except TemplateSyntaxError as e :
except TemplateSyntaxError as e :
except TypeError :
except TypeError as te :
except UnicodeDecodeError :
except UnicodeDecodeError :
except UnicodeDecodeError :
except UnicodeDecodeError as e :
except UnicodeEncodeError :
except UnicodeEncodeError :
except UnicodeError :
except UnicodeError :
except UnicodeError :
except UnicodeError as e :
except ValidationError :
except ValidationError :
except ValidationError as e :
except ValidationError as e :
except ValidationError as e :
except ValidationError as e :
except ValueError :
except ValueError :
except ValueError :
except VariableDoesNotExist :
except VariableDoesNotExist :
except:
except:
exclude . append ( f . name )
exclude . append ( name )
exclude = [ ]
exclude = form . _get_validation_exclusions ( )
exclude = options . get ( 'exclude' )
exclude = options . get ( 'exclude' )
exclude = self . _get_validation_exclusions ( )
excluded_apps . add ( app_config )
excluded_apps = set ( )
excluded_models . add ( model )
excluded_models = set ( )
excludes = options . get ( 'exclude' )
exctype , value = exc_info [ : 2 ]
exec ( """exec _code_ in _globs_, _locs_""" )
exec ( compile ( handle . read ( ) , pythonrc , 'exec' ) , imported_objects )
exec_ ( """def reraise(tp, value, tb=None):     raise tp, value, tb """ )
exec_ = getattr ( moves . builtins , "exec" )
executor . migrate ( targets , plan , fake = options . get ( "fake" , False ) )
executor = MigrationExecutor ( connection , self . migration_progress_callback )
executor = MigrationExecutor ( connection )
exhaust ( stream )
existing . remove ( name )
existing . sort ( )
existing = list ( root . manager . loggerDict )
existing_headers = set ( header . lower ( ) for header in vary_headers )
existing_headers = set ( header . lower ( ) for header in vary_headers )
exit(6)
exit(7)
exp = datetime . max
exp = datetime . utcfromtimestamp ( timeout )
exp = Decimal ( '1.0' ) / ( Decimal ( 10 ) ** abs ( p ) )
exp = Decimal ( 1 )
exp = exp . replace ( microsecond = 0 )
exp = pickle . load ( f )
exp = self . _expire_info . get ( key , - 1 )
expanded_template = path . expanduser ( template )
expanded_template = path . normpath ( expanded_template )
expires = None
expires = row [ 2 ]
expires = timezone . make_naive ( expires , timezone . utc )
expires = typecast_timestamp ( str ( expires ) )
expiry = self . get_backend_timeout ( timeout )
expression = parser . compile_filter ( var_name +  VARIABLE_ATTRIBUTE_SEPARATOR +  bits [ 3 ] )
ext = base [ - 4 : ] + ext
ext = ext [ : 255 ]
ext = mimetypes . guess_extension ( content_type )
ext = self . splitext ( guessed_filename ) [ 1 ]
ext_list . extend ( ext . replace ( ' ' , '' ) . split ( ',' ) )
ext_list [ i ] = '.%s' % ext_list [ i ]
ext_list = [ ]
extend = complain
extend = getattr ( definition , 'extend' , True )
extension_map = {  '.tar' : TarArchive ,  '.tar.bz2' : TarArchive ,  '.tar.gz' : TarArchive ,  '.tgz' : TarArchive ,  '.tz2' : TarArchive ,  '.zip' : ZipArchive ,  }
extensions = options . get ( 'extensions' )
extensions = tuple (  handle_extensions ( options [ 'extensions' ] , ignored = ( ) ) )
extra , resolver = resolver . namespace_dict [ ns ]
extra_attrs = self . widget_attrs ( widget )
extra_classes . add ( self . form . error_css_class )
extra_classes . add ( self . form . required_css_class )
extra_classes = extra_classes . split ( )
extra_classes = set ( extra_classes or [ ] )
extra_context = token_kwargs ( remaining_bits , parser , support_legacy = True )
extra_files . extend ( map ( lambda x : x . strip ( ) , file . split ( ',' ) ) )
extra_files = [ ]
extra_params . update ( field_params )
extra_params . update ( params )
extra_params [ 'blank' ] = True
extra_params [ 'null' ] = True
extra_params [ 'primary_key' ] = True
extra_params [ 'unique' ] = True
extra_params = OrderedDict ( )
extracted . close ( )
extracted = self . _archive . extractfile ( member )
exts = extensions if extensions else [ 'html' , 'txt' ]
exts = extensions if extensions else [ 'js' ]
f . close ( )
f . close ( )
f . error_messages . setdefault ( 'incomplete' ,  self . error_messages [ 'incomplete' ] )
f . process ( self , self . domain )
f . required = False
f . save_form_data ( instance , cleaned_data [ f . name ] )
f . seek ( 0 )
f . write ( pickle . dumps ( expiry , - 1 ) )
f . write ( zlib . compress ( pickle . dumps ( value ) , - 1 ) )
f = os . path . join ( p , cmd )
f = os . path . join ( root , f )
f = os . path . join ( root , f )
f = s [ : end ]
f = super ( ImageField , self ) . to_python ( data )
factor -= 1
factor += 1
factor = 0
factory = c
factory = config [ '()' ]
factory = klass
fail_message = 'changed'
fail_message = 'created'
fd , tmp_path = tempfile . mkstemp ( dir = self . _dir )
fd = os . open ( full_path , flags , 0o666 )
fd = os . open ( new_file_name , ( os . O_WRONLY | os . O_CREAT | getattr ( os , 'O_BINARY' , 0 ) |  ( os . O_EXCL if not allow_overwrite else 0 ) ) )
fd = pyinotify . INotifyWrapper . create ( ) . inotify_init ( )
fd = sys . stdin
fext = f + ext
fg = colors . pop ( )
fh . write ( migration_string )
fh . write ( writer . as_string ( ) )
fh . write ( writer . as_string ( ) )
Field . __init__ ( self , required , widget , label , initial , help_text ,  * args , ** kwargs )
Field . creation_counter += 1
FIELD = "field"
field = f . name
field = field . rel . get_related_field ( )
field = Model . _meta . get_field ( field_name )
field = Model . _meta . get_field ( field_name )
field = self . fields [ fieldname ]
field = self . fields [ name ]
field_desc += '  # ' + ' ' . join ( comment_notes )
field_desc += ', '
field_desc += ', ' . join ( [  '%s=%s' % ( k , strip_prefix ( repr ( v ) ) )  for k , v in extra_params . items ( ) ] )
field_desc += ')'
field_desc = '%s = %s%s' % (  att_name ,   '' if '.' in field_type else 'models.' ,  field_type ,  )
field_dict = OrderedDict (  [ ( f , field_dict . get ( f ) ) for f in fields  if ( ( not exclude ) or ( exclude and f not in exclude ) ) and ( f not in ignored ) ]  )
field_dict = OrderedDict ( field_list )
field_list . append ( ( f . name , formfield ) )
field_list = [ ]
field_name = disposition [ 'name' ] . strip ( )
field_name = field_node . getAttribute ( "name" )
field_name = force_text ( field_name , encoding , errors = 'replace' )
field_notes . append (  'max_digits and decimal_places have been guessed, as this '  'database handles decimal fields as float' )
field_notes . append ( 'Field name made lowercase.' )
field_notes . append ( 'Field renamed because it was a Python reserved word.' )
field_notes . append ( 'Field renamed because of name conflict.' )
field_notes . append ( 'Field renamed to remove unsuitable characters.' )
field_notes . append ( 'This field type is a guess.' )
field_notes . append ( "Field renamed because it contained more than one '_' in a row." )
field_notes . append ( "Field renamed because it ended with '_'." )
field_notes . append ( "Field renamed because it started with '_'." )
field_notes . append ( "Field renamed because it wasn't a valid Python identifier." )
field_notes = [ ]
field_output . append ( "%sNULL" % ( "NOT " if not f . null else "" ) )
field_output . append ( "PRIMARY KEY" )
field_output . append ( "UNIQUE" )
field_output = [ qn ( f . name ) , f . db_type ( connection = connection ) ]
field_params . update ( new_params )
field_params [ 'db_column' ] = col_name
field_params [ 'decimal_places' ] = row [ 5 ]
field_params [ 'decimal_places' ] = row [ 5 ] if row [ 5 ] is not None else 5
field_params [ 'max_digits' ] = row [ 4 ]
field_params [ 'max_digits' ] = row [ 4 ] if row [ 4 ] is not None else 10
field_params [ 'max_length' ] = int ( row [ 3 ] )
field_params = { }
field_params = OrderedDict ( )
field_type , field_params , field_notes = self . get_field_type ( connection , table_name , row )
field_type , new_params = field_type
field_type += '('
field_type = 'ForeignKey(%s' % rel_to
field_type = 'NullBooleanField('
field_type = 'TextField'
field_type = "ForeignKey('%s'" % rel_to
field_type = connection . introspection . get_field_type ( row [ 1 ] , row )
field_value = [ getInnerText ( k ) . strip ( ) for k in keys ]
field_value = getInnerText ( node ) . strip ( )
field_value = None
field_value = self . cleaned_data . get ( field , None )
field_value = smart_text ( field_value , options . get ( "encoding" , settings . DEFAULT_CHARSET ) , strings_only = True )
field_value = value [ i ]
fields . sort ( key = lambda x : x [ 1 ] . creation_counter )
fields . update ( new_class . declared_fields )
fields = (   models . CharField ( name = 'cache_key' , max_length = 255 , unique = True , primary_key = True ) ,  models . TextField ( name = 'value' ) ,  models . DateTimeField ( name = 'expires' , db_index = True ) ,  )
fields = (  DateField ( input_formats = input_date_formats ,  error_messages = { 'invalid' : errors [ 'invalid_date' ] } ,  localize = localize ) ,  TimeField ( input_formats = input_time_formats ,  error_messages = { 'invalid' : errors [ 'invalid_time' ] } ,  localize = localize ) ,  )
fields = [ ( field_name , attrs . pop ( field_name ) ) for field_name , obj in list ( six . iteritems ( attrs ) ) if isinstance ( obj , Field ) ]
fields = fields_for_model ( opts . model , opts . fields , opts . exclude ,  opts . widgets , formfield_callback ,  opts . localized_fields , opts . labels ,  opts . help_texts , opts . error_messages )
fields = list ( six . iteritems ( base . base_fields ) ) + fields
fields = list ( six . iteritems ( base . declared_fields ) ) + fields
fields = new_class . declared_fields
file . close ( )
file . seek ( 0 )
file . seek ( file_pos )
FILE = "file"
file = BytesIO ( data . read ( ) )
file = BytesIO ( data [ 'content' ] )
file = data . temporary_file_path ( )
file = file_or_path
file = open ( file_or_path , 'rb' )
file = tempfile . NamedTemporaryFile ( suffix = '.upload' ,  dir = settings . FILE_UPLOAD_TEMP_DIR )
file = tempfile . NamedTemporaryFile ( suffix = '.upload' )
file_ , _ , _ = imp . find_module ( module_name , [ entry ] )
file_ . close ( )
file_field_list . append ( f )
file_field_list = [ ]
FILE_INPUT_CONTRADICTION = object ( )
file_list = self . find_files ( "." )
FILE_MODIFIED = 1
file_move_safe ( content . temporary_file_path ( ) , full_path )
file_move_safe ( tmp_path , fname , allow_overwrite = True )
file_name = data . name
file_name = disposition . get ( 'filename' )
file_name = force_text ( file_name , encoding , errors = 'replace' )
file_name = self . IE_sanitize ( unescape_entities ( file_name ) )
file_obj = handler . file_complete ( counters [ i ] )
file_path = os . path . normpath ( os . path . join ( dirpath , filename ) )
file_pos = file . tell ( )
file_root , file_ext = os . path . splitext ( file_name )
file_size = data . size
filelist = _cached_filenames + new_filenames + _error_files
filelist = [ os . path . join ( self . _dir , fname ) for fname  in glob . glob1 ( self . _dir , '*%s' % self . cache_suffix ) ]
filelist = new_filenames
filelist = random . sample ( filelist ,  int ( num_entries / self . _cull_frequency ) )
filelist = self . _list_cache_files ( )
filemsg = ''
filemsg = 'file %s, ' % origin
filename , display_url = cleanup_url ( url )
filename . encode ( 'ascii' )
filename = ( 'utf-8' , '' , filename )
filename = ev . filename
filename = file
filename = file . name
filename = filename . encode ( 'utf-8' )
filename = filename [ : - 1 ]
filename = filename [ : - 9 ] + ".py"
filename = os . path . basename ( path )
filename = os . path . basename ( path )
filename = os . path . join ( to_path , name )
filename = os . path . join ( to_path , name )
filename = tmp . split ( '/' ) [ - 1 ]
filename = traceback . extract_tb ( tb ) [ - 1 ] [ 0 ]
filenames . append ( filename )
filenames = [ ]
fileno = property ( lambda self : self . file . fileno )
filepath = os . path . abspath ( filepath )
filepath = parser . compile_filter ( bits [ 1 ] )
filepath = self . filepath . resolve ( context )
files . append ( entry )
FILES = property ( _get_files )
filesize_number_format = lambda value : formats . number_format ( round ( value , 1 ) , 1 )
fill_to = 7
fill_to = 8
filter = get_exception_reporter_filter ( request )
FILTER_ARGUMENT_SEPARATOR = ':'
filter_expr = parser . compile_filter ( "var|%s" % ( rest ) )
filter_expression = self . compile_filter ( token . contents )
filter_func . _filter_name = name
filter_func = parser . find_filter ( filter_name )
filter_name = getattr ( func , '_filter_name' , None )
filter_name = match . group ( "filter_name" )
filter_raw_string = r""" ^(?P<constant>%(constant)s)| ^(?P<var>[%(var_chars)s]+|%(num)s)|  (?:\s*%(filter_sep)s\s*      (?P<filter_name>\w+)          (?:%(arg_sep)s              (?:               (?P<constant_arg>%(constant)s)|               (?P<var_arg>[%(var_chars)s]+|%(num)s)              )          )?  )""" % {  'constant' : constant_string ,  'num' : r'[-+\.]?\d[\d\.e]*' ,  'var_chars' : "\w\." ,  'filter_sep' : re . escape ( FILTER_SEPARATOR ) ,  'arg_sep' : re . escape ( FILTER_ARGUMENT_SEPARATOR ) ,  }
filter_re = re . compile ( filter_raw_string , re . UNICODE | re . VERBOSE )
FILTER_SEPARATOR = '|'
filterer . addFilter ( self . config [ 'filters' ] [ f ] )
filters . append ( ( filter_func , args ) )
filters [ name ] = self . configure_filter ( filters [ name ] )
filters = [ ]
filters = config . get ( 'filters' , EMPTY_DICT )
filters = config . get ( 'filters' , None )
filters = config . pop ( 'filters' , None )
final_attrs [ 'checked' ] = 'checked'
final_attrs [ 'value' ] = force_text ( self . _format_value ( value ) )
final_attrs [ 'value' ] = force_text ( value )
final_attrs = dict ( final_attrs , id = '%s_%s' % ( id_ , i ) )
final_attrs = dict ( self . attrs , type = self . input_type , name = self . name , value = self . choice_value )
final_attrs = self . build_attrs ( attrs , name = name )
final_attrs = self . build_attrs ( attrs , name = name )
final_attrs = self . build_attrs ( attrs , type = 'checkbox' , name = name )
final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name )
final_attrs = self . build_attrs ( attrs , type = self . input_type , name = name )
final_attrs = self . build_attrs ( attrs )
final_output . append ( '-- The following references should be added but depend on non-existent tables:' )
final_output . extend ( alter_sql )
final_output . extend ( connection . creation . sql_for_pending_references ( model , style , pending_references ) )
final_output . extend ( connection . creation . sql_for_pending_references ( refto , style , pending_references ) )
final_output . extend ( output )
final_output = [ ]
finally :
finally :
finally :
finally :
finally :
finally :
finder = hook ( entry )
finder = sys . path_importer_cache [ entry ]
first , lang , priority = pieces [ i : i + 3 ]
first = second = None
first_item , second_item = list_
fixture . close ( )
fixture = open_method ( fixture_file , mode )
fixture_dirs = [ os . path . dirname ( fixture_name ) ]
fixture_dirs = [ os . path . join ( dir_ , os . path . dirname ( fixture_name ) )  for dir_ in fixture_dirs ]
fixture_dirs = self . fixture_dirs
fixture_files . extend ( fixture_files_in_dir )
fixture_files = [ ]
fixture_files_in_dir . append ( ( candidate , fixture_dir , fixture_name ) )
fixture_files_in_dir = [ ]
fixture_name , ser_fmt , cmp_fmt = self . parse_name ( fixture_label )
fixture_name = os . path . basename ( fixture_name )
fixture_name = os . path . basename ( fixture_name )
fk = _get_foreign_key ( parent_model , model , fk_name = fk_name )
fk = fks_to_parent [ 0 ]
fks_to_parent = [  f for f in opts . fields  if isinstance ( f , ForeignKey )  and ( f . rel . to == parent_model  or f . rel . to in parent_model . _meta . get_parent_list ( ) )  ]
fks_to_parent = [ f for f in opts . fields if f . name == fk_name ]
flags = ( os . O_WRONLY | os . O_CREAT | os . O_EXCL |  getattr ( os , 'O_BINARY' , 0 ) )
flags = 0
flat . update ( d )
flat = { }
flup_module += '_fork'
flup_module = 'server.' + options [ 'protocol' ]
flush = property ( lambda self : self . file . flush )
fmt = config . get ( 'format' , None )
fmt = get_format ( 'DATE_FORMAT' )
fn ( * args , ** kwargs )
fn = code_changed
fn = inotify_code_changed
fname = "%s-%s.log" % ( timestamp , abs ( id ( self ) ) )
fname = self . _key_to_file ( key , version )
for _ , nodelist in self . conditions_nodelists :
for __ in iterator :
for __ in xrange ( fill_to - sep ) :
for ( field_name , field_value ) in six . iteritems ( d [ "fields" ] ) :
for ( k , v ) in kwargs . items ( ) :
for ( k , v ) in type_ . __dict__ . items ( ) :
for a in bytearray(shellcode):
for a in bytearray(z):
for accept_lang , unused in parse_accept_lang_header ( accept ) :
for accessor_name , object_list in self . m2m_data . items ( ) :
for alternative in self . alternatives :
for app in sorted ( commands_dict . keys ( ) ) :
for app_config , model_list in app_list :
for app_config in app_configs :
for app_config in app_configs :
for app_config in apps . get_app_configs ( ) :
for app_config in apps . get_app_configs ( ) :
for app_config in apps . get_app_configs ( ) :
for app_config in apps . get_app_configs ( ) :
for app_config in apps . get_app_configs ( ) :
for app_config in apps . get_app_configs ( ) :
for app_config in apps . get_app_configs ( ) :
for app_config in reversed ( list ( apps . get_app_configs ( ) ) ) :
for app_config in reversed ( list ( apps . get_app_configs ( ) ) ) :
for app_dir in app_dirs :
for app_label , app_migrations in changes . items ( ) :
for app_label , migration_names in conflicts . items ( ) :
for app_label in app_labels :
for app_label in bad_app_labels :
for app_name , model_list in manifest . items ( ) :
for app_name , model_list in manifest . items ( ) :
for app_name , model_list in manifest . items ( ) :
for app_name , namespace_list in pattern . app_dict . items ( ) :
for app_name in app_names :
for app_name in app_names :
for arg in args :
for arg in argv [ 2 : ] :
for arg in list ( args ) + list ( six . itervalues ( kwargs ) ) :
for attachment in self . attachments :
for attr , value in base . __dict__ . items ( ) :
for attr , value in list ( attrs . items ( ) ) :
for attr in _moved_attributes :
for attr in _urllib_error_moved_attributes :
for attr in _urllib_parse_moved_attributes :
for attr in _urllib_request_moved_attributes :
for attr in _urllib_response_moved_attributes :
for attr in _urllib_robotparser_moved_attributes :
for attr in ( 'expects_localtime' , 'is_safe' , 'needs_autoescape' ) :
for attr in self . child_nodelists :
for attr in self . rendering_attrs :
for b in bytearray(shellcode):
for base in bases [ : : - 1 ] :
for base in inspect . getmro ( new_class ) :
for base in reversed ( new_class . __mro__ ) :
for basedir in basedirs :
for bit in bits :
for bit in self . lookups :
for byte in bytearray(sc)[16:]:
for byte in bytearray(sh)[12:]:
for c in response . cookies . values ( ) :
for c in reversed ( self . __class__ . __mro__ ) :
for cache in caches . all ( ) :
for cache_alias in settings . CACHES :
for candidate in ( ( d not in models or d in model_list ) for d in deps ) :
for candidate in glob . iglob ( os . path . join ( fixture_dir , fixture_name + '*' ) ) :
for cat in item [ 'categories' ] :
for cat in item [ 'categories' ] :
for cat in self . feed [ 'categories' ] :
for char in key :
for char in self . add_truncation_text ( '' , truncate ) :
for character in name :
for check in checks :
for child in node . childNodes :
for choice in self . field . choice_cache :
for choice in value :
for chunk in content . chunks ( ) :
for chunk in field_stream :
for chunk in self . chunks ( ) :
for closable in self . _closable_objects :
for cmatch in cmatches :
for cnt , digit in enumerate ( int_part [ : : - 1 ] ) :
for code in ( lang_code , generic_lang_code ) :
for condition , nodelist in self . conditions_nodelists :
for d in object_list :
for d in reversed ( self . dicts ) :
for d in self . dicts :
for d in self . dicts [ - 1 ] :
for date_check in all_date_checks :
for date_key in date_keys :
for db in connections . all ( ) :
for dict_ in self . dicts :
for digit in str ( number ) :
for dirname in dirnames [ : ] :
for dirname in dirs [ : ] :
for dirpath , dirnames , filenames in os . walk ( ldir ) :
for dirpath , dirnames , filenames in os . walk ( root , topdown = True , followlinks = self . symlinks ) :
for dirpath , dirnames , locale_filenames in os . walk ( basedir ) :
for domain in domains :
for elt in source :
for entry in os . listdir ( path ) :
for entry in package_path :
for error in self . as_data ( ) :
for error in self . error_list :
for error in self . errors . as_data ( ) [ field ] :
for event , node in self . event_stream :
for exclude in excludes :
for ext in extensions :
for ext in pathext :
for ext in pathext :
for f in chain . from_iterable ( l [ 1 ] for l in self . _files . lists ( ) ) :
for f in dirs :
for f in fields :
for f in file_field_list :
for f in file_list :
for f in files :
for f in filters :
for f in opts . concrete_fields + opts . virtual_fields + opts . many_to_many :
for f in opts . fields :
for f in opts . local_fields :
for f in opts . many_to_many + opts . virtual_fields :
for f in post_sql_fields :
for f in self . instance . _meta . fields :
for f in sorted ( opts . concrete_fields + sortable_virtual_fields + opts . many_to_many ) :
for f in sorted ( os . listdir ( self . path ) ) :
for field , error_list in error . items ( ) :
for field , error_list in self . error_dict . items ( ) :
for field , errors in self . error_dict . items ( ) :
for field , errors in self . items ( ) :
for field , initial , data in zip ( self . fields , initial , data ) :
for field , messages in errors . error_dict . items ( ) :
for field , messages in message . items ( ) :
for field in _parse_date_fmt ( ) :
for field in concrete_model . _meta . local_fields :
for field in concrete_model . _meta . many_to_many :
for field in model . _meta . fields :
for field in model . _meta . many_to_many :
for field in self . fields :
for field in self . fields . values ( ) :
for field in unique_check :
for field_name in self . fields :
for field_node in node . getElementsByTagName ( "field" ) :
for file in options [ 'files' ] :
for filename in filelist :
for filename in filenames :
for filename in files :
for filename in gen_filenames ( ) :
for filename in locale_filenames :
for filepath in self . get_template_sources ( template_name , template_dirs ) :
for finder in sys . meta_path :
for first_select in _parse_date_fmt ( ) :
for fixture_dir in fixture_dirs :
for fixture_file , fixture_dir , fixture_name in self . find_fixtures ( fixture_label ) :
for fixture_label in fixture_labels :
for fmatch in constant_re . findall ( t . contents ) :
for fname in filelist :
for fname in self . _list_cache_files ( ) :
for form in self . extra_forms :
for form in self . initial_forms :
for form in self . saved_forms :
for form in valid_forms :
for form in valid_forms :
for format in BUILTIN_SERIALIZERS :
for format in self . input_formats :
for format in settings . SERIALIZATION_MODULES :
for formset in formsets :
for frag in name :
for func , args in self . filters :
for func , unused in filter_expr . filters :
for func in self . response_fixes :
for h in handlers :
for h in logger . handlers [ : ] :
for handler in handlers :
for handler in self . _upload_handlers :
for header in cc_delim_re . split ( response [ 'Vary' ] ) :
for header in headerlist :
for hextet in ip_str . split ( ':' ) :
for hextet in new_ip :
for hook in sys . path_hooks :
for i , ( dirpath , f ) in enumerate ( locations ) :
for i , ( seconds , name ) in enumerate ( chunks ) :
for i , arg in enumerate ( args ) :
for i , char in enumerate ( text ) :
for i , choice in enumerate ( self . choices ) :
for i , ext in enumerate ( ext_list ) :
for i , field in enumerate ( self . fields ) :
for i , handler in enumerate ( handlers ) :
for i , handler in enumerate ( self . _upload_handlers ) :
for i , item in enumerate ( values ) :
for i , line in enumerate ( lines ) :
for i , line in enumerate ( table_output ) :
for i , piece in enumerate ( re_formatchars . split ( force_text ( formatstr ) ) ) :
for i , row in enumerate ( connection . introspection . get_table_description ( cursor , table_name ) ) :
for i , v in enumerate ( value ) :
for i in bytearray(sc)[8:]:
for i in bytearray(shellcode) :
for i in random.sample(range(1, 128), 96):
for i in random.sample(range(32, 128), 96):
for i in range ( 0 , self . total_form_count ( ) ) :
for i in range(1, repeat+1):
for i in range(16, len(shellcode), 2):
for i in range(2, 10):
for i in range(3, val1):
for i in range(8, len(sh), 4):
for ip in ( self . _ipython , self . _ipython_pre_100 , self . _ipython_pre_011 ) :
for iso_input in ISO_INPUT_FORMATS . get ( format_type , ( ) ) :
for issues , group_name in sorted_issues :
for item , args in zip ( result , result_args ) :
for item in elt :
for item in self . items :
for item in sequence :
for item in six . iteritems ( dict_ ) :
for item in sorted_items :
for item in values :
for item_type , meta_data , field_stream in Parser ( stream , self . _boundary ) :
for j in bytearray(sc)[1:]:
for j in bytearray(sh)[2:]:
for j in range(1, val2):
for j in range(4, 12):
for k , list_ in self . lists ( ) :
for k , v in data . items ( ) :
for k , v in defaults . items ( ) :
for k , v in ret . items ( ) :
for k , v in self . _iteritems ( ) :
for k , v in self . choices :
for k , v in six . iteritems ( dict_ ) :
for k , v in six . iteritems ( kwargs ) :
for k in doomed :
for k in keys :
for k2 , v2 in v :
for key , op in OPERATORS . items ( ) :
for key , value in data :
for key , value in data . items ( ) :
for key , value in data . items ( ) :
for key , value in dict . items ( self ) :
for key , value in list ( attrs . items ( ) ) :
for key , value in other_dict . items ( ) :
for key , value in parse_qsl ( query_string or '' ,  keep_blank_values = True ,  encoding = encoding ) :
for key , value in parse_qsl ( query_string or '' ,  keep_blank_values = True ) :
for key , value in six . iteritems ( kwargs ) :
for key , value in six . iterlists ( self ) :
for key , value in six . iterlists ( self ) :
for key , value_list in other_dict . lists ( ) :
for key in c . keys ( ) :
for key in keys :
for key in self :
for key in self . bad_cookies :
for key in self . keyOrder :
for key in sorted ( user_settings ) :
for key_value in natural :
for key_value in related :
for label in app_labels :
for label in labels :
for ldir in dirs :
for level in zip ( * [ m . ancestry for m in merge_migrations ] ) :
for lib in builtins :
for line in chunk_buffer :
for line in content . split ( "\n" ) :
for line in header . split ( b'\r\n' ) :
for line in msgs . split ( '\n' ) :
for line in self . handle_inspection ( options ) :
for line in sequence_sql :
for line in text . splitlines ( True ) :
for lineno , line in enumerate ( content . splitlines ( True ) ) :
for loader in self . _loaders :
for loader in self . loaders :
for loader in template_source_loaders :
for loader_name in settings . TEMPLATE_LOADERS :
for loc in locales :
for locale in locales :
for localedir in reversed ( settings . LOCALE_PATHS ) :
for location in format_locations :
for log in existing :
for lookup , arg in args :
for match in matches :
for match in regexes [ state ] . finditer ( text , start ) :
for match in tag_re . finditer ( self . template_string ) :
for matches , pat , defaults in pattern . reverse_dict . getlist ( name ) :
for medium , paths in data . items ( ) :
for medium in extend :
for member in members :
for message in email_messages :
for message in email_messages :
for message in message :
for message in messages :
for meta_line in self . get_meta ( table_name ) :
for middleware_method in self . _exception_middleware :
for middleware_method in self . _request_middleware :
for middleware_method in self . _response_middleware :
for middleware_method in self . _template_response_middleware :
for middleware_method in self . _view_middleware :
for middleware_path in settings . MIDDLEWARE_CLASSES :
for migration in app_migrations :
for migration in merge_migrations :
for migration in merge_migrations :
for migration in migrations_to_squash :
for migration in migrations_to_squash :
for migration_name in migration_names :
for model in app_models :
for model in model_list :
for model in model_list :
for model in not_installed_models :
for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :
for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :
for model in router . get_migratable_models ( app_config , connection . alias , include_auto_created = True ) :
for model in sort_dependencies ( app_list . items ( ) ) :
for module in get_format_modules ( lang ) :
for module in templatetags_modules :
for module_to_search in args :
for name , app in six . iteritems ( get_commands ( ) ) :
for name , block in six . iteritems ( blocks ) :
for name , field in self . fields . items ( ) :
for name , field in self . fields . items ( ) :
for name , field in self . fields . items ( ) :
for name , tok in lexer . lex ( js ) :
for name , value in props . items ( ) :
for name , value in self . extra_headers . items ( ) :
for name in bits [ 1 : - 2 ] :
for name in dir ( models . signals ) :
for name in filters :
for name in formatters :
for name in handlers :
for name in loggers :
for name in MEDIA_TYPES :
for name in namelist :
for name in pattern . reverse_dict :
for name in self . fields :
for name in sorted ( commands_dict [ app ] ) :
for name in sorted ( handlers ) :
for namespace , ( prefix , sub_pattern ) in pattern . namespace_dict . items ( ) :
for node in compiled_parent . nodelist :
for node in graph . leaf_nodes ( app_name ) :
for node in nodelist :
for node in self :
for node in self . nodelist :
for node in self . nodelist_empty :
for node in self . nodelist_loop :
for node_app , node_name in migration . branch :
for o in opts :
for o in range(256):
for obj in objects :
for obj in PythonDeserializer ( objects , ** options ) :
for obj in PythonDeserializer ( yaml . load ( stream , Loader = SafeLoader ) , ** options ) :
for obj in queryset :
for obj in queryset . iterator ( ) :
for obj in self . queryset . all ( ) :
for opening , closing in WRAPPING_PUNCTUATION :
for operation in migration . merged_operations :
for operation in migration . operations :
for opname , opfunc in convert [ root ] :
for opt in [ 'fields' , 'exclude' , 'localized_fields' ] :
for opt in self . option_list :
for option in option_label :
for option in options :
for option_value , option_label in chain ( self . choices , choices ) :
for p in parts [ 1 : ] :
for p in path :
for p in plist :
for part in parts :
for part in plural :
for part in singular :
for part in singular :
for path in all_locale_paths ( ) :
for path in collect :
for path in data :
for path in format_module_path :
for path in gen_filenames ( only_new = True ) :
for path in paths :
for path in self . locale_paths :
for path_to_remove in self . paths_to_remove :
for pattern in allowed_hosts :
for pattern in reversed ( self . url_patterns ) :
for pattern in self . url_patterns :
for pk in value :
for plan_node in graph . forwards_plan ( node ) :
for pos , elt in enumerate ( source ) :
for possibility , pattern , defaults in possibilities :
for post_callback in self . _post_render_callbacks :
for potfile in potfiles :
for processor in get_standard_processors ( ) + processors :
for program in programs :
for punctuation in TRAILING_PUNCTUATION :
for pythonrc in ( os . environ . get ( "PYTHONSTARTUP" ) , '~/.pythonrc.py' ) :
for receiver , _ , _ in receivers :
for reference , receivers in obj . unresolved_references . items ( ) :
for refto , refs in references . items ( ) :
for refto , refs in references . items ( ) :
for regex in RFC1123_DATE , RFC850_DATE , ASCTIME_DATE :
for relobj in getattr ( obj , field . name ) . iterator ( ) :
for renamed_method in cls . renamed_methods :
for replacement in set ( [  thousand_sep , unicodedata . normalize ( 'NFKD' , thousand_sep ) ] ) :
for result , params in possibility :
for resultclass in resultclasses :
for role in termcolors . PALETTES [ termcolors . NOCOLOR_PALETTE ] :
for root , dirs , files in os . walk ( template_dir ) :
for root , dirs , files in sorted ( os . walk ( self . path ) ) :
for root in settings . ALLOWED_INCLUDE_ROOTS :
for shell in available_shells :
for site in sites :
for site in sites1 :
for slots_var in slots :
for smigration in migrations_to_squash :
for sql in custom_sql :
for sql in index_sql :
for sql in sql_list :
for sql_file in sql_files :
for state , rules in states . items ( ) :
for statement in index_output :
for statement in sql :
for statement in sql_statements :
for sub_stream in boundarystream :
for sublist in second_item :
for subnode in node :
for subwidget in self . field . widget . subwidgets ( self . html_name , self . value ( ) , attrs ) :
for supported_code in _supported :
for t in Lexer ( src , origin ) . tokenize ( ) :
for t in type ( res ) . mro ( ) :
for table_name in connection . introspection . table_names ( cursor ) :
for tablename in tablenames :
for tag in open_tags :
for taglib in bits [ 1 : ] :
for template_dir in template_dirs :
for template_name in template_name_list :
for templatetag_module in templatetags_modules_candidates :
for tok in rules :
for type_ in reversed ( resultclass . mro ( ) ) :
for uclass , unique_check in all_unique_checks :
for v in self . validators :
for val in value :
for val in value :
for var in loopvars :
for var in self . vars :
for w in self . widgets :
for widget in self . get_renderer ( name , value , attrs , choices ) :
for widget in self . widgets :
for widget in self . widgets :
for x , y in zip ( val1 , val2 ) :
for x in arg . split ( ':' ) :
for x in bytearray(code):
for x in bytearray(decoded_shell):
for x in bytearray(decoded_shellcode):
for x in bytearray(encoded_shell):
for x in bytearray(sc):
for x in bytearray(sc2):
for x in bytearray(sh4) :
for x in bytearray(shellcode) :
for x in bytearray(shellcode):
for x in bytearray(y):
for y in bytearray(decoded_shellcode):
for y in bytearray(encoded_shellcode):
for y in bytearray(shellcode):
for z in bytearray(f):
for z in bytearray(shellcode):
force_str = force_text
force_unicode = force_text
foreground = dict ( ( color_names [ x ] , '3%s' % x ) for x in range ( 8 ) )
form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] )
form . _errors [ NON_FIELD_ERRORS ] = self . error_class ( [ self . get_form_error ( ) ] )
form . _meta . fields . append ( self . fk . name )
form . _meta . fields = list ( form . _meta . fields )
form . data [ form . add_prefix ( self . _pk_field . name ) ] = None
form . data [ form . add_prefix ( self . fk . name ) ] = None
form . fields [ DELETION_FIELD_NAME ] = BooleanField ( label = _ ( 'Delete' ) , required = False )
form . fields [ name ] = InlineForeignKeyField ( self . instance , ** kwargs )
form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( 'Order' ) , initial = index + 1 , required = False )
form . fields [ ORDERING_FIELD_NAME ] = IntegerField ( label = _ ( 'Order' ) , required = False )
form . fields [ self . _pk_field . name ] = ModelChoiceField ( qs , initial = pk_value , required = False , widget = widget )
form . save_m2m ( )
form . save_m2m ( )
form . save_m2m = save_m2m
form = ManagementForm ( auto_id = self . auto_id , prefix = self . prefix , initial = {  TOTAL_FORM_COUNT : self . total_form_count ( ) ,  INITIAL_FORM_COUNT : self . initial_form_count ( ) ,  MIN_NUM_FORM_COUNT : self . min_num ,  MAX_NUM_FORM_COUNT : self . max_num  } )
form = ManagementForm ( self . data , auto_id = self . auto_id , prefix = self . prefix )
form = modelform_factory ( model , form = form , fields = fields , exclude = exclude ,  formfield_callback = formfield_callback ,  widgets = widgets , localized_fields = localized_fields ,  labels = labels , help_texts = help_texts , error_messages = error_messages )
form = self . form (  auto_id = self . auto_id ,  prefix = self . add_prefix ( '__prefix__' ) ,  empty_permitted = True ,  )
form = self . form ( ** defaults )
form = self . forms [ i ]
form = super ( BaseInlineFormSet , self ) . _construct_form ( i , ** kwargs )
form_class_attrs = {  'Meta' : Meta ,  'formfield_callback' : formfield_callback  }
form_field = self . fields [ field ]
format = color_settings . get ( role , { } )
format = force_str ( default or get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ] )
format = force_str ( default or get_format ( 'DATETIME_INPUT_FORMATS' ) [ 0 ] )
format = force_str ( default or get_format ( 'TIME_INPUT_FORMATS' ) [ 0 ] )
format_0x += '0'
format_0x += '0xxx'
format_0x += "," + encoded_instruction_in_hex
format_0x += "," + encoded_instruction_in_hex
format_0x += encoded+","
format_0x = ""
format_key = 'DATE_INPUT_FORMATS'
format_key = 'DATETIME_INPUT_FORMATS'
format_key = 'TIME_INPUT_FORMATS'
format_locations . append ( 'django.conf.locale.%s' )
format_locations . append ( path + '.%s' )
format_locations = [ ]
format_module_path = [ format_module_path ]
format_module_path = settings . FORMAT_MODULE_PATH
format_slash_x = ""
format_slash_x = ""
format_type = force_str ( format_type )
formatted += '0x'
formatted = ""
formatted = "\n" . join ( sorted ( formatted ) )
formatted = (  color_style ( ) . ERROR ( force_str ( e ) )  if e . is_serious ( )  else color_style ( ) . WARNING ( force_str ( e ) )  for e in issues )
formatted_subject = subject . replace ( '\n' , '\\n' ) . replace ( '\r' , '\\r' )
formatter = config . pop ( 'formatter' , None )
formatter = self . config [ 'formatters' ] [ formatter ]
formatters [ name ] = self . configure_formatter (  formatters [ name ] )
formatters = config . get ( 'formatters' , EMPTY_DICT )
formfield . queryset = formfield . queryset . complex_filter ( limit_choices_to )
formfield = f . formfield ( ** kwargs )
formfield = formfield_callback ( f , ** kwargs )
formfield = self . fields [ field_name ]
formfield_callback = attrs . pop ( 'formfield_callback' , None )
forms = ' ' . join ( form . as_p ( ) for form in self )
forms = ' ' . join ( form . as_table ( ) for form in self )
forms = ' ' . join ( form . as_ul ( ) for form in self )
forms = [ self . _construct_form ( i ) for i in xrange ( self . total_form_count ( ) ) ]
forms_to_delete = self . deleted_forms
forms_valid &= form . is_valid ( )
forms_valid = True
FormSet . fk = fk
FormSet . model = model
FormSet = formset_factory ( form , formset , extra = extra , min_num = min_num , max_num = max_num ,  can_order = can_order , can_delete = can_delete ,  validate_min = validate_min , validate_max = validate_max )
FormSet = modelformset_factory ( model , ** kwargs )
found = False
found = getattr ( found , frag )
found = self . importer ( used )
found = True
fp . write ( "%d\n" % os . getpid ( ) )
fp . write ( content )
fp . write ( data )
fp . write ( msgs )
fp . write ( msgs )
fp . write ( src_data )
fp = kwargs . pop ( "file" , sys . stdout )
fp = six . BytesIO ( )
fp = six . StringIO ( )
frame = sys . _getframe ( 1 )
from __future__ import absolute_import
from __future__ import absolute_import
from __future__ import unicode_literals
from __future__ import unicode_literals
from _systemrestart import SystemRestart
from . . import Warning , register , Tags
from . base import CommandError
from . html_parser import HTMLParser , HTMLParseError
from . import Error , Tags , register
from . import six
from . messages import ( CheckMessage ,  Debug , Info , Warning , Error , Critical ,  DEBUG , INFO , WARNING , ERROR , CRITICAL )
from . registry import register , run_checks , tag_exists , Tags
from argparse import ArgumentParser
from binascii import Error as BinasciiError
from collections import defaultdict
from collections import namedtuple
from collections import OrderedDict
from collections import UserList
from copy import copy
from ctypes . wintypes import BOOL , DWORD , HANDLE
from ctypes import ( sizeof , c_ulong , c_void_p , c_int64 ,  Structure , Union , POINTER , windll , byref )
from datetime import date as real_date , datetime as real_datetime
from datetime import datetime
from datetime import datetime , timedelta , tzinfo
from datetime import timedelta , tzinfo
from decimal import Decimal
from decimal import Decimal , DecimalException
from decimal import Decimal , InvalidOperation , Context , ROUND_HALF_UP
from django . apps import apps
from django . apps import apps
from django . conf . locale import LANG_INFO
from django . conf import settings
from django . conf import settings
from django . conf import settings
from django . conf import settings
from django . conf import settings
from django . conf import settings
from django . conf import settings
from django . conf import settings
from django . conf import settings , global_settings
from django . conf import urls
from django . contrib . auth import get_user_model
from django . core . cache . backends . base import (  InvalidCacheBackendError , CacheKeyWarning , BaseCache )
from django . core . cache . backends . base import BaseCache , DEFAULT_TIMEOUT
from django . core . cache . backends . db import BaseDatabaseCache
from django . core . cache import caches
from django . core . cache import caches
from django . core . checks . registry import registry
from django . core . exceptions import (  ImproperlyConfigured , ValidationError , NON_FIELD_ERRORS , FieldError )
from django . core . exceptions import AppRegistryNotReady
from django . core . exceptions import DisallowedHost , ImproperlyConfigured
from django . core . exceptions import DisallowedRedirect
from django . core . exceptions import ImproperlyConfigured
from django . core . exceptions import ImproperlyConfigured , DjangoRuntimeWarning
from django . core . exceptions import ImproperlyConfigured , ViewDoesNotExist
from django . core . exceptions import MiddlewareNotUsed , PermissionDenied , SuspiciousOperation
from django . core . exceptions import SuspiciousFileOperation
from django . core . exceptions import SuspiciousMultipartForm
from django . core . exceptions import ValidationError
from django . core . exceptions import ValidationError , NON_FIELD_ERRORS
from django . core . files . base import File
from django . core . files . move import file_move_safe
from django . core . files . uploadedfile import TemporaryUploadedFile , InMemoryUploadedFile
from django . core . files . uploadhandler import StopUpload , SkipFile , StopFutureHandlers
from django . core . files . utils import FileProxyMixin
from django . core . files import File
from django . core . files import locks
from django . core . files import locks , File
from django . core . files import temp as tempfile
from django . core . files import uploadhandler
from django . core . handlers . wsgi import WSGIHandler
from django . core . handlers import base
from django . core . mail . backends . base import BaseEmailBackend
from django . core . mail . backends . console import EmailBackend as ConsoleEmailBackend
from django . core . mail . message import (  EmailMessage , EmailMultiAlternatives ,  SafeMIMEText , SafeMIMEMultipart ,  DEFAULT_ATTACHMENT_MIME_TYPE , make_msgid ,  BadHeaderError , forbid_multi_line_headers )
from django . core . mail . message import sanitize_address
from django . core . mail . utils import CachedDnsName , DNS_NAME
from django . core . mail . utils import DNS_NAME
from django . core . mail import get_connection
from django . core . management . base import ( BaseCommand , CommandError ,  CommandParser , handle_default_options )
from django . core . management . base import AppCommand
from django . core . management . base import BaseCommand
from django . core . management . base import BaseCommand , CommandError
from django . core . management . base import CommandError
from django . core . management . base import CommandError , BaseCommand
from django . core . management . color import color_style
from django . core . management . color import color_style , no_style
from django . core . management . color import no_style
from django . core . management . commands . check import Command as CheckCommand
from django . core . management . sql import check_for_migrations
from django . core . management . sql import custom_sql_for_model , emit_post_migrate_signal , emit_pre_migrate_signal
from django . core . management . sql import sql_all
from django . core . management . sql import sql_create
from django . core . management . sql import sql_custom
from django . core . management . sql import sql_delete
from django . core . management . sql import sql_destroy_indexes
from django . core . management . sql import sql_flush
from django . core . management . sql import sql_flush , emit_post_migrate_signal
from django . core . management . sql import sql_indexes
from django . core . management . templates import TemplateCommand
from django . core . management . utils import ( handle_extensions , find_command ,  popen_wrapper )
from django . core . management . utils import find_command , popen_wrapper
from django . core . management . utils import handle_extensions
from django . core . management import call_command
from django . core . serializers . base import DeserializationError
from django . core . serializers . base import SerializerDoesNotExist
from django . core . serializers . json import DjangoJSONEncoder
from django . core . serializers . python import Deserializer as PythonDeserializer
from django . core . serializers . python import Serializer as PythonSerializer
from django . core . serializers import base
from django . core . servers . basehttp import get_internal_wsgi_application
from django . core . servers . basehttp import run , get_internal_wsgi_application
from django . core . servers . fastcgi import FASTCGI_HELP
from django . core . servers . fastcgi import FASTCGI_OPTIONS
from django . core . servers . fastcgi import runfastcgi
from django . core . signals import request_finished
from django . core . urlresolvers import reverse , NoReverseMatch
from django . core . urlresolvers import set_script_prefix
from django . core . validators import EMPTY_VALUES
from django . core . validators import validate_ipv4_address
from django . core . wsgi import get_wsgi_application
from django . core import checks
from django . core import mail
from django . core import serializers
from django . core import signals
from django . core import signing
from django . core import urlresolvers
from django . core import validators
from django . db . backends . utils import typecast_timestamp
from django . db . migrations . autodetector import MigrationAutodetector
from django . db . migrations . executor import MigrationExecutor
from django . db . migrations . loader import AmbiguityError
from django . db . migrations . loader import MigrationLoader
from django . db . migrations . loader import MigrationLoader , AmbiguityError
from django . db . migrations . optimizer import MigrationOptimizer
from django . db . migrations . questioner import MigrationQuestioner , InteractiveMigrationQuestioner
from django . db . migrations . state import ProjectState
from django . db . migrations . writer import MigrationWriter
from django . db . migrations import Migration
from django . db . models . fields . related import ManyToManyField
from django . db . models . fields . related import RelatedObject
from django . db . models . fields import Field as ModelField
from django . db . models import AutoField , OneToOneField , ForeignKey
from django . db . models import ForeignKey
from django . db . utils import DatabaseError
from django . db import ( connections , router , transaction , DEFAULT_DB_ALIAS ,  IntegrityError , DatabaseError )
from django . db import connection
from django . db import connections , DEFAULT_DB_ALIAS
from django . db import connections , DEFAULT_DB_ALIAS
from django . db import connections , DEFAULT_DB_ALIAS , migrations
from django . db import connections , router , transaction , DEFAULT_DB_ALIAS
from django . db import connections , router , transaction , DEFAULT_DB_ALIAS
from django . db import connections , router , transaction , models , DEFAULT_DB_ALIAS
from django . db import connections , transaction
from django . db import connections , transaction , router , DatabaseError
from django . db import DEFAULT_DB_ALIAS
from django . db import models
from django . db import models
from django . db import models , DEFAULT_DB_ALIAS
from django . db import models , router
from django . db import router , DEFAULT_DB_ALIAS
from django . dispatch import receiver
from django . dispatch import Signal
from django . forms . extras . widgets import SelectDateWidget
from django . forms . fields import *
from django . forms . fields import Field , ChoiceField
from django . forms . fields import Field , FileField
from django . forms . fields import IntegerField , BooleanField
from django . forms . forms import *
from django . forms . forms import DeclarativeFieldsMetaclass , BaseForm
from django . forms . formsets import *
from django . forms . formsets import BaseFormSet , formset_factory
from django . forms . models import *
from django . forms . utils import *
from django . forms . utils import ErrorList
from django . forms . utils import flatatt , ErrorDict , ErrorList
from django . forms . utils import flatatt , to_current_timezone
from django . forms . utils import from_current_timezone , to_current_timezone
from django . forms . widgets import (  TextInput , NumberInput , EmailInput , URLInput , HiddenInput ,  MultipleHiddenInput , ClearableFileInput , CheckboxInput , Select ,  NullBooleanSelect , SelectMultiple , DateInput , DateTimeInput , TimeInput ,  SplitDateTimeWidget , SplitHiddenDateTimeWidget , FILE_INPUT_CONTRADICTION  )
from django . forms . widgets import ( SelectMultiple , HiddenInput ,  MultipleHiddenInput )
from django . forms . widgets import *
from django . forms . widgets import HiddenInput
from django . forms . widgets import Media , MediaDefiningClass , TextInput , Textarea
from django . forms . widgets import Widget , Select
from django . forms import Form
from django . http . cookie import SimpleCookie
from django . http . cookie import SimpleCookie , parse_cookie
from django . http . multipartparser import MultiPartParser , MultiPartParserError
from django . http . request import ( HttpRequest , QueryDict ,  RawPostDataException , UnreadablePostError , build_request_repr )
from django . http . response import ( HttpResponse , StreamingHttpResponse ,  HttpResponseRedirect , HttpResponsePermanentRedirect ,  HttpResponseNotModified , HttpResponseBadRequest , HttpResponseForbidden ,  HttpResponseNotFound , HttpResponseNotAllowed , HttpResponseGone ,  HttpResponseServerError , Http404 , BadHeaderError , JsonResponse )
from django . http . response import REASON_PHRASES as STATUS_CODE_TEXT
from django . http . utils import fix_location_header , conditional_content_removal
from django . http import Http404
from django . http import HttpResponse
from django . http import QueryDict
from django . middleware . csrf import get_token
from django . template . base import ( ALLOWED_VARIABLE_CHARS , BLOCK_TAG_END ,  BLOCK_TAG_START , COMMENT_TAG_END , COMMENT_TAG_START ,  FILTER_ARGUMENT_SEPARATOR , FILTER_SEPARATOR , SINGLE_BRACE_END ,  SINGLE_BRACE_START , TOKEN_BLOCK , TOKEN_COMMENT , TOKEN_TEXT , TOKEN_VAR ,  TRANSLATOR_COMMENT_MARK , UNKNOWN_SOURCE , VARIABLE_ATTRIBUTE_SEPARATOR ,  VARIABLE_TAG_END , VARIABLE_TAG_START , filter_re , tag_re )
from django . template . base import ( compile_string , resolve_variable ,  unescape_string_literal , generic_tag_compiler )
from django . template . base import ( Context , FilterExpression , Lexer , Node ,  NodeList , Parser , RequestContext , Origin , StringOrigin , Template ,  TextNode , Token , TokenParser , Variable , VariableNode , constant_string ,  filter_raw_string )
from django . template . base import ( ContextPopException , InvalidTemplateLibrary ,  TemplateDoesNotExist , TemplateEncodingError , TemplateSyntaxError ,  VariableDoesNotExist )
from django . template . base import ( Library , add_to_builtins , builtins ,  get_library , get_templatetags_modules , get_text_list , import_library ,  libraries )
from django . template . base import ( Node , NodeList , Template , Context , Library ,  TemplateSyntaxError , VariableDoesNotExist , InvalidTemplateLibrary ,  BLOCK_TAG_START , BLOCK_TAG_END , VARIABLE_TAG_START , VARIABLE_TAG_END ,  SINGLE_BRACE_START , SINGLE_BRACE_END , COMMENT_TAG_START , COMMENT_TAG_END ,  VARIABLE_ATTRIBUTE_SEPARATOR , get_library , token_kwargs , kwarg_re ,  render_value_in_context )
from django . template . base import Lexer , Parser , tag_re , NodeList , VariableNode , TemplateSyntaxError
from django . template . base import Origin , Template , Context , TemplateDoesNotExist
from django . template . base import TemplateDoesNotExist
from django . template . base import TemplateSyntaxError , Library , Node , TextNode , token_kwargs , Variable
from django . template . base import Variable , Library , VariableDoesNotExist
from django . template . context import ( BaseContext , Context , RequestContext ,  ContextPopException )
from django . template . debug import DebugLexer , DebugParser
from django . template . defaultfilters import date
from django . template . loader import BaseLoader
from django . template . loader import BaseLoader , get_template_from_string , find_template_loader , make_origin
from django . template . loader import get_template
from django . template . loader import get_template , select_template
from django . template . smartif import IfParser , Literal
from django . template import ( Lexer , TOKEN_TEXT , TOKEN_VAR , TOKEN_BLOCK ,  TOKEN_COMMENT , TRANSLATOR_COMMENT_MARK )
from django . template import loader , Context , RequestContext
from django . template import Template , Context
from django . test . signals import setting_changed
from django . test . utils import get_runner
from django . test . utils import get_runner
from django . utils . _os import npath , upath
from django . utils . _os import rmtree_errorhandler
from django . utils . _os import safe_join
from django . utils . _os import safe_join , abspathu
from django . utils . _os import upath
from django . utils . crypto import constant_time_compare , salted_hmac
from django . utils . crypto import get_random_string
from django . utils . daemonize import become_daemon
from django . utils . datastructures import MultiValueDict
from django . utils . datastructures import MultiValueDict , ImmutableList
from django . utils . datastructures import MultiValueDict , MergeDict
from django . utils . dateformat import format , time_format
from django . utils . dates import MONTHS
from django . utils . dates import MONTHS , MONTHS_3 , MONTHS_ALT , MONTHS_AP , WEEKDAYS , WEEKDAYS_ABBR
from django . utils . deconstruct import deconstructible
from django . utils . deprecation import RemovedInDjango19Warning
from django . utils . deprecation import RemovedInDjango19Warning , RemovedInDjango20Warning
from django . utils . deprecation import RemovedInDjango20Warning
from django . utils . deprecation import RemovedInNextVersionWarning
from django . utils . deprecation import RenameMethodsBase , RemovedInDjango19Warning
from django . utils . encoding import force_bytes
from django . utils . encoding import force_bytes , force_str , force_text
from django . utils . encoding import force_bytes , force_text , force_str , iri_to_uri
from django . utils . encoding import force_bytes , force_text , iri_to_uri
from django . utils . encoding import force_bytes , python_2_unicode_compatible
from django . utils . encoding import force_str
from django . utils . encoding import force_str
from django . utils . encoding import force_str , force_text
from django . utils . encoding import force_str , force_text , DEFAULT_LOCALE_ENCODING
from django . utils . encoding import force_str , force_text , iri_to_uri
from django . utils . encoding import force_text
from django . utils . encoding import force_text , DEFAULT_LOCALE_ENCODING
from django . utils . encoding import force_text , filepath_to_uri
from django . utils . encoding import force_text , force_str
from django . utils . encoding import force_text , iri_to_uri
from django . utils . encoding import force_text , python_2_unicode_compatible
from django . utils . encoding import force_text , smart_text
from django . utils . encoding import force_unicode
from django . utils . encoding import iri_to_uri , force_bytes , force_text
from django . utils . encoding import python_2_unicode_compatible
from django . utils . encoding import python_2_unicode_compatible , force_str
from django . utils . encoding import smart_text
from django . utils . encoding import smart_text , force_str , force_text
from django . utils . encoding import smart_text , force_text
from django . utils . encoding import smart_text , force_text , python_2_unicode_compatible
from django . utils . encoding import smart_text , is_protected_type
from django . utils . formats import get_format
from django . utils . formats import localize
from django . utils . functional import allow_lazy
from django . utils . functional import allow_lazy , SimpleLazyObject
from django . utils . functional import cached_property
from django . utils . functional import curry , Promise
from django . utils . functional import lazy
from django . utils . functional import LazyObject
from django . utils . functional import Promise
from django . utils . functional import total_ordering
from django . utils . html import ( conditional_escape , escapejs ,  escape , urlize as _urlize , linebreaks , strip_tags , avoid_wrapping ,  remove_tags )
from django . utils . html import avoid_wrapping
from django . utils . html import conditional_escape , format_html
from django . utils . html import escape
from django . utils . html import format_html
from django . utils . html import format_html , format_html_join , escape
from django . utils . html import strip_spaces_between_tags
from django . utils . http import cookie_date
from django . utils . http import http_date
from django . utils . http import urlquote
from django . utils . http import urlquote
from django . utils . ipv6 import clean_ipv6_address
from django . utils . ipv6 import is_valid_ipv6_address
from django . utils . itercompat import is_iterable
from django . utils . jslex import prepare_js_for_gettext
from django . utils . module_loading import import_string
from django . utils . module_loading import module_has_submodule
from django . utils . regex_helper import normalize
from django . utils . safestring import ( SafeData , EscapeData , mark_safe ,  mark_for_escaping )
from django . utils . safestring import mark_safe
from django . utils . safestring import mark_safe , SafeData
from django . utils . safestring import mark_safe , SafeData , mark_for_escaping
from django . utils . safestring import SafeData , EscapeData
from django . utils . safestring import SafeData , mark_safe
from django . utils . six . moves . urllib . parse import (  quote , quote_plus , unquote , unquote_plus , urlparse ,  urlencode as original_urlencode )
from django . utils . six . moves . urllib . parse import parse_qsl , urlencode , quote , urljoin , urlsplit
from django . utils . six . moves . urllib . parse import quote
from django . utils . six . moves . urllib . parse import quote , unquote , urlsplit , urlunsplit
from django . utils . six . moves . urllib . parse import urljoin
from django . utils . six . moves . urllib . parse import urlparse
from django . utils . six . moves . urllib . parse import urlsplit , urlunsplit
from django . utils . six . moves . urllib . request import urlretrieve
from django . utils . six . moves import _dummy_thread as thread
from django . utils . six . moves import _thread as thread
from django . utils . six . moves import copyreg
from django . utils . six . moves import cPickle as pickle
from django . utils . six . moves import cPickle as pickle
from django . utils . six . moves import html_entities
from django . utils . six . moves import html_parser as _html_parser
from django . utils . six . moves import http_cookies
from django . utils . six . moves import input
from django . utils . six . moves import map
from django . utils . six . moves import reduce
from django . utils . six . moves import socketserver
from django . utils . six . moves import xrange
from django . utils . six . moves import zip
from django . utils . six import StringIO
from django . utils . synch import RWLock
from django . utils . text import ( smart_split , unescape_string_literal ,  get_text_list )
from django . utils . text import get_text_list
from django . utils . text import get_text_list , capfirst
from django . utils . text import get_valid_filename
from django . utils . text import normalize_newlines
from django . utils . text import normalize_newlines , slugify as _slugify
from django . utils . text import Truncator , wrap , phone2numeric
from django . utils . text import unescape_entities
from django . utils . timesince import timesince , timeuntil
from django . utils . timezone import get_current_timezone_name
from django . utils . timezone import get_default_timezone , is_aware , is_naive
from django . utils . timezone import is_aware
from django . utils . timezone import is_aware , utc
from django . utils . timezone import template_localtime
from django . utils . timezone import utc , get_fixed_timezone
from django . utils . translation import get_language
from django . utils . translation import get_language
from django . utils . translation import get_language , to_locale , check_for_language
from django . utils . translation import templatize
from django . utils . translation import trans_null as trans
from django . utils . translation import trans_real
from django . utils . translation import trans_real as trans
from django . utils . translation import TranslatorCommentWarning , trim_whitespace , LANGUAGE_SESSION_KEY
from django . utils . translation import ugettext , ungettext
from django . utils . translation import ugettext , ungettext_lazy
from django . utils . translation import ugettext as _
from django . utils . translation import ugettext_lazy
from django . utils . translation import ugettext_lazy , pgettext_lazy
from django . utils . translation import ugettext_lazy , ugettext as _ , pgettext
from django . utils . translation import ugettext_lazy as _
from django . utils . translation import ugettext_lazy as _ , pgettext_lazy
from django . utils . translation import ugettext_lazy as _ , ugettext
from django . utils . translation import ugettext_lazy as _ , ungettext_lazy
from django . utils . translation import ungettext , ugettext as _
from django . utils . xmlutils import SimplerXMLGenerator
from django . utils import archive
from django . utils import autoreload
from django . utils import baseconv
from django . utils import datastructures
from django . utils import dateformat , numberformat , datetime_safe
from django . utils import datetime_safe
from django . utils import formats
from django . utils import formats
from django . utils import formats , six
from django . utils import lru_cache
from django . utils import six
from django . utils import six , lru_cache
from django . utils import six , timezone
from django . utils import termcolors
from django . utils import timezone
from django . utils import timezone , six
from django . utils import translation
from django . utils import translation
from django . utils import translation
from django . utils import translation
from django . views . debug import ExceptionReporter , get_exception_reporter_filter
from django . views import debug
from django import http
from django import VERSION as version
from email . header import Header
from email . message import Message
from email . mime . base import MIMEBase
from email . mime . message import MIMEMessage
from email . mime . multipart import MIMEMultipart
from email . mime . text import MIMEText
from email . utils import formatdate
from email . utils import formatdate , getaddresses , formataddr , parseaddr
from email import ( charset as Charset , encoders as Encoders ,  message_from_string , generator )
from functools import lru_cache
from functools import partial
from functools import reduce
from functools import total_ordering
from functools import update_wrapper
from functools import wraps
from functools import wraps , update_wrapper , WRAPPER_ASSIGNMENTS
from gzip import GzipFile
from importlib . util import find_spec as importlib_find
from importlib import find_loader as importlib_find
from importlib import import_module
from importlib import import_module
from inspect import getargspec , getcallargs
from io import BytesIO
from io import BytesIO , StringIO , UnsupportedOperation
from io import StringIO
from IPython . frontend . terminal . ipapp import TerminalIPythonApp
from IPython . Shell import IPShell
from IPython import start_ipython
from itertools import chain
from itertools import dropwhile
from itertools import groupby , cycle as itertools_cycle
from itertools import product
from lib2to3 . fixer_util import find_indentation , Name , syms , touch_import
from lib2to3 . pgen2 import token
from lib2to3 . pytree import Leaf , Node
from lib2to3 import fixer_base
from logging . config import dictConfig
from logging import _checkLevel
from logging import NullHandler
from math import ceil
from optparse import OptionParser
from os . path import join , normcase , normpath , abspath , isabs , sep , dirname
from os import path
from PIL import Image
from PIL import ImageFile as PillowImageFile
from pkg_resources import resource_string
from pprint import pformat
from pprint import pformat
from shutil import copystat
from subprocess import PIPE , Popen
from threading import local
from threading import Lock
from threading import RLock
from unittest import *
from unittest2 import *
from UserList import UserList
from wsgiref . util import FileWrapper
from wsgiref import simple_server
from xml . dom import pulldom
from xml . sax . expatreader import ExpatParser as _ExpatParser
from xml . sax . saxutils import XMLGenerator
from xml . sax import handler
from yaml import CSafeDumper as SafeDumper
from yaml import CSafeLoader as SafeLoader
from yaml import SafeLoader , SafeDumper
from_email = sanitize_address ( email_message . from_email , email_message . encoding )
fs_encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )
fs_encoding = sys . getfilesystemencoding ( ) or sys . getdefaultencoding ( )
full_file = os . path . join ( self . path , f )
full_module_name = package_name + '.' + module_name
full_path = self . path ( name )
full_path = self . path ( name )
full_statement . append ( '    %s%s' % ( line , ',' if i < len ( table_output ) - 1 else '' ) )
full_statement . append ( ');' )
full_statement = [ "CREATE TABLE %s (" % qn ( tablename ) ]
func . __doc__ = doc
func ( path )
func = getattr ( func , '_decorated_function' , func )
func = import_string ( path )
func = TemplateLoader
func = TemplateLoader ( * args )
function_name = ( name or  getattr ( func , '_decorated_function' , func ) . __name__ )
function_name = ( name or  getattr ( func , '_decorated_function' , func ) . __name__ )
g . flatten ( self , unixfrom = unixfrom )
g = g . strip ( '"' )
g = g . strip ( "'" )
g = generator . BytesGenerator ( fp , mangle_from_ = False )
g = generator . Generator ( fp , mangle_from_ = False )
g = imatch . group ( 1 )
g = one_percent_re . sub ( '%%' , g )
GB = 1 << 30
generic_lang_code = lang_code . split ( '-' ) [ 0 ]
generic_lang_code = lang_code . split ( '-' ) [ 0 ]
get = '<could not parse>'
get = ( pformat ( GET_override )  if GET_override is not None  else pformat ( request . GET ) )
get_callable . cache_clear ( )
get_format_lazy = lazy ( get_format , six . text_type , list , tuple )
get_function_closure = operator . attrgetter ( _func_closure )
get_function_code = operator . attrgetter ( _func_code )
get_function_defaults = operator . attrgetter ( _func_defaults )
get_function_globals = operator . attrgetter ( _func_globals )
get_git_changeset . cache = changeset
get_language = lambda : settings . LANGUAGE_CODE
get_language_bidi = lambda : settings . LANGUAGE_CODE in settings . LANGUAGES_BIDI
get_method_function = operator . attrgetter ( _meth_func )
get_method_self = operator . attrgetter ( _meth_self )
get_ns_resolver . cache_clear ( )
get_resolver . cache_clear ( )
get_supported_language_variant . cache_clear ( )
get_text_list = allow_lazy ( get_text_list , six . text_type )
get_valid_filename = allow_lazy ( get_valid_filename , six . text_type )
getattr ( combined , 'add_' + name ) ( getattr ( other , '_' + name , None ) )
getattr ( combined , 'add_' + name ) ( getattr ( self , '_' + name , None ) )
getattr ( self , 'add_' + name ) ( media_attrs . get ( name , None ) )
getattr ( self , 'error_dict' )
getcallargs ( current )
getLogger = logging . getLogger
gettempdir = tempfile . gettempdir
gettext . _translations = { }
gettext_lazy = lazy ( gettext , str )
gettext_module . GNUTranslations . __init__ ( self )
gettext_noop = gettext_lazy = _ = gettext
git_changeset = get_git_changeset ( )
git_log = subprocess . Popen ( 'git log --pretty=format:%ct --quiet -1 HEAD' ,  stdout = subprocess . PIPE , stderr = subprocess . PIPE ,  shell = True , cwd = repo_dir , universal_newlines = True )
global _cached_modules , _cached_filenames
global _default
global _format_cache , _format_modules_cache
global _localtime
global _mtimes , _win
global _serializers
global _standard_context_processors
global _supported
global _translations
global invalid_var_format_string
global template_source_loaders
global templatetags_modules
globalpath = os . path . join (  os . path . dirname ( upath ( sys . modules [ settings . __module__ ] . __file__ ) ) , 'locale' )
got_request_exception = Signal ( providing_args = [ "request" ] )
graph = loader . graph
groupid = "t%d" % tok . id
guessed_filename += ext
guessed_filename = params . get ( 'filename' ) or used_name
guessed_filename = used_name
guessed_path = path . join ( tempdir , guessed_filename )
guid_attrs [ 'isPermaLink' ] = str (  item [ 'unique_id_is_permalink' ] ) . lower ( )
guid_attrs = { }
h = (y + x)%128
h = (y + x)%2
h = (y + z)%256
handle_default_options ( options )
handle_default_options ( options )
handle_m2m ( relobj )
handler . addQuickElement ( 'published' , rfc3339_date ( item [ 'pubdate' ] ) )
handler . addQuickElement ( 'updated' , rfc3339_date ( item [ 'updateddate' ] ) )
handler . addQuickElement ( "atom:link" , None ,  { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
handler . addQuickElement ( "author" , "%s (%s)" %  ( item [ 'author_email' ] , item [ 'author_name' ] ) )
handler . addQuickElement ( "author" , item [ "author_email" ] )
handler . addQuickElement ( "category" , "" , { "term" : cat } )
handler . addQuickElement ( "category" , "" , { "term" : cat } )
handler . addQuickElement ( "category" , cat )
handler . addQuickElement ( "category" , cat )
handler . addQuickElement ( "comments" , item [ 'comments' ] )
handler . addQuickElement ( "copyright" , self . feed [ 'feed_copyright' ] )
handler . addQuickElement ( "dc:creator" , item [ "author_name" ] , { "xmlns:dc" : "http://purl.org/dc/elements/1.1/" } )
handler . addQuickElement ( "description" , item [ 'description' ] )
handler . addQuickElement ( "description" , item [ 'description' ] )
handler . addQuickElement ( "description" , self . feed [ 'description' ] )
handler . addQuickElement ( "email" , item [ 'author_email' ] )
handler . addQuickElement ( "email" , self . feed [ 'author_email' ] )
handler . addQuickElement ( "enclosure" , '' ,  { "url" : item [ 'enclosure' ] . url , "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
handler . addQuickElement ( "guid" , item [ 'unique_id' ] , guid_attrs )
handler . addQuickElement ( "id" , self . feed [ 'id' ] )
handler . addQuickElement ( "id" , unique_id )
handler . addQuickElement ( "language" , self . feed [ 'language' ] )
handler . addQuickElement ( "lastBuildDate" , rfc2822_date ( self . latest_post_date ( ) ) )
handler . addQuickElement ( "link" , '' ,  { "rel" : "enclosure" ,  "href" : item [ 'enclosure' ] . url ,  "length" : item [ 'enclosure' ] . length ,  "type" : item [ 'enclosure' ] . mime_type } )
handler . addQuickElement ( "link" , "" , { "href" : item [ 'link' ] , "rel" : "alternate" } )
handler . addQuickElement ( "link" , "" , { "rel" : "alternate" , "href" : self . feed [ 'link' ] } )
handler . addQuickElement ( "link" , "" , { "rel" : "self" , "href" : self . feed [ 'feed_url' ] } )
handler . addQuickElement ( "link" , item [ 'link' ] )
handler . addQuickElement ( "link" , self . feed [ 'link' ] )
handler . addQuickElement ( "name" , item [ 'author_name' ] )
handler . addQuickElement ( "name" , self . feed [ 'author_name' ] )
handler . addQuickElement ( "pubDate" , rfc2822_date ( item [ 'pubdate' ] ) )
handler . addQuickElement ( "rights" , item [ 'item_copyright' ] )
handler . addQuickElement ( "rights" , self . feed [ 'feed_copyright' ] )
handler . addQuickElement ( "subtitle" , self . feed [ 'subtitle' ] )
handler . addQuickElement ( "summary" , item [ 'description' ] , { "type" : "html" } )
handler . addQuickElement ( "title" , item [ 'title' ] )
handler . addQuickElement ( "title" , self . feed [ 'title' ] )
handler . addQuickElement ( "ttl" , item [ 'ttl' ] )
handler . addQuickElement ( "ttl" , self . feed [ 'ttl' ] )
handler . addQuickElement ( "updated" , rfc3339_date ( self . latest_post_date ( ) ) )
handler . addQuickElement ( "uri" , item [ 'author_link' ] )
handler . addQuickElement ( "uri" , self . feed [ 'author_link' ] )
handler . endElement ( "author" )
handler . endElement ( "channel" )
handler . endElement ( "entry" )
handler . endElement ( "feed" )
handler . endElement ( "item" )
handler . endElement ( "rss" )
handler . file . close ( )
handler . name = name
handler . new_file ( field_name , file_name ,  content_type , content_length ,  charset , content_type_extra )
handler . setLevel ( _checkLevel ( level ) )
handler . startDocument ( )
handler . startElement ( 'feed' , self . root_attributes ( ) )
handler . startElement ( 'item' , self . item_attributes ( item ) )
handler . startElement ( "author" , { } )
handler . startElement ( "author" , { } )
handler . startElement ( "channel" , self . root_attributes ( ) )
handler . startElement ( "entry" , self . item_attributes ( item ) )
handler . startElement ( "rss" , self . rss_attributes ( ) )
handler = logging . _handlers [ name ]
handler = logging . StreamHandler ( )
handler = self . configure_handler ( handlers [ name ] )
handler = self . get_handler ( * args , ** options )
handler = SimplerXMLGenerator ( outfile , encoding )
handler_config = handlers [ name ]
handlers [ name ] = handler
handlers = config . get ( 'handlers' , EMPTY_DICT )
handlers = config . get ( 'handlers' , None )
handlers = self . _upload_handlers
hard_coded_bullets_re = re . compile ( r'((?:<p>(?:%s).*?[a-zA-Z].*?</p>\s*)+)' % '|' . join ( re . escape ( x ) for x in DOTS ) , re . DOTALL )
has_bz2 = False
has_bz2 = True
has_new_option = hasattr ( self , 'requires_system_checks' )
has_old_option = hasattr ( self , 'requires_model_validation' )
header , value = settings . SECURE_PROXY_SSL_HEADER
header = chunk [ : header_end ]
header = header . upper ( ) . replace ( '-' , '_' )
header = self . _convert_to_charset ( header , 'ascii' )
header_end = chunk . find ( b'\r\n\r\n' )
header_names = [ key . lower ( ) for key in self . extra_headers ]
headerlist . append ( 'HTTP_' + header )
headerlist . sort ( )
headerlist = [ ]
headerlist = cache . get ( cache_key , None )
headers = [  ( b': ' . join ( [ to_bytes ( key , 'ascii' ) , to_bytes ( value , 'latin-1' ) ] ) )  for key , value in self . _headers . values ( )  ]
height = property ( _get_height )
help = ''
help = 'Compiles .po files to .mo files for use with builtin gettext support.'
help = 'Deprecated. Use "check" command instead. ' + CheckCommand . help
help = 'Discover and run tests in the specified modules or the current directory.'
help = 'Installs the named fixture(s) in the database.'
help = 'Prints the SQL statements for resetting sequences for the given app name(s).'
help = 'Runs a development server with data from the given fixture(s).'
help = "Checks the entire Django project for potential problems."
help = "Creates new migration(s) for apps."
help = "Creates the tables needed to use the SQL cache backend."
help = "Deprecated - use 'migrate' instead."
help = "Introspects the database tables in the given database and outputs a Django model module."
help = "Prints the CREATE INDEX SQL statements for the given model module name(s)."
help = "Prints the CREATE TABLE SQL statements for the given app name(s)."
help = "Prints the CREATE TABLE, custom SQL and CREATE INDEX SQL statements for the given model module name(s)."
help = "Prints the custom table modifying SQL statements for the given app name(s)."
help = "Prints the DROP INDEX SQL statements for the given model module name(s)."
help = "Prints the DROP TABLE SQL statements for the given app name(s)."
help = "Prints the SQL statements for the named migration."
help = "Returns a list of the SQL statements required to return all tables in the database to the state they were in just after they were installed."
help = "Runs a Python interactive interpreter. Tries to use IPython or bpython, if one of them is available."
help = "Runs this project as a FastCGI application. Requires flup."
help = "Squashes an existing set of migrations (from first until specified) into a single new one."
help = "Starts a lightweight Web server for development."
help = "Updates database schema. Manages both apps with migrations and those without."
help = ( 'Removes ALL DATA from the database, including data added during '  'migrations. Unmigrated apps will also have their initial_data '  'fixture reloaded. Does not achieve a "fresh install" state.' )
help = ( "Creates a Django app directory structure for the given app "  "name in the current directory or optionally in the given "  "directory." )
help = ( "Creates a Django project directory structure for the given "  "project name in the current directory or optionally in the "  "given directory." )
help = ( "Output the contents of the database as a fixture of the given "  "format (using each model's default manager unless --all is "  "specified)." )
help = ( "Runs over the entire source tree of the current directory and "  "pulls out all strings marked for translation. It creates (or updates) a message "  "file in the conf/locale (in the django tree) or locale (for projects and "  "applications) directory.\n\nYou must run this command with one of either the "  "--locale, --exclude or --all options." )
help = ( "Runs the command-line client for specified database, or the "  "default database if none is provided." )
help_text = ''
help_text = help_text_html % force_text ( field . help_text )
hex_format_string = "%%0%ix" % ( hlen * 2 )
hextet = ip_str . split ( '::' )
hextets [ best_doublecolon_start : best_doublecolon_end ] = [ '' ]
hextets [ index ] = '0'
hextets [ index ] = hextets [ index ] . lstrip ( '0' )
hextets += [ '' ]
hextets = [ '' ] + hextets
hextets = ip_str . split ( ':' )
hextets = ip_str . split ( ":" )
hfile = msvcrt . get_osfhandle ( _fd ( f ) )
hhmm = '%02d%02d' % divmod ( abs ( offset ) , 60 )
hidden_fields . append ( six . text_type ( bf ) )
hidden_widget = field . hidden_widget ( )
hidden_widget = HiddenInput
hidden_widget = MultipleHiddenInput
hidden_widget = SplitHiddenDateTimeWidget
hint = "\n\tHINT: %s" % self . hint if self . hint else ''
HITS , MISSES = 0 , 1
hits = max ( 1 , self . count - self . orphans )
hopcode = '%02x' %encoded
hopcode = '%02x' %x
hopcode = '%02x' %x
host = host . lower ( )
host = host [ : - 1 ] if host . endswith ( '.' ) else host
host = self . META [ 'HTTP_HOST' ]
host = self . META [ 'HTTP_X_FORWARDED_HOST' ]
host = self . META [ 'SERVER_NAME' ]
host_validation_re = re . compile ( r"^([a-z0-9.-]+|\[[a-f0-9]*:[a-f0-9:]+\])(:\d+)?$" )
hour , minute = divmod ( timezone , 60 )
hour , minute = divmod ( timezone , 60 )
hour = int ( m . group ( 'hour' ) )
html [ 'day' ] = self . create_select ( name , self . day_field , value , day_val , choices , self . day_none_value )
html [ 'month' ] = self . create_select ( name , self . month_field , value , month_val , choices , self . month_none_value )
html [ 'year' ] = self . create_select ( name , self . year_field , value , year_val , choices , self . year_none_value )
html = { }
html = endtag_re . sub ( '' , html )
html = starttag_re . sub ( '' , html )
html_class_attr = ' class="%s"' % css_classes
html_class_attr = ''
html_gunk_re = re . compile ( r'(?:<br clear="all">|<i><\/i>|<b><\/b>|<em><\/em>|<strong><\/strong>|<\/?smallcaps>|<\/?uppercase>)' , re . IGNORECASE )
html_message = reporter . get_traceback_html ( ) if self . include_html else None
html4_singlets = (  'br' , 'col' , 'link' , 'base' , 'img' ,  'param' , 'area' , 'hr' , 'input'  )
HTMLParseError = _html_parser . HTMLParseError
HTMLParser . __init__ ( self , strict = False )
HTMLParser . __init__ ( self )
HTMLParser = _html_parser . HTMLParser
httpd . daemon_threads = True
httpd . serve_forever ( )
httpd . set_app ( wsgi_handler )
httpd = httpd_cls ( server_address , WSGIRequestHandler , ipv6 = ipv6 )
httpd_cls = type ( str ( 'WSGIServer' ) , ( socketserver . ThreadingMixIn , WSGIServer ) , { } )
httpd_cls = WSGIServer
HttpResponse . content . fset ( self , value )
i += 1
i += 1
i += 1
i += 1
i += 1
i += 1
i +=1
i = 365
i = 366
i = existing . index ( name )
i = i % j
i = i + 1
i = j + 1
i = next_space_index ( subject , i )
i = next_space_index ( subject , i )
i = open_tags . index ( tagname )
i = p . find ( b'=' )
i=0
id = "(%s) " % self . id if self . id else ""
id = "literal"
id = None
id_ += '_0'
id_ = 'id_%s' % name
id_ = final_attrs . get ( 'id' , None )
id_ = final_attrs . get ( 'id' , None )
id_ = self . attrs . get ( 'id' , None )
id_ = self . attrs [ 'id' ]
id_ = self . field . widget . attrs . get ( 'id' ) or self . auto_id
id_ = widget . attrs . get ( 'id' ) or self . auto_id
id_for_label = widget . id_for_label ( id_ )
IDENTIFIER = re . compile ( '^[a-z_][a-z0-9_]*$' , re . I )
idhost = DNS_NAME
idstring = '.' + idstring
idstring = ''
idx = m . groups ( ) [ 0 ]
if __name__ == '__main__' :
if _cached_modules == module_values :
if _cookie_encodes_correctly and _cookie_allows_colon_in_names :
if _default is None :
if _default is None :
if _file is None :
if _file is not None :
if _globs_ is None :
if _ipv6 :
if _localtime is None :
if _locs_ is None :
if _samefile ( old_file_name , new_file_name ) :
if _standard_context_processors is None :
if _supported is None :
if _time . daylight :
if _win :
if '__str__' not in klass . __dict__ :
if '_' in locale :
if '--commands' in args :
if '-' not in lang_code :
if ',' in args [ 1 ] :
if ',' not in arg :
if ':::' in ip_str :
if '::' not in ip_str and ip_str . count ( ':' ) != 7 :
if ':' not in ip_str :
if ':' not in template :
if '.' in exclude :
if '.' in hextets [ - 1 ] :
if '.' in ip_str . split ( ':' ) [ - 1 ] :
if '.' in str_number :
if '.' in word or '@' in word or ':' in word :
if '.' not in var and 'e' not in var . lower ( ) :
if '()' in config :
if '@' in addr :
if '/' in path and ( ( '\\' in path and path . find ( '/' ) < path . find ( '\\' ) )  or '\\' not in path ) :
if '\n' in val or '\r' in val :
if '%(truncated_text)s' in truncate :
if 'args' in options :
if 'charset' in content_params :
if 'class' in attrs :
if 'date' not in header_names :
if 'DJANGO_AUTO_COMPLETE' not in os . environ :
if 'django.middleware.clickjacking.XFrameOptionsMiddleware' not in set ( settings . MIDDLEWARE_CLASSES ) :
if 'error_messages' in kwargs :
if 'file_path' in kwargs :
if 'forloop' in context :
if 'id' in self . attrs :
if 'id' in self . attrs :
if 'Location' in response and request . get_host ( ) :
if 'max-age' in cc :
if 'max-age' in cc and 'max_age' in kwargs :
if 'media' not in attrs :
if 'message-id' not in header_names :
if 'noreset' not in opts :
if 'pk' in d :
if 'private' in cc and 'public' in kwargs :
if 'version' not in config :
if 'warning' in kwargs :
if "'format'" not in str ( te ) :
if "'stream'" not in str ( te ) :
if "\\" in encoded and not encoded . startswith ( '"' ) :
if "\n" in self . __starttag_text :
if "0x0aec," in format_0x:
if ( ( ( self . allow_files and os . path . isfile ( full_file ) ) or  ( self . allow_folders and os . path . isdir ( full_file ) ) ) and  ( self . match is None or self . match_re . search ( f ) ) ) :
if ( ( context . autoescape and not isinstance ( value , SafeData ) ) or  isinstance ( value , EscapeData ) ) :
if ( ( ip_str . startswith ( ':' ) and not ip_str . startswith ( '::' ) ) or  ( ip_str . endswith ( ':' ) and not ip_str . endswith ( '::' ) ) ) :
if ( ( os . stat ( path ) . st_mode & stat . S_IREAD ) != stat . S_IREAD ) :
if ( 3 , 2 ) < sys . version_info < ( 3 , 3 , 4 ) :
if ( attr in ( "__file__" , "__name__" , "__path__" ) and  self . mod not in sys . modules ) :
if ( BLOCK_CONTEXT_KEY in render_context and  render_context [ BLOCK_CONTEXT_KEY ] . get_block ( self . name ) is not None ) :
if ( connections [ db ] . features . needs_datetime_string_cast and not  isinstance ( current_expires , datetime ) ) :
if ( context . autoescape and not isinstance ( output , SafeData ) ) or isinstance ( output , EscapeData ) :
if ( db . settings_dict [ 'ATOMIC_REQUESTS' ]  and db . alias not in non_atomic_requests ) :
if ( domain_part not in self . domain_whitelist and  not self . validate_domain_part ( domain_part ) ) :
if ( field == NON_FIELD_ERRORS and opts . error_messages and  NON_FIELD_ERRORS in opts . error_messages ) :
if ( form . cleaned_data and form . cleaned_data [ field ] is not None  and form . cleaned_data [ unique_for ] is not None ) :
if ( getattr ( meta , 'fields' , fields ) is None and  getattr ( meta , 'exclude' , exclude ) is None ) :
if ( getattr ( Meta , 'fields' , None ) is None and  getattr ( Meta , 'exclude' , None ) is None ) :
if ( hasattr ( self . cmd , 'missing_args_message' ) and  not ( args or any ( [ not arg . startswith ( '-' ) for arg in args ] ) ) ) :
if ( hasattr ( value , '__iter__' ) and  not isinstance ( value , six . text_type ) and  not hasattr ( value , '_meta' ) ) :
if ( i - day_of_year ) < ( 4 - weekday ) :
if ( isinstance ( args [ 0 ] , SafeData ) and  getattr ( _dec . _decorated_function , 'is_safe' , False ) ) :
if ( isinstance ( data , ( datetime . datetime , datetime . time ) ) and  not getattr ( self . field . widget , 'supports_microseconds' , True ) ) :
if ( isinstance ( data , Node ) and not data . negated  and ( data . connector == conn_type or len ( data ) == 1 ) ) :
if ( isinstance ( fp , file ) and  isinstance ( data , unicode ) and  fp . encoding is not None ) :
if ( isinstance ( message , ValidationError ) and  message . code in error_messages ) :
if ( locale is None and not exclude and not process_all ) or self . domain is None :
if ( middle . endswith ( closing )  and middle . count ( closing ) == middle . count ( opening ) + 1 ) :
if ( not normcase ( final_path ) . startswith ( normcase ( base_path + sep ) ) and  normcase ( final_path ) != normcase ( base_path ) and  dirname ( normcase ( base_path ) ) != normcase ( base_path ) ) :
if ( obj . pk is None and hasattr ( Model , 'natural_key' ) and  hasattr ( Model . _default_manager , 'get_by_natural_key' ) ) :
if ( self . max_digits is not None and self . decimal_places is not None  and whole_digits > ( self . max_digits - self . decimal_places ) ) :
if ( self . negate and val1 != val2 ) or ( not self . negate and val1 == val2 ) :
if ( self . requires_system_checks and  not options . get ( 'skip_validation' ) and  not options . get ( 'skip_checks' ) ) :
if ( self . validate_max and  self . total_form_count ( ) - len ( self . deleted_forms ) > self . max_num ) or self . management_form . cleaned_data [ TOTAL_FORM_COUNT ] > self . absolute_max :
if (len(execve_shellcode)%3)!=0:
if (len(z)%100)!=0:
if (r ^ c[i] != 0) and (r ^ c[i+1] != 0) and (r ^ c[i+2] != 0) and (r ^ c[i+3] != 0):
if (r ^ shellcode_original[i] != 0) and (r ^ shellcode_original[i+1] != 0) and (r ^ shellcode_original[i+2] != 0) and (r ^ shellcode_original[i+3] != 0):
if a % 2 == 0 :
if action == "apply_start" :
if age > max_age :
if alias not in settings . CACHES :
if all_issues :
if alter_sql :
if answer != "y" :
if any ( e . is_serious ( ) and not e . is_silenced ( ) for e in all_issues ) :
if any ( len ( x ) < 4 for x in ip_str . split ( ':' ) ) :
if app == 'django.core' :
if app_config . label in loader . migrated_apps :
if app_config . models_module is None :
if app_config . models_module is None :
if app_config . models_module is None :
if app_config . models_module is None or app_config in excluded_apps :
if app_config . models_module is None or app_config in excluded_apps :
if app_config is None :
if app_label not in executor . loader . migrated_apps :
if app_labels :
if app_list_value is not None :
if app_name not in loader . migrated_apps :
if app_names :
if app_output :
if app_path is None :
if arg :
if arg . startswith ( option ) :
if arg < 1 :
if arg is None :
if arg is None :
if arg not in ( 'on' , 'off' ) :
if args :
if args :
if args [ - 1 ] != "silent" :
if args [ - 3 ] == "as" :
if args [ 1 ] [ 0 ] == '2' :
if args and kwargs :
if args is None :
if as_ != 'as' :
if as_form :
if att_name == 'id' and extra_params == { 'primary_key' : True } :
if attr in flags :
if attr in obj_dict :
if attrs :
if attrs is None :
if attrs is not None :
if attrvalue :
if auto_id and '%s' in smart_text ( auto_id ) :
if auto_id and 'id' not in attrs and 'id' not in widget . attrs :
if autoescape :
if autoescape and not safe_input :
if bad_app_labels :
if base . lower ( ) . endswith ( '.tar' ) :
if base_url is None :
if base64d [ : 1 ] == b'.' :
if bases == ( BaseModelForm , ) :
if basetype == 'text' :
if bcc :
if best_doublecolon_end == len ( hextets ) :
if best_doublecolon_len > 1 :
if best_doublecolon_start == 0 :
if bf . is_hidden :
if bf . label :
if bf_errors :
if bit :
if bit . startswith ( '_("' ) or bit . startswith ( "_('" ) :
if bits [ 0 ] != 'and' :
if bits [ 2 ] != 'by' :
if bits [ 2 ] == 'parsed' :
if bits [ 4 ] != 'as' :
if bits [ in_index ] != 'in' :
if bits and not kwarg_format :
if block is None :
if block_content [ : 9 ] in ( 'verbatim' , 'verbatim ' ) :
if block_context is None :
if BLOCK_CONTEXT_KEY not in context . render_context :
if block_name in parser . __loaded_blocks :
if bmatch . group ( 1 ) :
if boundary :
if buffer_ :
if buffer_ is not None :
if bytes < KB :
if bytes_read > rollback :
if cache is None :
if cache_choices is not None :
if cache_timeout < 0 :
if cache_timeout is None :
if cache_timeout is None :
if cached is not None :
if calendar . isleap ( self . data . year ) :
if callable ( callback ) :
if callable ( current ) :
if callable ( data ) :
if callable ( getattr ( self . stream , 'getvalue' , None ) ) :
if callable ( initial_value ) :
if callable ( key_func ) :
if callable ( limit_choices_to ) :
if callable ( lookup_view ) :
if callable ( name ) :
if callable ( self . limit_choices_to ) :
if can_fail :
if can_fail :
if categories :
if cc :
if ch  not in bad_chars:
if ch :
if ch != '?' or escaped :
if ch != '\\' :
if ch == '?' :
if ch == '(' :
if ch == '+' :
if ch == '<' :
if ch in '*?+' :
if ch in "iLmsu#" :
if ch not in ( '<' , '=' ) :
if ch2 == '?' :
if change == FILE_MODIFIED :
if character != '.' :
if charset == 'utf-8' :
if check not in self . registered_checks :
if check_path :
if child . nodeType == child . TEXT_NODE or child . nodeType == child . CDATA_SECTION_NODE :
if chunk is None :
if cleaned_data is not None :
if cleaned_line . endswith ( ";" ) :
if close :
if cls . _delegate_text :
if cmatch :
if cmd . endswith ( ext ) :
if cnt and not cnt % grouping :
if code in _supported and check_for_language ( code ) :
if code is None :
if code is not None :
if code is not None :
if code_changed ( ) :
if col_name != new_name and field_notes :
if col_name . lower ( ) . find ( '__' ) >= 0 :
if color_settings :
if colors and colors [ - 1 ] in color_names :
if column_name in indexes :
if command . use_argparse :
if command . verbosity > 1 :
if command in parse_until :
if commands_only :
if comment_lineno_cache == cur_lineno :
if comment_lineno_cache is not None :
if comment_notes :
if commit :
if commit :
if commit and hasattr ( form , 'save_m2m' ) :
if common_ancestor is None :
if compare_to != state_frame [ self ] :
if compress :
if condition is not None :
if config [ 'version' ] != 1 :
if confirm == 'yes' :
if confirm == 'yes' :
if confirm not in ( 'yes' , 'no' ) :
if conflicts :
if conflicts and not self . merge :
if connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names :
if connection . ops . start_transaction_sql ( ) :
if connection . settings_dict [ 'ENGINE' ] == 'django.db.backends.dummy' :
if connections [ db ] . features . needs_datetime_string_cast and not isinstance ( expires , datetime ) :
if constant :
if constant_arg :
if constant_time_compare ( sig , self . signature ( value ) ) :
if construct :
if consume_next :
if contains ( elt , inst ) :
if contains ( result [ - 1 ] , Group ) :
if content_disposition :
if content_length < 0 :
if content_length > settings . FILE_UPLOAD_MAX_MEMORY_SIZE :
if contents is not None :
if CONTEXT_SEPARATOR in result :
if converter :
if count % 2 != 0:
if count % 2 != 0:
if count == 0 :
if counter % 2 == 0 :
if counter % 2 == 0 :
if csrf_token == 'NOTPROVIDED' :
if csrf_token is not None :
if css_classes :
if current_app and current_app in app_list :
if current_len <= length :
if current_len == truncate_len :
if current_version >= ( 3 , 4 ) :
if cursor :
if cursor and close_connection :
if cursor and connection . introspection . table_name_converter ( model . _meta . db_table ) in table_names :
if custom_sql :
if cword == 1 :
if cwords [ 0 ] == 'runfcgi' :
if daemonize :
if data :
if data [ last : last + 1 ] == b'\n' :
if data [ last : last + 1 ] == b'\r' :
if data in ( None , FILE_INPUT_CONTRADICTION ) :
if data in seen_data :
if data in self . children :
if data in self . empty_values :
if data is False :
if data is FILE_INPUT_CONTRADICTION :
if data is None :
if data is None or isinstance ( data , dict ) :
if data is not None :
if data_list :
if data_list [ 0 ] in self . empty_values :
if data_list [ 1 ] in self . empty_values :
if date is not None :
if day_of_year <= ( 8 - jan1_weekday ) and jan1_weekday > 4 :
if dec_part :
if decimal_pos is not None :
if decimal_pos is not None :
if decimal_separator in value :
if decimals > digits :
if decompress :
if default is None :
if default is not RAISE_ERROR :
if DEFAULT_CACHE_ALIAS not in settings . CACHES :
if default_list is None :
if defaults is not None :
if definition :
if delta < 0 :
if delta < 0 :
if deps :
if digest is None :
if dirname . startswith ( '.' ) or dirname == '__pycache__' :
if dirname and not os . path . exists ( dirname ) :
if dirname and not os . path . exists ( dirname ) :
if display_num_errors :
if django . VERSION [ - 2 ] != 'final' :
if dklen > ( 2 ** 32 - 1 ) * hlen :
if domain :
if domain == 'djangojs' and file_ext in command . extensions :
if domain and validate_host ( domain , settings . ALLOWED_HOSTS ) :
if domain is not None :
if doublecolon_len > best_doublecolon_len :
if doublecolon_start == - 1 :
if dt . year >= 1900 :
if e . args [ 0 ] . startswith ( "Error -5" ) :
if e . args [ 0 ] not in not_found :
if e . errno != errno . EEXIST :
if e . errno != errno . ENOENT :
if e . errno != errno . ENOENT :
if e . errno != errno . ENOENT :
if e . errno == errno . EEXIST :
if e . errno == errno . EEXIST :
if e . errno == errno . ENOENT :
if empty_label is not None :
if encoding == 'utf-8' :
if end . endswith ( '/>' ) :
if end < 0 :
if end is None :
if end is not None :
if end not in ( ">" , "/>" ) :
if end_index is None and s_len > truncate_len :
if endblock . contents not in acceptable_endblocks :
if endbmatch :
if ending and not msg . endswith ( ending ) :
if endpos < 0 :
if err_log :
if error . code == code :
if error . params :
if error_class is None :
if error_message is not None :
if error_messages and f . name in error_messages :
if error_messages is not None :
if errors :
if errors is None :
if errors_on_separate_row and bf_errors :
if escaped :
if event . path . endswith ( '.mo' ) :
if event == "START_ELEMENT" and node . nodeName == "object" :
if exclude and f . name in exclude :
if exclude is not None :
if exctype is not WindowsError or 'Access is denied' not in str ( value ) :
if exit_code != 3 :
if exit_code < 0 :
if exp is None or exp > time . time ( ) :
if exp is not None and exp < time . time ( ) :
if expires < now :
if expires is not None :
if ext :
if extend :
if extend is True :
if extra_attrs :
if extra_params :
if extracted :
if f . db_index :
if f . name in cleaned_data :
if f . primary_key :
if f . rel and f . rel . to not in to_delete :
if f == '__pycache__' :
if f is None :
if failures :
if fake :
if fd . isatty ( ) :
if fd >= 0 :
if fdel is not None :
if fg in color_names :
if fget is not None :
if field != NON_FIELD_ERRORS and field not in self . fields :
if field . _has_changed ( field . to_python ( initial ) , data ) :
if field . _has_changed ( initial_value , data_value ) :
if field . error_messages [ 'incomplete' ] not in errors :
if field . help_text :
if field . rel . through . _meta . auto_created :
if field . rel . to . _meta . pk . rel :
if field . rel and isinstance ( field . rel , models . ManyToManyRel ) :
if field . rel and isinstance ( field . rel , models . ManyToManyRel ) :
if field . rel is None :
if field . serialize :
if field . widget . needs_multipart_form :
if field == NON_FIELD_ERRORS :
if field in form . cleaned_data :
if field in self . cleaned_data :
if field in self . errors :
if field is not None :
if field not in self . errors :
if field not in self . fields :
if field_node . getElementsByTagName ( 'None' ) :
if field_type == 'AutoField(' :
if field_type == 'BooleanField(' :
if field_type == 'CharField' and row [ 3 ] :
if field_type == 'DecimalField' :
if field_type not in ( 'TextField(' , 'CharField(' ) :
if field_value in self . empty_values :
if field_value is not None :
if fields :
if fields and f . name not in fields :
if fields is not None :
if fields is not None and f . name not in fields :
if file_ :
if file_obj :
if filename :
if filename . endswith ( '.mo' ) :
if filename . endswith ( ".pyc" ) or filename . endswith ( ".pyo" ) :
if filename . endswith ( "$py.class" ) :
if filename . endswith ( ( '.pyo' , '.pyc' , '.py.class' ) ) :
if filename . endswith ( ( '/' , '\\' ) ) :
if filename . endswith ( extensions ) or filename in extra_files :
if filename and not os . path . exists ( filename ) :
if filename not in _error_files :
if filename not in _mtimes :
if filepath . startswith ( root ) :
if filter_name in ( 'escape' , 'safe' ) :
if filter_name in self . filters :
if filters :
if find_command ( program ) is None :
if find_command ( self . program ) is None :
if finder . find_module ( name , package_path ) :
if finder . find_module ( name ) :
if finder is None :
if first :
if fixture_name != 'initial_data' and not fixture_files :
if fk . unique :
if fk_name :
if flags is not None :
if float ( value ) != 1 :
if force_text ( val ) not in pks :
if force_text ( value ) != force_text ( orig ) :
if form . _meta . fields :
if form . _meta . widgets :
if form . errors :
if form . is_bound :
if form in forms_to_delete :
if format not in _serializers :
if format not in serializers . get_public_serializer_formats ( ) :
if format_module_path :
if format_module_path is None :
if formatter :
if formfield :
if formfield_callback is None :
if found :
if fp is None :
if fset is not None :
if func is None :
if g [ 0 ] == '"' :
if getattr ( current , 'do_not_call_in_templates' , False ) :
if getattr ( e , 'silent_variable_failure' , False ) :
if getattr ( e , 'winerror' , 0 ) != 32 and getattr ( e , 'errno' , 0 ) != 13 :
if getattr ( ev , 'filename' , None ) is None :
if getattr ( func , 'expects_localtime' , False ) :
if getattr ( func , 'is_safe' , False ) and isinstance ( obj , SafeData ) :
if getattr ( func , 'needs_autoescape' , False ) :
if getattr ( obj , field . name ) is not None :
if getattr ( self , '_client' , None ) is None :
if getattr ( self , '_client' , None ) is None :
if gettext_module . find ( 'django' , path , [ to_locale ( lang_code ) ] ) is not None :
if git_changeset :
if graph . nodes [ plan_node ] . replaces :
if handlers :
if has_bom ( po_path ) :
if has_bz2 :
if has_old_option :
if has_old_option and has_new_option :
if hasattr ( _active , "value" ) :
if hasattr ( _active , "value" ) :
if hasattr ( _urlconfs , "value" ) :
if hasattr ( base , 'base_fields' ) :
if hasattr ( base , 'declared_fields' ) :
if hasattr ( base , 'declared_fields' ) :
if hasattr ( cls , k ) :
if hasattr ( content , 'temporary_file_path' ) :
if hasattr ( data , 'read' ) :
if hasattr ( data , 'temporary_file_path' ) :
if hasattr ( decorator , '__name__' ) :
if hasattr ( e , 'code' ) and e . code in self . error_messages :
if hasattr ( error , 'error_dict' ) :
if hasattr ( extra_classes , 'split' ) :
if hasattr ( f , 'seek' ) and callable ( f . seek ) :
if hasattr ( field . rel , 'to' ) :
if hasattr ( field . rel . to . _default_manager , 'get_by_natural_key' ) :
if hasattr ( field . rel . to . _default_manager , 'get_by_natural_key' ) :
if hasattr ( field . rel . to . _default_manager , 'get_by_natural_key' ) :
if hasattr ( field_value , '__iter__' ) and not isinstance ( field_value , six . text_type ) :
if hasattr ( file , 'mode' ) :
if hasattr ( file_or_path , 'read' ) :
if hasattr ( filter_func , "_decorated_function" ) :
if hasattr ( form , 'Meta' ) :
if hasattr ( formfield , 'queryset' ) :
if hasattr ( get_git_changeset , 'cache' ) :
if hasattr ( handler , 'file' ) :
if hasattr ( hashlib , "pbkdf2_hmac" ) :
if hasattr ( hmac , "compare_digest" ) :
if hasattr ( message , 'error_dict' ) :
if hasattr ( middleware , 'process_exception' ) :
if hasattr ( middleware , 'process_request' ) :
if hasattr ( middleware , 'process_response' ) :
if hasattr ( middleware , 'process_template_response' ) :
if hasattr ( middleware , 'process_view' ) :
if hasattr ( model , 'natural_key' ) :
if hasattr ( mw_instance , 'process_exception' ) :
if hasattr ( mw_instance , 'process_request' ) :
if hasattr ( mw_instance , 'process_response' ) :
if hasattr ( mw_instance , 'process_template_response' ) :
if hasattr ( mw_instance , 'process_view' ) :
if hasattr ( os , 'chmod' ) :
if hasattr ( os , 'utime' ) :
if hasattr ( os . path , 'samefile' ) :
if hasattr ( out , 'isatty' ) and out . isatty ( ) :
if hasattr ( parent , 'render' ) :
if hasattr ( pattern , '_callback_str' ) :
if hasattr ( rel_model , 'natural_key' ) and rel_model != model :
if hasattr ( rel_model , 'natural_key' ) and rel_model != model :
if hasattr ( request , 'session' ) :
if hasattr ( request , 'urlconf' ) :
if hasattr ( response , 'render' ) and callable ( response . render ) :
if hasattr ( response , 'render' ) and callable ( response . render ) :
if hasattr ( response , 'render' ) and callable ( response . render ) :
if hasattr ( self , '_body' ) :
if hasattr ( self , '_choices' ) :
if hasattr ( self , '_coerce' ) :
if hasattr ( self , '_files' ) :
if hasattr ( self , '_files' ) :
if hasattr ( self , '_get' ) :
if hasattr ( self , '_post' ) :
if hasattr ( self , '_regex_validator' ) and self . _regex_validator in self . validators :
if hasattr ( self , '_size' ) :
if hasattr ( self , 'clean_%s' % name ) :
if hasattr ( self , 'error_dict' ) :
if hasattr ( self , 'error_dict' ) :
if hasattr ( self . data , 'tzinfo' ) and self . data . tzinfo :
if hasattr ( self . file , 'name' ) :
if hasattr ( self . file , 'size' ) :
if hasattr ( self . file , 'tell' ) and hasattr ( self . file , 'seek' ) :
if hasattr ( settings , "SERIALIZATION_MODULES" ) :
if hasattr ( signal , 'SIGTTOU' ) :
if hasattr ( TemplateLoader , 'load_template_source' ) :
if hasattr ( test_runner_class , 'add_arguments' ) :
if hasattr ( test_runner_class , 'option_list' ) :
if hasattr ( text , '__html__' ) :
if hasattr ( timezone , 'localize' ) :
if hasattr ( timezone , 'normalize' ) :
if hasattr ( value , '__iter__' ) and not isinstance ( value , ( bytes , six . string_types ) ) :
if hasattr ( value , '__iter__' ) and not isinstance ( value , six . text_type ) :
if hasattr ( value , '_meta' ) :
if hasattr ( value , 'close' ) :
if hasattr ( value , 'close' ) :
if header == 'ACCEPT_LANGUAGE' and is_accept_language_redundant :
if header_end == - 1 :
if headerlist is not None :
if help_texts and f . name in help_texts :
if help_texts is not None :
if hextet . count ( '.' ) == 3 :
if hextets [ index ] == '0' :
if hidden_fields :
if host [ - 1 ] == ']' :
if html :
if html_message :
if html_message :
if httponly :
if i :
if i % 2 :
if i + 1 < len ( chunks ) :
if i < 0 :
if i < len(z):
if i < self . initial_form_count ( ) and 'instance' not in kwargs :
if i == int(byte.encode('hex'), 16):
if i > sys . maxint :
if i >= 0 :
if i >= len ( subject ) :
if i >= len ( subject ) :
if i >= len ( subject ) :
if i >= len ( subject ) :
if i >= self . initial_form_count ( ) and i >= self . min_num :
if i >= self . initial_form_count ( ) and not form . has_changed ( ) :
if i >= self . initial_form_count ( ) and self . initial_extra :
if id_ :
if id_ :
if id_ :
if id_for_label :
if idstring is None :
if ignore :
if ignore and field_name not in model_fields :
if ignore_failures :
if illegal_formatting :
if imatch :
if imatch . group ( 2 ) :
if in_tag and not self . verbatim :
if in_tag and token_string . startswith ( BLOCK_TAG_START ) :
if incomment :
if incremental :
if indent :
if index < 0 :
if index is not None :
if index is not None and index < self . initial_form_count ( ) :
if index_sql :
if indexes [ column_name ] [ 'primary_key' ] :
if initial == 'False' :
if initial is None :
if initial is not None :
if initial_forms > self . max_num >= 0 :
if inplural :
if input_formats is not None :
if input_val in special_floats :
if instance . pk is None :
if instance is None :
if instance is None :
if instance is not None :
if int ( hextet , 16 ) < 0x0 or int ( hextet , 16 ) > 0xFFFF :
if interactive :
if invalid_apps :
if invalid_var_format_string :
if invalid_var_format_string is None :
if inverse_match is not None :
if ip_str . count ( '::' ) == 1 :
if ip_str . count ( '::' ) > 1 :
if ip_str . count ( ':' ) > 7 :
if ip_str . count ( '.' ) != 3 :
if ipv4_unpacked :
if iri is None :
if is_aware ( date ) :
if is_aware ( o ) :
if is_aware ( value ) :
if is_compressed :
if is_ignored ( file_path , self . ignore_patterns ) :
if is_ignored ( os . path . normpath ( os . path . join ( dirpath , dirname ) ) , norm_patterns ) :
if is_library_missing ( taglib_module ) :
if is_naive ( obj ) :
if is_protected_type ( value ) :
if is_relation :
if is_relation :
if is_templatized :
if isinstance ( addr , six . string_types ) :
if isinstance ( app_name , BaseCommand ) :
if isinstance ( app_name , BaseCommand ) :
if isinstance ( arg , Promise ) :
if isinstance ( arg , unicode ) :
if isinstance ( attachment , MIMEBase ) :
if isinstance ( attr , MovedModule ) :
if isinstance ( boundary , six . text_type ) :
if isinstance ( cache , BaseDatabaseCache ) :
if isinstance ( callback , functools . partial ) :
if isinstance ( callback , types . FunctionType ) :
if isinstance ( choice_label , ( tuple , list ) ) :
if isinstance ( content , EmailMessage ) :
if isinstance ( context , Context ) :
if isinstance ( context , Context ) :
if isinstance ( current , BaseContext ) and getattr ( type ( current ) , bit ) :
if isinstance ( d , real_datetime ) :
if isinstance ( data , ( MultiValueDict , MergeDict ) ) :
if isinstance ( data , ( MultiValueDict , MergeDict ) ) :
if isinstance ( data , bytes ) :
if isinstance ( data , bytes ) :
if isinstance ( elt , ( Choice , NonCapture ) ) :
if isinstance ( elt , Group ) :
if isinstance ( elt , NonCapture ) :
if isinstance ( elt , six . string_types ) :
if isinstance ( empty_label , ( list , tuple ) ) :
if isinstance ( end , unicode ) :
if isinstance ( error , ValidationError ) :
if isinstance ( expires , datetime . datetime ) :
if isinstance ( f , ManyToManyField ) :
if isinstance ( f , models . FileField ) :
if isinstance ( field , FileField ) :
if isinstance ( field , InlineForeignKeyField ) :
if isinstance ( field , models . TimeField ) and getattr ( obj , field . name ) is not None :
if isinstance ( field_value , str ) :
if isinstance ( file , six . string_types ) :
if isinstance ( file_name , Template ) :
if isinstance ( filename , MIMEBase ) :
if isinstance ( form . _meta . fields , tuple ) :
if isinstance ( format_module_path , six . string_types ) :
if isinstance ( item . get ( 'unique_id_is_permalink' ) , bool ) :
if isinstance ( level , int ) :
if isinstance ( loader , ( tuple , list ) ) :
if isinstance ( loader , six . string_types ) :
if isinstance ( message , dict ) :
if isinstance ( message , SafeData ) :
if isinstance ( message , SafeData ) :
if isinstance ( message , ValidationError ) :
if isinstance ( node , Node ) :
if isinstance ( nodelist , NodeList ) and not isinstance ( node , TextNode ) :
if isinstance ( number , int ) :
if isinstance ( number , int ) and not use_grouping and not decimal_pos :
if isinstance ( o , datetime . datetime ) :
if isinstance ( obj , datetime . datetime ) :
if isinstance ( obj , models . signals . ModelSignal ) :
if isinstance ( offset , timedelta ) :
if isinstance ( offset , timedelta ) :
if isinstance ( option_label , ( list , tuple ) ) :
if isinstance ( other , BaseContext ) :
if isinstance ( other , Promise ) :
if isinstance ( other , Promise ) :
if isinstance ( other_dict , MultiValueDict ) :
if isinstance ( path , six . string_types ) :
if isinstance ( pattern , RegexURLResolver ) :
if isinstance ( pk , OneToOneField ) or isinstance ( pk , ForeignKey ) :
if isinstance ( query , MultiValueDict ) :
if isinstance ( query_string , bytes ) :
if isinstance ( receiver , types . FunctionType ) :
if isinstance ( regex , six . string_types ) :
if isinstance ( rhs , dict ) and number :
if isinstance ( rhs , SafeData ) :
if isinstance ( rhs , SafeText ) :
if isinstance ( s , ( SafeData , EscapeData ) ) :
if isinstance ( s , ( six . text_type , Promise ) ) :
if isinstance ( s , bytes ) :
if isinstance ( s , bytes ) :
if isinstance ( s , bytes ) :
if isinstance ( s , bytes ) or ( isinstance ( s , Promise ) and s . _delegate_bytes ) :
if isinstance ( s , Exception ) :
if isinstance ( s , Promise ) :
if isinstance ( s , Promise ) :
if isinstance ( s , SafeData ) :
if isinstance ( s , six . memoryview ) :
if isinstance ( s , six . text_type ) :
if isinstance ( self , nodetype ) :
if isinstance ( self . _regex , six . string_types ) :
if isinstance ( self . data , datetime . datetime ) and is_aware ( self . data ) :
if isinstance ( self . regex , six . string_types ) :
if isinstance ( self . urlconf_name , list ) and len ( self . urlconf_name ) :
if isinstance ( self . var , Variable ) :
if isinstance ( self . warning , Exception ) :
if isinstance ( sep , unicode ) :
if isinstance ( server , six . string_types ) :
if isinstance ( settings . TIME_ZONE , six . string_types ) and pytz is not None :
if isinstance ( slots , str ) :
if isinstance ( source , Group ) :
if isinstance ( source , inst ) :
if isinstance ( source , NonCapture ) :
if isinstance ( stream_or_string , bytes ) :
if isinstance ( stream_or_string , bytes ) :
if isinstance ( stream_or_string , six . string_types ) :
if isinstance ( stream_or_string , six . string_types ) :
if isinstance ( template , ( list , tuple ) ) :
if isinstance ( template_name , ( list , tuple ) ) :
if isinstance ( timezone , tzinfo ) :
if isinstance ( title , ( list , tuple ) ) :
if isinstance ( unicode_value , six . text_type ) :
if isinstance ( v , ( list , tuple ) ) :
if isinstance ( val , tuple ) :
if isinstance ( value , ( decimal . Decimal , float ) + six . integer_types ) :
if isinstance ( value , bool ) :
if isinstance ( value , bytes ) :
if isinstance ( value , datetime . date ) :
if isinstance ( value , datetime . date ) :
if isinstance ( value , datetime . datetime ) :
if isinstance ( value , datetime . datetime ) :
if isinstance ( value , datetime . time ) :
if isinstance ( value , Field ) :
if isinstance ( value , list ) :
if isinstance ( value , list ) :
if isinstance ( value , six . string_types ) :
if isinstance ( value , six . string_types ) :
if isinstance ( value , six . string_types ) and value != ALL_FIELDS :
if isinstance ( value , six . string_types ) and value . lower ( ) in ( 'false' , '0' ) :
if isinstance ( value , six . text_type ) :
if isinstance ( value , str ) :
if isinstance ( widget , NumberInput ) :
if isinstance ( widget , NumberInput ) and 'step' not in widget . attrs :
if isinstance ( widget , NumberInput ) and 'step' not in widget . attrs :
if isinstance ( widget , type ) :
if iso_input not in val :
if issubclass ( klass , logging . handlers . MemoryHandler ) and 'target' in config :
if issues :
if item [ 'author_email' ] is not None :
if item [ 'author_link' ] is not None :
if item [ 'author_name' ] is not None :
if item [ 'comments' ] is not None :
if item [ 'description' ] is not None :
if item [ 'enclosure' ] is not None :
if item [ 'enclosure' ] is not None :
if item [ 'item_copyright' ] is not None :
if item [ 'pubdate' ] is not None :
if item [ 'pubdate' ] is not None :
if item [ 'ttl' ] is not None :
if item [ 'unique_id' ] is not None :
if item [ 'updateddate' ] is not None :
if item [ "author_name" ] and item [ "author_email" ] :
if item_date :
if item_type == FIELD :
if iterator is None :
if j == - 1 :
if jan1_weekday == 5 or ( jan1_weekday == 6 and calendar . isleap ( self . data . year - 1 ) ) :
if jan1_weekday > 4 :
if json . __version__ . split ( '.' ) >= [ '2' , '1' , '3' ] :
if k [ 1 ] is None :
if k == 'fg' :
if k in seen :
if key . startswith ( self . prefix ) :
if key in cache :
if key in d :
if key in dict_ :
if key not in default_settings :
if key not in self :
if key not in self :
if key_func is not None :
if key_prefix is None :
if keys :
if keyword . iskeyword ( new_name ) :
if klass not in cls . __dispatch :
if kw [ 'microsecond' ] :
if kwarg :
if kwarg_format :
if kwargs :
if kwargs . get ( 'localize' ) and self . widget == NumberInput :
if kwargs . get ( k , v ) != v :
if kwargs . pop ( 'ipv6' , False ) :
if kwargs [ 'setting' ] in ( 'LANGUAGES' , 'LANGUAGE_CODE' ) :
if kwargs is None :
if kwds :
if label_output :
if label_suffix and contents and contents [ - 1 ] not in _ ( ':?.!' ) :
if label_suffix is None :
if labels and f . name in labels :
if labels is not None :
if lang is None :
if lang_code :
if lang_code in _supported and lang_code is not None and check_for_language ( lang_code ) :
if lang_code is not None :
if lang_code not in _supported and replacement in _supported :
if language in _DJANGO_DEPRECATED_LOCALES :
if language not in _translations :
if language_code not in self . _app_dict :
if language_code not in self . _namespace_dict :
if language_code not in self . _regex_dict :
if language_code not in self . _reverse_dict :
if last == 1 :
if last == 2 :
if last == 3 :
if last_bit :
if latest_date is None or item_date > latest_date :
if leading :
if len ( app_labels ) == 0 :
if len ( app_labels ) == 1 :
if len ( app_labels ) > 1 and primary_keys :
if len ( args ) != 2 :
if len ( args ) != len ( params ) + len ( prefix_args ) :
if len ( args ) < 2 :
if len ( args ) == 2 :
if len ( args ) > 1 :
if len ( args ) > 4 :
if len ( bits ) :
if len ( bits ) != 2 :
if len ( bits ) != 2 :
if len ( bits ) != 3 :
if len ( bits ) != 6 :
if len ( bits ) < 1 :
if len ( bits ) < 2 :
if len ( bits ) < 2 or bits [ - 2 ] != 'as' :
if len ( bits ) < 3 or bits [ 1 ] != 'as' :
if len ( bits ) < 4 :
if len ( bits ) == 2 :
if len ( bits ) == 3 :
if len ( bits ) == 4 :
if len ( bits ) > 2 :
if len ( bits ) >= 2 and bits [ - 2 ] == 'as' :
if len ( bits ) >= 4 and bits [ - 2 ] == "from" :
if len ( bits ) not in ( 2 , 3 ) :
if len ( compressed ) < ( len ( data ) - 1 ) :
if len ( fixture_files_in_dir ) > 1 :
if len ( fks_to_parent ) == 1 :
if len ( fks_to_parent ) == 1 :
if len ( hextet ) > 1 :
if len ( initial ) != len ( data ) :
if len ( initial ) != len ( data ) :
if len ( key ) > MEMCACHE_MAX_KEY_LENGTH :
if len ( language [ p + 1 : ] ) > 2 :
if len ( list_ ) == 0 :
if len ( list_ ) == 1 :
if len ( name ) > 255 :
if len ( new_operations ) == len ( operations ) :
if len ( parts ) > 1 :
if len ( parts ) > 1 and parts [ - 1 ] in self . compression_formats :
if len ( password ) > inner . block_size :
if len ( s ) > 13 :
if len ( self . _cache ) >= self . _max_entries :
if len ( self . dicts ) == 1 :
if len ( self . namelist ( ) ) != 1 :
if len ( t ) == 2 :
if len ( t ) > 1 :
if len ( tablenames ) :
if len ( unique_check ) == 1 :
if len ( val1 ) != len ( val2 ) :
if len ( value ) != 1 :
if len ( value ) != 2 :
if len ( value ) >= 2 and value [ : 1 ] == value [ - 1 : ] == b'"' :
if len ( words ) > length :
if len(m) % 4 != 0:
if len(shell) >= 100:
if len(sys.argv) != 3:
if len(sys.argv) != 3:
if len(sys.argv) < 2:
if len(sys.argv) < 3:
if len(sys.argv) < 3:
if len(sys.argv) > 1:
if level is not None :
if level not in logging . _levelNames :
if lib :
if limit is None or len ( x ) <= limit :
if limit_choices_to is not None :
if line :
if line . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
if line [ - 1 : ] in ( b'\n' , b'\r' ) :
if link is not None :
if literal_match :
if loader is not None :
if locales :
if locales :
if localized_fields == ALL_FIELDS or ( localized_fields and f . name in localized_fields ) :
if localized_fields is not None :
if location is None :
if location is None :
if locations :
if log in child_loggers :
if logging_config :
if logging_settings :
if lookup == 'date' :
if lookup_view in self . _callback_strs :
if m :
if m . group ( 1 ) :
if m is None :
if m is not None :
if m is not None and n is not None :
if match :
if match :
if max_age is not None :
if max_length is not None :
if max_num is None :
if max_value is not None :
if maxsize == 0 :
if media :
if mem_args in cache :
if member . isdir ( ) :
if memo is None :
if message :
if message is not None :
if message is not None :
if message_context :
if message_context [ 0 ] == '"' :
if meta is None :
if middle . endswith ( punctuation ) :
if middle . startswith ( opening ) :
if migration . replaces :
if migration_name == "zero" :
if mime_encode :
if mimetype is None :
if min_length is not None :
if min_num is None :
if min_value is not None :
if missing_fields :
if model in created_models :
if model in excluded_models :
if model not in app_list_value :
if model_list is None :
if module_has_submodule ( app_config . module , "management" ) :
if module_has_submodule ( app_config . module , module_to_search ) :
if months :
if msg :
if msgs :
if name :
if name . lower ( ) == 'subject' :
if name . lower ( ) in ( 'from' , 'to' ) :
if name . lower ( ) in ADDRESS_HEADERS :
if name . startswith ( '.' ) :
if name == 'content-disposition' :
if name == 'regex' :
if name == "_wrapped" :
if name in existing :
if name in lib . filters :
if name in lib . tags :
if name in MEDIA_TYPES :
if name is None :
if name is None :
if name is None and compile_function is None :
if name is None and filter_func is None :
if name is not None :
if name not in data :
if name not in logging . _handlers :
if name not in parser . _namedCycleNodes :
if namespaces :
if neg :
if new is None :
if new_attr is None :
if new_conn_created :
if new_mod is None :
if new_name != col_name :
if new_name . endswith ( '_' ) :
if new_name . endswith ( '_id' ) :
if new_name . find ( '__' ) >= 0 :
if new_name . startswith ( '_' ) :
if new_name [ 0 ] . isdigit ( ) :
if new_name in used_column_names :
if new_value == value :
if newretval is not None :
if next_item and isinstance ( next_item , ( list , tuple ) ) :
if node . getElementsByTagName ( 'None' ) :
if node . hasAttribute ( 'pk' ) :
if node . must_be_first and nodelist :
if nodelist :
if nodelist . contains_nontext :
if nodelist . get_nodes_by_type ( ExtendsNode ) :
if nodelist_empty is None :
if not _cached_filenames and settings . USE_I18N :
if not _cookie_allows_colon_in_names :
if not _cookie_encodes_correctly :
if not _is_shorthand_ip ( ip_str ) :
if not _serializers :
if not _serializers :
if not ( bits . scheme and bits . netloc ) :
if not ( self . data or self . files ) :
if not ( self . inverse_match is not bool ( self . regex . search (  force_text ( value ) ) ) ) :
if not ( value is True or value is False or value is None or value == '' ) :
if not allow_overwrite and os . access ( new_file_name , os . F_OK ) :
if not answer :
if not app_config . path :
if not app_labels :
if not args :
if not attr_list [ 3 ] & termios . ECHO :
if not autoescape or isinstance ( value , SafeData ) :
if not basedirs :
if not bits :
if not boundary or not cgi . valid_boundary ( boundary ) :
if not buf :
if not bytes :
if not callable ( getattr ( template , 'render' , None ) ) :
if not callable ( original_lookup ) and callable ( lookup_view ) :
if not callable ( view_func ) :
if not callback :
if not candidate :
if not changed :
if not changes and self . verbosity >= 1 :
if not check_for_language ( lang ) :
if not chunk :
if not chunk [ : - rollback ] :
if not chunk_size :
if not chunks :
if not cleaned_line :
if not cls :
if not commit :
if not commit :
if not config_string :
if not content_type :
if not content_type . startswith ( 'multipart/' ) :
if not context_instance :
if not data :
if not data :
if not data and initial :
if not dictionary :
if not digest :
if not directory_created . get ( app_label , False ) :
if not dklen :
if not e . connection_reset :
if not email_message . recipients ( ) :
if not email_messages :
if not encoding :
if not etags :
if not expires :
if not ext . startswith ( '.' ) :
if not ext and content_type :
if not extra_context :
if not f . blank and not form_field . required and field_value in form_field . empty_values :
if not f . editable or isinstance ( f , models . AutoField ) or f . name not in cleaned_data :
if not field . show_hidden_initial :
if not field_desc . endswith ( '(' ) :
if not field_name :
if not file_name :
if not filename :
if not fname . startswith ( self . _dir ) or not os . path . exists ( fname ) :
if not form . has_changed ( ) :
if not form . is_valid ( ) :
if not formset . is_valid ( ) :
if not found and ( not line or plural_forms_re . search ( line ) ) :
if not func . is_usable :
if not func_name :
if not getattr ( f , 'editable' , False ) :
if not getattr ( self , 'nodelist' , False ) :
if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
if not hasattr ( c , '__call__' ) and hasattr ( types , 'ClassType' ) and type ( c ) != types . ClassType :
if not hasattr ( callback , '__name__' ) :
if not hasattr ( content , 'chunks' ) :
if not hasattr ( e , 'django_template_source' ) :
if not hasattr ( f , 'save_form_data' ) :
if not hasattr ( func , '__name__' ) :
if not hasattr ( mail , 'outbox' ) :
if not hasattr ( obj , "_meta" ) :
if not hasattr ( other_dict , '__getitem__' ) :
if not hasattr ( package , 'rindex' ) :
if not hasattr ( parser , '_namedCycleNodes' ) :
if not hasattr ( self , '_body' ) :
if not hasattr ( self , '_deleted_form_indexes' ) :
if not hasattr ( self , '_dimensions_cache' ) :
if not hasattr ( self , '_files' ) :
if not hasattr ( self , '_fqdn' ) :
if not hasattr ( self , '_object_dict' ) :
if not hasattr ( self , '_ordering' ) :
if not hasattr ( self , '_post' ) :
if not hasattr ( self , '_queryset' ) :
if not hasattr ( self , '_request' ) :
if not hasattr ( self , 'bad_cookies' ) :
if not hasattr ( template , 'render' ) :
if not hasattr ( template , 'render' ) :
if not hasattr ( translation , '_catalog' ) :
if not hasattr ( values , '__len__' ) :
if not hextets [ index ] :
if not host_validation_re . match ( host ) :
if not include_is_allowed ( filepath ) :
if not incremental :
if not indent :
if not inhibit_post_migrate :
if not ip_str . lower ( ) . startswith ( '0000:0000:0000:0000:0000:ffff:' ) :
if not ip_str . split ( ':' ) [ - 1 ] == hextet :
if not is_valid_ipv6_address ( ip_str ) :
if not is_valid_ipv6_address ( value ) :
if not isabs ( path ) :
if not isinstance ( candidate , six . string_types ) :
if not isinstance ( cookie , http_cookies . BaseCookie ) :
if not isinstance ( d , datetime . datetime ) :
if not isinstance ( data , basestring ) :
if not isinstance ( e , CommandError ) :
if not isinstance ( error , ValidationError ) :
if not isinstance ( fk , ForeignKey ) or ( fk . rel . to != parent_model and  fk . rel . to not in parent_model . _meta . get_parent_list ( ) ) :
if not isinstance ( i , six . integer_types ) :
if not isinstance ( index , ( slice , ) + six . integer_types ) :
if not isinstance ( initial , list ) :
if not isinstance ( item , ( list , tuple ) ) :
if not isinstance ( list_ , ( tuple , list ) ) or len ( list_ ) != 2 :
if not isinstance ( message , ValidationError ) :
if not isinstance ( messages , ValidationError ) :
if not isinstance ( node , ExtendsNode ) :
if not isinstance ( node , TextNode ) :
if not isinstance ( s , Exception ) :
if not isinstance ( s , six . string_types ) :
if not isinstance ( s , six . string_types ) :
if not isinstance ( self . file_path , six . string_types ) :
if not isinstance ( self . object_list , list ) :
if not isinstance ( stream_or_string , ( bytes , six . string_types ) ) :
if not isinstance ( urlconf_name , six . string_types ) :
if not isinstance ( value , ( bytes , six . text_type ) ) :
if not isinstance ( value , ( list , tuple ) ) :
if not isinstance ( value , ConvertingDict ) and isinstance ( value , dict ) :
if not isinstance ( value , list ) :
if not isinstance ( var , six . string_types ) :
if not isinstance ( viewname , six . string_types ) :
if not kwarg_format :
if not language_code_re . search ( accept_lang ) :
if not language_code_re . search ( lang_code ) :
if not last_row . endswith ( row_ender ) :
if not len ( empty_label ) == 3 :
if not len ( self . backout ) :
if not lib :
if not locale_dir :
if not lookup :
if not m :
if not m :
if not m and p < 0 :
if not match :
if not match :
if not matched_a_byte:
if not matches :
if not model . _meta . proxy and router . allow_migrate ( using , model ) :
if not model_identifier :
if not name :
if not nesting :
if not new_method and old_method :
if not now :
if not old_method and new_method :
if not old_style_list :
if not only_initial :
if not options . get ( 'addrport' ) :
if not options [ 'no_startup' ] :
if not os . access ( filename , os . W_OK ) :
if not os . access ( self . file_path , os . W_OK ) :
if not os . path . exists ( directory ) :
if not os . path . exists ( filename ) :
if not os . path . exists ( potfile ) :
if not os . path . exists ( self . _dir ) :
if not os . path . exists ( self . _dir ) :
if not os . path . exists ( self . default_locale_path ) :
if not os . path . exists ( top_dir ) :
if not os . path . isdir ( basedir ) :
if not os . path . isdir ( directory ) :
if not os . path . isdir ( migrations_directory ) :
if not os . path . isfile ( init_path ) :
if not os . path . isfile ( pythonrc ) :
if not package :
if not parent :
if not path . exists ( target_dir ) :
if not path_info :
if not plan :
if not prefix :
if not prefix . endswith ( '/' ) :
if not prefix or not hasattr ( self , '_callback_str' ) :
if not priority :
if not pythonrc :
if not qs . ordered :
if not re . search ( r'^[_a-zA-Z]' , name ) :
if not re . search ( r'^[_a-zA-Z]\w*$' , name ) :
if not regex_match :
if not renamed :
if not response . has_header ( 'Cache-Control' ) :
if not response . has_header ( 'Expires' ) :
if not response . has_header ( 'Last-Modified' ) :
if not response . has_header ( 'Vary' ) :
if not response . streaming :
if not rest :
if not roots :
if not router . allow_migrate ( database , cache . cache_model_class ) :
if not script_url :
if not self :
if not self . _cached_loaders :
if not self . _css . get ( medium ) or path not in self . _css [ medium ] :
if not self . _has_expired ( key ) :
if not self . _has_expired ( key ) :
if not self . _is_expired ( f ) :
if not self . _is_rendered :
if not self . _is_rendered :
if not self . _mutable :
if not self . _populated :
if not self . _upload_handlers :
if not self . activated :
if not self . addr :
if not self . allow_empty_file and not file_size :
if not self . allow_multiple_selected :
if not self . can_import_settings :
if not self . close_called :
if not self . closed :
if not self . compile_filter_error ( token , e ) :
if not self . compile_function_error ( token , e ) :
if not self . connection :
if not self . data :
if not self . DIGIT_PATTERN . match ( idx ) :
if not self . dry_run :
if not self . fail_silently :
if not self . fail_silently :
if not self . first :
if not self . form . is_bound :
if not self . initial_forms :
if not self . invoked_for_django :
if not self . is_bound :
if not self . is_required :
if not self . is_required :
if not self . is_required and CheckboxInput ( ) . value_from_datadict (  data , files , self . clear_checkbox_name ( name ) ) :
if not self . is_valid ( ) :
if not self . is_valid ( ) or not self . can_delete :
if not self . is_valid ( ) or not self . can_order :
if not self . keep_pot :
if not self . leave_locale_alone :
if not self . port . isdigit ( ) :
if not self . recipients ( ) :
if not self . render_value :
if not self . required :
if not self . timezone :
if not self . timezone :
if not self . use_argparse :
if not self . use_natural_primary_keys or not hasattr ( obj , 'natural_key' ) :
if not self . use_natural_primary_keys or not hasattr ( obj , 'natural_key' ) :
if not self . use_ssl and self . use_tls :
if not self . user_regex . match ( user_part ) :
if not self . valid_value ( val ) :
if not settings . ADMINS :
if not settings . configured :
if not settings . DEBUG and not settings . ALLOWED_HOSTS :
if not settings . is_overridden ( 'MIDDLEWARE_CLASSES' ) :
if not settings . is_overridden ( 'TEST_RUNNER' ) :
if not settings . MANAGERS :
if not shown :
if not squash :
if not strict :
if not support_legacy :
if not supported_platform or not is_a_tty :
if not supports_color ( ) :
if not sys . warnoptions :
if not table_name_filter ( table_name ) :
if not tag or current_len >= truncate_len :
if not template_dirs :
if not template_name_list :
if not templatetags_modules :
if not token . contents :
if not unicodedata . combining ( char ) :
if not unused_char :
if not url :
if not url_fields [ 0 ] :
if not url_fields [ 1 ] :
if not url_info . netloc and url_info . scheme :
if not use_workaround :
if not UserModel . _default_manager . exists ( ) and options . get ( 'interactive' ) :
if not using_sysrandom :
if not value :
if not value :
if not value and self . required :
if not value or '@' not in value :
if not value or isinstance ( value , ( list , tuple ) ) :
if not value or not [ v for v in value if v not in self . empty_values ] :
if not var or ' ' in var :
if not want_unicode :
if not widget :
if not_installed_models :
if now and not isinstance ( now , datetime . datetime ) :
if ns_pattern :
if num > self . _max_entries :
if num_entries < self . _max_entries :
if num_loopvars != len_item :
if num_repl > 0 :
if number < 1 :
if number == 1 :
if number == 1 and self . allow_empty_first_page :
if number > self . num_pages :
if number_equal > 40 :
if o . microsecond :
if o in opt_dict :
if obj . pk is None :
if obj_list is None :
if obj_pk is not None :
if objects_in_fixture == 0 :
if offset is not None :
if old_attr is None :
if old_field_name :
if old_handler is not None :
if old_style_list :
if only_django :
if only_new :
if opname not in roots :
if option [ 1 ] :
if option == 'with' :
if option in options :
if option_value in selected_choices :
if option_value is None :
if options :
if options . get ( 'list_tags' ) :
if options . get ( 'liveserver' ) is not None :
if options . get ( 'load_initial_data' ) :
if options . get ( 'no_color' ) :
if options . get ( 'no_location' ) :
if options . get ( 'no_wrap' ) :
if options . get ( 'use_default_ignore_patterns' ) :
if options . get ( "list" , False ) :
if options . get ( "test_flush" , False ) :
if options . pythonpath :
if options . settings :
if options . traceback or not isinstance ( e , CommandError ) :
if options [ 'app_label' ] and options [ 'migration_name' ] :
if options [ 'errlog' ] :
if options [ 'method' ] in ( 'prefork' , 'fork' ) :
if options [ 'outlog' ] :
if options [ 'plain' ] :
if options [ 'umask' ] :
if options [ 'verbosity' ] > 0 :
if options [ "daemonize" ] . lower ( ) in ( 'true' , 'yes' , 't' ) :
if options [ "daemonize" ] is None :
if options [ "host" ] and options [ "port" ] and not options [ "socket" ] :
if options [ "pidfile" ] :
if opts :
if opts . fields == ALL_FIELDS :
if opts . fields is None and opts . exclude is None :
if opts . managed :
if opts . model :
if opts . model is None :
if ord ( char ) < 33 or ord ( char ) == 127 :
if origin :
if os . environ . get ( 'DJANGO_SETTINGS_MODULE' ) :
if os . environ . get ( "RUN_MAIN" ) == "true" :
if os . fork ( ) > 0 :
if os . name == 'nt' :
if os . name == 'nt' :
if os . name == 'nt' :
if os . name == 'posix' :
if os . path . abspath ( dirpath ) . startswith ( os . path . dirname ( path ) ) :
if os . path . basename ( candidate ) in targets :
if os . path . exists ( django_po ) :
if os . path . exists ( filename ) :
if os . path . exists ( fname ) :
if os . path . exists ( name ) :
if os . path . exists ( old_app_dir ) :
if os . path . exists ( pofile ) :
if os . path . exists ( pot_path ) :
if os . path . exists ( potfile ) :
if os . path . exists ( self . file_path ) and not os . path . isdir ( self . file_path ) :
if os . path . exists ( sql_file ) :
if os . path . isabs ( fixture_name ) :
if os . path . isdir ( 'locale' ) :
if os . path . isdir ( app_dir ) :
if os . path . isdir ( entry ) :
if os . path . isdir ( os . path . join ( 'conf' , 'locale' ) ) :
if os . path . isdir ( os . path . join ( path , entry ) ) :
if os . path . isdir ( template_dir ) :
if os . path . isfile ( f ) :
if os . path . isfile ( fext ) :
if os . path . sep in fixture_name :
if out_log :
if output :
if over_bytes :
if p . find ( ':_(' ) >= 0 :
if p . image :
if p == 0 :
if p >= 0 :
if padding:
if padding:
if padding:
if padding:
if palette == PALETTES [ NOCOLOR_PALETTE ] :
if param :
if param in unhandled_params :
if param not in params and varkw is None :
if params . get ( 'filename' ) :
if params [ 0 ] == 'context' :
if parse_until :
if parse_until is None :
if parsed . scheme and parsed . scheme not in self . allowed_schemes :
if part in PALETTES :
if parts [ - 1 ] in self . serialization_formats :
if path . exists ( absolute_path ) :
if path . exists ( new_path ) :
if path . isdir ( expanded_template ) :
if path . isfile ( path_to_remove ) :
if path . startswith ( ( 'http://' , 'https://' , '/' ) ) :
if path is None :
if path is None :
if path is not None :
if path not in self . _js :
if pathext is None :
if pattern . app_name :
if pattern . name is not None :
if pattern . namespace :
if pickled is not None :
if pieces [ - 1 ] :
if pk_is_not_editable ( pk ) or pk . name not in form . fields :
if pks :
if plan :
if plan_node in loader . applied_migrations :
if plan_node not in shown and plan_node [ 0 ] == app_name :
if plen < ( alen - dlen ) or plen > alen :
if pop_context :
if pos >= last :
if prefix is None :
if primary_keys :
if primary_keys :
if print_ is None :
if priority :
if process_all :
if processors is None :
if propagate is not None :
if props :
if proto >= 2 :
if protocol != 'both' and unpack_ipv4 :
if push is not None :
if PY3 :
if PY3 :
if qs . _result_cache is not None :
if queryset is None :
if questioner . ask_merge ( app_label ) :
if quote_double_quotes :
if r . endswith ( '+00:00' ) :
if re . search ( '^%s%s' % ( prefix_norm , pattern ) , candidate_pat % candidate_subs , re . UNICODE ) :
if reason is not None :
if record . exc_info :
if recursive :
if reduce ( operator . eq , level ) :
if refto in known_models :
if refto in seen_models :
if regex is not None :
if register_to :
if rel_to in known_models :
if related :
if related_att is not None :
if relative_dir :
if remaining is None :
if remaining_bits :
if renderer :
if representative is None :
if request . _post_parse_error :
if request . method == 'HEAD' :
if required and ( initial is not None ) :
if resolved_path :
if resolver . urlconf_module is None :
if resource_string is not None :
if response :
if response . has_header ( 'Cache-Control' ) :
if response . has_header ( 'Vary' ) :
if response . has_header ( 'Vary' ) :
if response . streaming :
if response is None :
if result :
if result and ( mode == 'set' or ( mode == 'add' and current_expires < now ) ) :
if result is not None :
if result is not None :
if result is not root :
if ret :
if retval :
if reverse :
if rot < 1:
if row [ 6 ] :
if row is None :
if row_data and None not in row_data :
if row_data in seen_data :
if run_syncdb and executor . loader . unmigrated_apps :
if run_syncdb and executor . loader . unmigrated_apps :
if s [ 0 ] not in "\"'" or s [ - 1 ] != s [ 0 ] :
if s == '"' :
if s_len > length :
if safe :
if safe and arg != ';' :
if safe and not isinstance ( data , dict ) :
if safe is not None :
if safe_input :
if saved_locale is not None :
if scheme not in self . schemes :
if schemes is not None :
if script_url :
if second_item == [ ] :
if secret is None :
if secure :
if self . __dispatch is None :
if self . __language == settings . LANGUAGE_CODE :
if self . __language == settings . LANGUAGE_CODE or self . __language == "en-us" :
if self . _callback is not None :
if self . _changed_data is None :
if self . _content_length == 0 :
if self . _count is None :
if self . _cull_frequency == 0 :
if self . _delegate_bytes :
if self . _delegate_bytes and six . PY2 :
if self . _done :
if self . _encoding is None :
if self . _errors is None :
if self . _fname is None :
if self . _has_expired ( key ) :
if self . _is_rendered :
if self . _isdst ( dt ) :
if self . _isdst ( dt ) :
if self . _leftover :
if self . _non_form_errors is None :
if self . _num_pages is None :
if self . _options :
if self . _pk_field == self . fk :
if self . _read_started :
if self . _read_started and not hasattr ( self , '_body' ) :
if self . _request_middleware is None :
if self . _should_delete_form ( form ) :
if self . _should_delete_form ( form ) :
if self . _validate_unique :
if self . _varlist :
if self . _wrapped is empty :
if self . _wrapped is empty :
if self . activated :
if self . active_readers == 0 and self . waiting_writers != 0 :
if self . active_writers == 0 and self . waiting_writers == 0 :
if self . active_writers == 0 and self . waiting_writers == 0 and self . active_readers == 0 :
if self . addr :
if self . allow_files :
if self . allow_folders :
if self . alternatives :
if self . app_label and app_config . label != self . app_label :
if self . args :
if self . asvar :
if self . asvar is None :
if self . attachments :
if self . base_url is None :
if self . body :
if self . callback ( record ) :
if self . can_delete :
if self . can_delete :
if self . can_delete and self . _should_delete_form ( form ) :
if self . can_delete and self . _should_delete_form ( form ) :
if self . can_import_settings :
if self . can_order :
if self . cc :
if self . cdata_tag is not None :
if self . check_test ( value ) :
if self . choices :
if self . cleaned_data . get ( name ) is not None and self . cleaned_data [ name ] . _state . adding :
if self . cmd . _called_from_command_line :
if self . compare ( cleaned , self . limit_value ) :
if self . connection :
if self . connection is None :
if self . connection_reset :
if self . connector == conn_type :
if self . count == 0 and not self . allow_empty_first_page :
if self . current_token is not EndToken :
if self . data . day in ( 11 , 12 , 13 ) :
if self . data . hour == 0 :
if self . data . hour > 11 :
if self . data . hour > 12 :
if self . data . minute == 0 :
if self . data . minute == 0 and self . data . hour == 0 :
if self . data . minute == 0 and self . data . hour == 12 :
if self . deactivate :
if self . decimal_places is not None :
if self . decimal_places is not None and decimals > self . decimal_places :
if self . directory_permissions_mode is not None :
if self . domain == 'djangojs' :
if self . domain == 'djangojs' :
if self . domain not in ( 'django' , 'djangojs' ) :
if self . domain_regex . match ( domain_part ) :
if self . empty :
if self . empty_permitted and not self . has_changed ( ) :
if self . errors and hasattr ( self . form , 'error_css_class' ) :
if self . fail_silently :
if self . feed [ 'author_email' ] is not None :
if self . feed [ 'author_link' ] is not None :
if self . feed [ 'author_name' ] is not None :
if self . feed [ 'feed_copyright' ] is not None :
if self . feed [ 'feed_copyright' ] is not None :
if self . feed [ 'feed_url' ] is not None :
if self . feed [ 'feed_url' ] is not None :
if self . feed [ 'language' ] is not None :
if self . feed [ 'language' ] is not None :
if self . feed [ 'subtitle' ] is not None :
if self . feed [ 'ttl' ] is not None :
if self . field . cache_choices :
if self . field . choice_cache is None :
if self . field . empty_label is not None :
if self . field . label is None :
if self . field . localize :
if self . field . required and hasattr ( self . form , 'required_css_class' ) :
if self . field . required and hasattr ( self . form , 'required_css_class' ) :
if self . field . show_hidden_initial :
if self . file_permissions_mode is not None :
if self . first :
if self . fixture_count == 0 and self . hide_empty :
if self . fk . rel . field_name != self . fk . rel . to . _meta . pk . name :
if self . flags and not isinstance ( self . regex , six . string_types ) :
if self . forms :
if self . has_header ( 'Content-Encoding' ) :
if self . has_key ( key , version ) :
if self . help :
if self . id_for_label :
if self . ignore and field_name not in model_fields :
if self . initial and 'initial' not in kwargs :
if self . instance . pk is None :
if self . instance . pk is not None :
if self . interactive :
if self . is_bound :
if self . is_bound :
if self . is_bound and i < self . initial_form_count ( ) :
if self . is_checked ( ) :
if self . is_localized :
if self . is_reversed :
if self . is_url ( template ) :
if self . isolated_context :
if self . L ( ) and self . data . month > 2 :
if self . language is not None :
if self . load_initial_data :
if self . loaded_object_count > 0 :
if self . locale_paths :
if self . localize :
if self . lookups is not None :
if self . m2m_data and save_m2m :
if self . match is None or self . match_re . search ( f ) :
if self . match is not None :
if self . max_digits is not None and digits > self . max_digits :
if self . max_length is not None :
if self . max_length is not None and len ( file_name ) > self . max_length :
if self . max_value is not None :
if self . merge and conflicts :
if self . merge and not conflicts :
if self . message_context :
if self . META . get ( 'CONTENT_TYPE' , '' ) . startswith ( 'multipart/form-data' ) :
if self . META . get ( header , None ) == value :
if self . method != 'POST' :
if self . min_value is not None :
if self . negated :
if self . no_obsolete :
if self . number == self . paginator . num_pages :
if self . obj is None :
if self . old_timezone is None :
if self . options . get ( 'indent' , None ) is not None :
if self . options . get ( 'indent' ) :
if self . options . get ( "indent" ) :
if self . output_transaction :
if self . paginator . count == 0 :
if self . parent_instance is not None :
if self . parent_name . filters or isinstance ( self . parent_name . var , Variable ) :
if self . parsed :
if self . paths_to_remove :
if self . pk_field :
if self . pos >= len ( self . tokens ) :
if self . queryset is not None :
if self . require_all_fields :
if self . require_all_fields :
if self . required :
if self . required :
if self . required :
if self . required and not value :
if self . save_as_new :
if self . save_as_new :
if self . selected_fields is None or field . attname [ : - 3 ] in self . selected_fields :
if self . selected_fields is None or field . attname in self . selected_fields :
if self . selected_fields is None or field . attname in self . selected_fields :
if self . sep not in signed_value :
if self . setting :
if self . settings_exception is not None :
if self . show_traceback :
if self . silent :
if self . stream is None :
if self . stream is not None :
if self . takes_context :
if self . timeout is not None :
if self . timezone and self . timezone . dst ( self . data ) :
if self . timezone is None :
if self . to_field :
if self . to_field_name :
if self . translate :
if self . use_argparse :
if self . use_ipv6 and not socket . has_ipv6 :
if self . use_natural_foreign_keys and hasattr ( field . rel . to , 'natural_key' ) :
if self . use_natural_foreign_keys and hasattr ( field . rel . to , 'natural_key' ) :
if self . use_natural_foreign_keys and hasattr ( field . rel . to , 'natural_key' ) :
if self . use_natural_keys :
if self . use_ssl and self . use_tls :
if self . username and self . password :
if self . validate_domain_part ( domain_part ) :
if self . variable_name :
if self . verbatim and block_content == self . verbatim :
if self . verbosity > 0 :
if self . verbosity > 0 :
if self . verbosity > 0 or self . interactive :
if self . verbosity > 1 :
if self . verbosity > 1 :
if self . verbosity > 1 :
if self . verbosity >= 1 :
if self . verbosity >= 1 :
if self . verbosity >= 1 :
if self . verbosity >= 1 :
if self . verbosity >= 1 :
if self . verbosity >= 1 :
if self . verbosity >= 1 and sql :
if self . verbosity >= 2 :
if self . verbosity >= 2 :
if self . verbosity >= 2 :
if self . verbosity >= 2 :
if self . verbosity >= 2 :
if self . verbosity >= 2 :
if self . verbosity >= 2 and not fixture_files_in_dir :
if self . verbosity >= 3 :
if self . verbosity >= 3 :
if self . waiting_writers != 0 :
if self not in context . render_context :
if self not in state_frame :
if self_closing or tagname in html4_singlets :
if sender and getattr ( sender , 'handles_files' , False ) :
if sent :
if sep is None :
if sep is not None :
if sequence_sql :
if serializers is None :
if serializers is None and not _serializers :
if server_port != ( '443' if self . is_secure ( ) else '80' ) :
if set ( kwargs . keys ( ) ) | set ( defaults . keys ( ) ) != set ( params ) | set ( defaults . keys ( ) ) | set ( prefix_args ) :
if settings . configured :
if settings . configured :
if settings . DEBUG :
if settings . DEBUG :
if settings . DEBUG :
if settings . DEBUG :
if settings . DEBUG and request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS :
if settings . DEBUG_PROPAGATE_EXCEPTIONS :
if settings . FILE_UPLOAD_TEMP_DIR :
if settings . FORCE_SCRIPT_NAME is not None :
if settings . is_overridden ( 'ADMINS' ) :
if settings . is_overridden ( 'MANAGERS' ) :
if settings . is_overridden ( 'TEMPLATE_LOADERS' ) :
if settings . SECURE_PROXY_SSL_HEADER :
if settings . SETTINGS_MODULE :
if settings . STATIC_URL is None :
if settings . TEMPLATE_DEBUG :
if settings . TEMPLATE_DEBUG and display_name :
if settings . TEMPLATE_DEBUG and origin is None :
if settings . TEMPLATE_STRING_IF_INVALID :
if settings . USE_ETAGS and not response . has_header ( 'ETag' ) :
if settings . USE_I18N :
if settings . USE_I18N or settings . USE_L10N :
if settings . USE_L10N :
if settings . USE_L10N and isinstance ( value , six . string_types ) :
if settings . USE_THOUSAND_SEPARATOR :
if settings . USE_TZ :
if settings . USE_TZ :
if settings . USE_TZ and value is not None and timezone . is_aware ( value ) :
if settings . USE_TZ and value is not None and timezone . is_naive ( value ) :
if settings . USE_X_FORWARDED_HOST and (  'HTTP_X_FORWARDED_HOST' in self . META ) :
if show_traceback :
if shutdown_message :
if sign :
if sign in self . digits :
if simple_url_re . match ( middle ) :
if since <= 0 :
if site in sites2 :
if six . PY2 :
if six . PY2 :
if six . PY2 :
if six . PY2 :
if six . PY2 :
if six . PY2 and isinstance ( rawdata , six . text_type ) :
if six . PY2 and not isinstance ( path , bytes ) :
if six . PY2 and not isinstance ( path , six . text_type ) :
if six . PY2 and value > sys . maxint :
if six . PY3 :
if six . PY3 :
if six . PY3 :
if six . PY3 :
if six . PY3 :
if six . PY3 and isinstance ( val1 , bytes ) and isinstance ( val2 , bytes ) :
if six . PY3 or os . name == 'nt' :
if size :
if size :
if size == 0 :
if size is None :
if size is None or size > self . remaining :
if sizeof ( c_ulong ) != sizeof ( c_void_p ) :
if slots is not None :
if source [ 1 ] is None :
if source is None :
if space == 0 :
if space == 0 :
if start > upto :
if status :
if status != STATUS_OK :
if status != STATUS_OK :
if status is not None :
if str ( '\n' ) in value or str ( '\r' ) in value :
if str ( number ) [ 0 ] == sign :
if str_number [ 0 ] == '-' :
if stream :
if stream_created :
if strings_only and is_protected_type ( s ) :
if struct.pack('B', my_value):
if struct.pack('B', temp ^ i) == byte:
if struct.pack('B', temp ^ i) == byte:
if struct.pack('B', val1 ^ i) == bad_byte:
if struct.pack('B', val1 ^ i) == byte:
if struct.pack('B', val1 ^ z) == bad_byte:
if struct.pack('B', val1 ^ z):
if struct.pack('B', z):
if struct.pack('B', z):
if sub_tried is not None :
if subcommand == 'help' :
if subcommand in no_settings_commands :
if subcommand_cls . use_argparse :
if subject [ i ] in ( '"' , "'" ) :
if subject [ i ] in ( '"' , "'" ) :
if sublist_item :
if submod and not module_has_submodule ( import_module ( parentmod ) , submod ) :
if supported_code . startswith ( generic_lang_code + '-' ) :
if sys . platform . startswith ( 'java' ) :
if sys . platform . startswith ( 'java' ) :
if sys . platform . startswith ( "java" ) :
if sys . platform == "win32" :
if sys . version_info [ : 2 ] == ( 2 , 7 ) :
if sys . version_info [ : 2 ] == ( 3 , 2 ) :
if sys . version_info [ : 2 ] >= ( 3 , 3 ) :
if sys . version_info [ : 2 ] >= ( 3 , 4 ) :
if sys . version_info [ 1 ] <= 1 :
if sys . version_info >= ( 2 , 7 , 2 ) :
if t . contents . lstrip ( ) . startswith ( TRANSLATOR_COMMENT_MARK ) :
if t . token_type != TOKEN_COMMENT :
if t . token_type == TOKEN_BLOCK :
if t . token_type == TOKEN_BLOCK and t . contents == 'endcomment' :
if t [ 1 ] is True :
if t in self . __dispatch :
if t is not None :
if t is not None :
if table_name_filter is not None and callable ( table_name_filter ) :
if tablename in connection . introspection . table_names ( ) :
if tag . lower ( ) != self . cdata_tag :
if tag in self . CDATA_CONTENT_ELEMENTS :
if tag not in TemplateTagNode . mapping :
if tags and any ( not checks . tag_exists ( tag ) for tag in tags ) :
if tags is not None :
if takes_context :
if target is None :
if target_app_labels_only :
if targets [ 0 ] [ 1 ] is None :
if template . startswith ( 'file://' ) :
if template is None :
if template_dirs :
if template_source_loaders is None :
if template_tuple is TemplateDoesNotExist :
if terminal_char != ')' :
if termios :
if text . endswith ( truncate ) :
if text [ 0 ] == '#' :
if text [ 0 ] in 'xX' :
if text == '' and len ( opts ) == 1 and opts [ 0 ] == 'reset' :
if this_bases is None :
if threading :
if timeout == DEFAULT_TIMEOUT :
if timeout > 2592000 :
if timeout is None :
if timeout is not None :
if timezone . is_aware ( expires ) :
if timezone is None :
if to :
if to_lower :
if tok . next :
if tok . startswith ( "'" ) :
if token . contents == 'else' :
if token . contents == 'else' :
if token . contents == 'empty' :
if token . token_type == 0 :
if token . token_type == TOKEN_BLOCK and token . contents == endtag :
if token == "not" and i + 1 < l and tokens [ i + 1 ] == "in" :
if token is None :
if token_string . find ( TRANSLATOR_COMMENT_MARK ) :
if token_string . startswith ( VARIABLE_TAG_START ) :
if top + self . orphans >= self . count :
if top_errors :
if total != 2:
if transaction . get_autocommit ( self . using ) :
if transfer_encoding == 'base64' :
if transfer_encoding == 'base64' :
if transfer_encoding is not None :
if translators_comment_start is not None and lineno >= translators_comment_start :
if tried :
if trim :
if truncate is None :
if truncate_len == 0 :
if truncate_text :
if ttl is not None :
if type ( field_type ) is tuple :
if type ( result ) in ( ConvertingDict , ConvertingList ,  ConvertingTuple ) :
if type ( s ) == bytes :
if TYPE == RAW :
if typed :
if tzinfo [ 0 ] == '-' :
if tzinfo == 'Z' :
if unhandled_params :
if unicodedata . combining ( char ) :
if unpack :
if unpack_ipv4 :
if upload :
if upto != len ( token ) :
if upto != start :
if url :
if url . endswith ( '/' ) :
if url . startswith ( '///' ) :
if urlconf is None :
if urlconf is None :
if urlconf_name :
if use_base_manager :
if use_func :
if use_grouping :
if USE_INOTIFY :
if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
if use_l10n or ( use_l10n is None and settings . USE_L10N ) :
if use_natural_keys :
if use_reloader :
if used_name != guessed_filename :
if val == [ ] :
if val is None :
if val is not None :
if value :
if value :
if value != '' :
if value != self . empty_value :
if value != value or value == Decimal ( "Inf" ) or value == Decimal ( "-Inf" ) :
if value != value or value in ( Decimal ( 'Inf' ) , Decimal ( '-Inf' ) ) :
if value . __traceback__ is not tb :
if value [ 0 ] in self . empty_values and value [ 1 ] in self . empty_values :
if value == k or text_value == force_text ( k ) :
if value == k2 or text_value == force_text ( k2 ) :
if value == self . empty_value or value in self . empty_values :
if value and ':' in value :
if value and hasattr ( value , "url" ) :
if value and not self . valid_value ( value ) :
if value in ( None , '' ) :
if value in ( True , 'True' , '1' ) :
if value in self . empty_values :
if value in self . empty_values :
if value in self . empty_values and self . required :
if value is None :
if value is None and attr in declared_fields :
if value is not None :
if value is not result :
if value is True :
if values is None :
if var . endswith ( '.' ) :
if var . find ( VARIABLE_ATTRIBUTE_SEPARATOR + '_' ) > - 1 or var [ 0 ] == '_' :
if var . startswith ( '_(' ) and var . endswith ( ')' ) :
if var_obj is None :
if varargs is None :
if vary_on is None :
if verbosity >= 2 :
if version [ 3 ] == 'alpha' and version [ 4 ] == 0 :
if version is None :
if want_unicode :
if weight >= 6 :
if whitelist is not None :
if widgets and f . name in widgets :
if widgets is not None :
if x == bytearray(shellcode):
if x == bytearray(shellcode)[n]:
if x == bytearray(shellcode)[n]:
if x == bytearray(shellcode)[n]:
if x == bytearray(z)[i]:
if x == list(shellcode)[n]:
if x == shellcode[n]:
if y and m and d :
if year < 100 :
if year < 70 :
if years :
if z == a:
if z:
ignore = lambda pattern : fnmatch . fnmatchcase ( filename , pattern )
ignore = options . pop ( 'ignorenonexistent' , False )
ignore_patterns += [ 'CVS' , '.*' , '*~' , '*.pyc' ]
ignore_patterns = options . get ( 'ignore_patterns' )
ignored . append ( f . name )
ignored = [ ]
illegal_formatting = _illegal_formatting . search ( fmt )
Image . open ( file ) . verify ( )
imatch = inline_re . match ( t . contents )
import argparse
import argparse
import base64
import binascii
import bpython
import bz2
import calendar
import cgi
import code
import codecs
import collections
import contextlib
import copy
import datetime
import decimal
import django
import django . core . checks . compatibility . django_1_6_0
import django . core . checks . compatibility . django_1_7_0
import django . core . checks . model_checks
import dummy_threading as threading
import errno
import fcntl
import flup
import fnmatch
import functools
import gettext
import gettext as gettext_module
import glob
import gzip
import hashlib
import hashlib
import hmac
import imp
import importlib
import inspect
import io
import io
import itertools
import json
import keyword
import locale
import logging
import logging . handlers
import memcache
import mimetypes
import msvcrt
import operator
import operator
import os
import pickle
import pickle
import posixpath
import pyinotify
import pylibmc
import pytz
import random
import random as random_module
import re
import re
import readline
import rlcompleter
import shutil
import signal
import smtplib
import socket
import ssl
import stat
import stat
import stat
import StringIO
import termios
import threading
import threading
import threading
import time
import time
import time as _time
import traceback
import types
import unicodedata
import warnings
import warnings
import yaml
import zipfile
import zlib
import_module ( '.management' , app_config . name )
import_module ( '.management' , app_config . name )
import_module ( '%s.%s' % ( app_config . name , module_to_search ) )
import_module ( app_name )
import_module ( project_name )
import_module ( templatetag_module )
import_string ( backend )
imported_objects = { }
importer = __import__
in_index = - 3 if is_reversed else - 2
in_tag = False
in_tag = not in_tag
incomment = False
incomment = True
incremental = config . pop ( 'incremental' , False )
indent = '\t' * tabs
indent = options . get ( 'indent' )
indent = self . options . get ( "indent" )
index = data . find ( self . _boundary )
index_output . append ( "CREATE %sINDEX %s ON %s (%s);" %  ( unique , qn ( '%s_%s' % ( tablename , f . name ) ) , qn ( tablename ) ,  qn ( f . name ) ) )
index_output = [ ]
INDEX_PATTERN = re . compile ( r'^\[\s*(\w+)\s*\]\s*' )
index_sql = connection . creation . sql_indexes_for_model ( model , no_style ( ) )
indexbytes = operator . getitem
indexes = { }
indexes = connection . introspection . get_indexes ( cursor , table_name )
INFO = 20
infos = [ e for e in all_issues if checks . INFO <= e . level < checks . WARNING and not e . is_silenced ( ) ]
inhibit_post_migrate = options . get ( 'inhibit_post_migrate' , False )
init_path = os . path . join ( migrations_directory , "__init__.py" )
initial = [ '' for x in range ( 0 , len ( data ) ) ]
initial = [ ]
initial = bool ( initial )
initial = False
initial = self . initial . get ( name , field . initial )
initial = self . widget . decompress ( initial )
INITIAL_FORM_COUNT = 'INITIAL_FORMS'
initial_forms = len ( self . initial ) if self . initial else 0
initial_forms = self . initial_form_count ( )
initial_prefixed_name = self . add_initial_prefix ( name )
initial_set = set ( force_text ( value ) for value in initial )
initial_set = set ( force_text ( value ) for value in self . prepare_value ( initial ) )
initial_text = ugettext_lazy ( 'Currently' )
initial_value = field . to_python ( hidden_widget . value_from_datadict (  self . data , self . files , initial_prefixed_name ) )
initial_value = initial if initial is not None else ''
initial_value = initial if initial is not None else ''
initial_value = initial_value ( )
initial_value = self . initial . get ( name , field . initial )
initLock = Lock ( )
inline_re = re . compile ( r"""^\s*trans\s+((?:"[^"]*?")|(?:'[^']*?'))(\s+.*context\s+((?:"[^"]*?")|(?:'[^']*?')))?\s*""" )
inner , outer = digest ( ) , digest ( )
inner . update ( password . translate ( hmac . trans_36 ) )
inner = NonCapture ( result [ start : ] )
inner_args . extend ( args )
inner_html = '<li>{choice_value}{sub_widgets}</li>'
inner_result , inner_args = [ ] , [ ]
inner_result . extend ( res )
inner_text . append ( child . data )
inner_text . extend ( getInnerText ( child ) )
inner_text = [ ]
inplural = False
inplural = True
input_attrs [ 'id' ] = '%s_%s' % ( id_ , i )
input_attrs = dict ( value = force_text ( v ) , ** final_attrs )
input_format = get_format ( 'DATE_INPUT_FORMATS' ) [ 0 ]
input_formats = formats . get_format_lazy ( 'DATE_INPUT_FORMATS' )
input_formats = formats . get_format_lazy ( 'DATETIME_INPUT_FORMATS' )
input_formats = formats . get_format_lazy ( 'TIME_INPUT_FORMATS' )
input_text = ugettext_lazy ( 'Change' )
input_type = 'checkbox'
input_type = 'email'
input_type = 'file'
input_type = 'hidden'
input_type = 'number'
input_type = 'password'
input_type = 'radio'
input_type = 'text'
input_type = 'url'
input_type = None
input_val = force_text ( text )
inputs . append ( format_html ( '<input{0} />' , flatatt ( input_attrs ) ) )
insertByte = hex(243)
insertByte = hex(random.randint(0,222))
insertByte = hex(random.randint(1,255))
insertByte = hex(random.randint(1,360))
insertByte = random.randint(1,255)
instance . save ( )
instance = construct_instance ( form , instance , fields , exclude )
instance = super ( SortedDict , cls ) . __new__ ( cls , * args , ** kwargs )
int ( value )
int_part , dec_part = str_number , ''
int_part , dec_part = str_number . split ( '.' )
int_part = int_part_gd [ : : - 1 ]
int_part_gd += digit
int_part_gd += thousand_sep
int_part_gd = ''
int2byte = chr
int2byte = operator . methodcaller ( "to_bytes" , 1 , "big" )
integer_types = ( int , long )
integer_types = int ,
interactive = options . get ( 'interactive' )
interactive = options . get ( 'interactive' )
internal_use_only = False
internal_use_only = False
internal_use_only = True
intrans = False
intrans = True
invalid_apps . append ( app_name )
invalid_apps = [ ]
invalid_tag = next ( tag for tag in tags if not checks . tag_exists ( tag ) )
invalid_var_format_string = '%s' in settings . TEMPLATE_STRING_IF_INVALID
invalid_var_format_string = None
inverse_match = False
ip ( )
ip_address = literal_match . group ( 1 )
ip_address_validator_map = {  'both' : ( [ validate_ipv46_address ] , _ ( 'Enter a valid IPv4 or IPv6 address.' ) ) ,  'ipv4' : ( [ validate_ipv4_address ] , _ ( 'Enter a valid IPv4 address.' ) ) ,  'ipv6' : ( [ validate_ipv6_address ] , _ ( 'Enter a valid IPv6 address.' ) ) ,  }
ip_str = _explode_shorthand_ip_string ( ip_str )
ip_str = _sanitize_ipv4_mapping ( ip_str )
ipv4_address = "%d.%d.%d.%d" % (  int ( hextets [ 6 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 6 ] [ 2 : 4 ] , 16 ) ,  int ( hextets [ 7 ] [ 0 : 2 ] , 16 ) ,  int ( hextets [ 7 ] [ 2 : 4 ] , 16 ) ,  )
ipv4_re = re . compile ( r'^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$' )
ipv4_unpacked = _unpack_ipv4 ( ip_str )
is_a_tty = hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( )
is_accept_language_redundant = settings . USE_I18N or settings . USE_L10N
is_compressed = False
is_compressed = True
is_dst = False if dt is None else self . _isdst ( dt )
is_dst = False if dt is None else self . _isdst ( dt )
is_localized = False
is_relation = i in relations
is_required = False
is_reversed = bits [ - 1 ] == 'reversed'
is_templatized = file_ext in command . extensions
is_templatized = True
is_usable = False
is_usable = resource_string is not None
is_usable = True
isatty = property ( lambda self : self . file . isatty )
ISO_8859_1 , UTF_8 = str ( 'iso-8859-1' ) , str ( 'utf-8' )
ISO_INPUT_FORMATS = {  'DATE_INPUT_FORMATS' : ( '%Y-%m-%d' , ) ,  'TIME_INPUT_FORMATS' : ( '%H:%M:%S' , '%H:%M:%S.%f' , '%H:%M' ) ,  'DATETIME_INPUT_FORMATS' : (  '%Y-%m-%d %H:%M:%S' ,  '%Y-%m-%d %H:%M:%S.%f' ,  '%Y-%m-%d %H:%M' ,  '%Y-%m-%d'  ) ,  }
isolated_context = options . get ( 'only' , False )
item , old_style_list = convert_old_style_list ( sublist )
item . update ( kwargs )
item = {  'title' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'pubdate' : pubdate ,  'updateddate' : updateddate ,  'comments' : to_unicode ( comments ) ,  'unique_id' : to_unicode ( unique_id ) ,  'unique_id_is_permalink' : unique_id_is_permalink ,  'enclosure' : enclosure ,  'categories' : categories or ( ) ,  'item_copyright' : to_unicode ( item_copyright ) ,  'ttl' : ttl ,  }
item_date = item . get ( date_key )
items = _iteritems
iter ( patterns )
iter ( second_item )
iter ( x )
iterator = ChunkIter ( stream_or_iterable , 16384 )
iterator = iter ( stream_or_iterable )
iterator = None
Iterator = object
iterbytes = iter
iteritems = _iteritems
iterkeys = _iterkeys
iterlists = _iterlists
j = (i + magic)
j = (i + magic)%2
j = (i + magic)%256
j = (i + z)%250
j = day_of_year + ( 7 - weekday ) + ( jan1_weekday - 1 )
j = i + magic % 250
j = i + magic % 256
j = match . end ( )
j = text . find ( substr , i )
jan1_weekday = self . data . replace ( month = 1 , day = 1 ) . weekday ( ) + 1
javascript_quote = allow_lazy ( javascript_quote , six . text_type )
json . dump ( self . get_dump_object ( obj ) , self . stream ,  cls = DjangoJSONEncoder , ** self . json_kwargs )
k , v = x , True
k , v = x . split ( '=' , 1 )
k = force_bytes ( k , self . encoding )
k = item [ 0 ]
k = m . end ( )
k = match . end ( )
KB = 1 << 10
key , value = bits [ 2 ] , bits [ 0 ]
key , value = match . groups ( )
key += item
key += kwd_mark
key += tuple ( type ( v ) for k , v in sorted_items )
key += tuple ( type ( v ) for v in args )
key = ':' . join ( urlquote ( var ) for var in vary_on )
key = args
key = bytes_to_text ( key , self . encoding )
key = bytes_to_text ( key , self . encoding )
key = force_bytes ( settings . SECRET_KEY )
key = force_str ( key )
key = hashlib . sha1 ( key_salt + secret ) . digest ( )
key = key [ len ( self . prefix ) : ]
key = make_key ( args , kwds , typed )
key = make_key ( args , kwds , typed ) if kwds or typed else args
key = plist . pop ( 0 ) . lower ( ) . decode ( 'ascii' )
key = self . cache_key ( name , dirs )
key = self . cache_key ( template_name , template_dirs )
key = self . make_key ( key , version = version )
key = self . make_key ( key , version = version )
key = self . make_key ( key , version = version )
key = self . make_key ( key , version = version )
key = self . to_field_name or 'pk'
key = self . to_field_name or 'pk'
key_prefix = settings . CACHE_MIDDLEWARE_KEY_PREFIX
key_salt = force_bytes ( key_salt )
keys = _iterkeys
keys = n . getElementsByTagName ( 'natural' )
keys = node . getElementsByTagName ( 'natural' )
klass . __new__ = staticmethod ( __new__ )
klass . __str__ = lambda self : self . __unicode__ ( ) . encode ( 'utf-8' )
klass . __unicode__ = klass . __str__
klass . deconstruct = deconstruct
klass . prefix = '\n' + find_indentation ( node )
klass = app_name
klass = import_string ( backend or settings . EMAIL_BACKEND )
klass = load_command_class ( app_name , subcommand )
klass = node . clone ( )
klass = self . resolve ( config . pop ( 'class' ) )
known_models . add ( model )
known_models . append ( table2model ( table_name ) )
known_models = [ ]
known_models = set ( model for model in connection . introspection . installed_models ( tables ) if model not in app_models )
kw . extend ( [ d . hour , d . minute , d . second , d . microsecond , d . tzinfo ] )
kw [ 'microsecond' ] = kw [ 'microsecond' ] . ljust ( 6 , '0' )
kw [ 'tzinfo' ] = tzinfo
kw = [ d . year , d . month , d . day ]
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( kw ) if v is not None )
kw = dict ( ( k , int ( v ) ) for k , v in six . iteritems ( match . groupdict ( ) ) )
kw = match . groupdict ( )
kwarg = token_kwargs ( [ bit ] , parser )
kwarg_format = match and match . group ( 1 )
kwarg_re = re . compile ( r"(?:(\w+)=)?(.+)" )
kwargs . setdefault ( 'content_type' , 'application/json' )
kwargs . setdefault ( 'widget' , super ( IntegerField , self ) . widget )
kwargs . update ( self . default_args )
kwargs [ 'error_messages' ] = error_messages
kwargs [ 'error_messages' ] = error_messages [ f . name ]
kwargs [ 'help_text' ] = help_texts [ f . name ]
kwargs [ 'initial' ] = self . initial_extra [ i - self . initial_form_count ( ) ]
kwargs [ 'instance' ] = self . _existing_object ( pk )
kwargs [ 'instance' ] = self . get_queryset ( ) [ i ]
kwargs [ 'label' ] = labels [ f . name ]
kwargs [ 'localize' ] = True
kwargs [ 'max_age' ] = min ( int ( cc [ 'max-age' ] ) , kwargs [ 'max_age' ] )
kwargs [ 'number' ] = number
kwargs [ 'number' ] = number_value
kwargs [ 'safe' ] = safe
kwargs [ 'stream' ] = None
kwargs [ 'strm' ] = kwargs . pop ( 'stream' )
kwargs [ 'to_field' ] = self . fk . rel . field_name
kwargs [ 'widget' ] = widgets [ f . name ]
kwargs [ "initial" ] = getattr ( self . parent_instance , self . to_field )
kwargs [ "initial" ] = self . parent_instance . pk
kwargs [ "required" ] = False
kwargs [ key ] = parser . compile_filter ( value )
kwargs [ name ] = parser . compile_filter ( value )
kwargs [ str ( param ) ] = value
kwargs = {  'form' : form ,  'formfield_callback' : formfield_callback ,  'formset' : formset ,  'extra' : extra ,  'can_delete' : can_delete ,  'can_order' : can_order ,  'fields' : fields ,  'exclude' : exclude ,  'min_num' : min_num ,  'max_num' : max_num ,  'widgets' : widgets ,  'validate_min' : validate_min ,  'validate_max' : validate_max ,  'localized_fields' : localized_fields ,  'labels' : labels ,  'help_texts' : help_texts ,  'error_messages' : error_messages ,  }
kwargs = {  'label' : getattr ( form . fields . get ( name ) , 'label' , capfirst ( self . fk . verbose_name ) )  }
kwargs = { 'pk_field' : True }
kwargs = { }
kwargs = { }
kwargs = { }
kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
kwargs = dict ( ( k , config [ k ] ) for k in config if valid_ident ( k ) )
kwargs = dict ( ( smart_text ( k , 'ascii' ) , v . resolve ( context ) )  for k , v in self . kwargs . items ( ) )
kwargs = kwargs or { }
kwargs = match . groupdict ( )
kwargs_safe = dict ( ( k , conditional_escape ( v ) ) for ( k , v ) in six . iteritems ( kwargs ) )
l = - ( - dklen // hlen )
l = lambda x : self . make_key ( x , version = version )
l = len ( tokens )
label = ''
label = 'label'
label = bf . label_tag ( label ) or ''
label = conditional_escape ( force_text ( bf . label ) )
label_for = ''
label_for = format_html ( ' for="{0}"' , self . id_for_label )
label_output = self . handle_label ( label , ** options )
label_suffix = ( self . field . label_suffix if self . field . label_suffix is not None  else self . form . label_suffix )
lang = get_language ( )
lang = None
lang_code = get_language_from_path ( request . path_info )
lang_code = regex_match . group ( 1 )
lang_code = request . COOKIES . get ( settings . LANGUAGE_COOKIE_NAME )
lang_code = request . session . get ( LANGUAGE_SESSION_KEY )
language_code = get_language ( )
language_code = get_language ( )
language_code_prefix_re = re . compile ( r'^/([\w-]+)(/|$)' )
language_code_re = re . compile ( r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*$' , re . IGNORECASE )
LANGUAGE_SESSION_KEY = '_language'
last [ NEXT ] = root [ PREV ] = cache [ key ] = link
last [ NEXT ] = root [ PREV ] = link
last = max ( 0 , end - 1 )
last = pos + 1
last = root [ PREV ]
last = self . data . day % 10
last_bit = self . template_string [ upto : ]
last_row = ( normal_row % { 'errors' : '' , 'label' : '' ,  'field' : '' , 'help_text' : '' ,  'html_class_attr' : html_class_attr } )
last_row = output [ - 1 ]
latest_date = item_date
latest_date = None
lbp = 0
lbp = 0
lbp = bp
lead , middle , trail = '' , word , ''
leader = int(sys.argv[1])
leader = int(sys.argv[2])
leader = int(sys.argv[3])
leader = int(sys.argv[3])
leading = self . has_leading_dir ( namelist )
leading = self . has_leading_dir ( x . name for x in members )
leave_locale_alone = False
leave_locale_alone = True
leave_locale_alone = True
left = t . led ( left , self )
left = t . nud ( self )
len ( X ( ) )
len_item = 1
len_item = len ( item )
len(bytearray(shellcode)))
len(shellcode)
length = int ( arg )
length = int ( num )
length = int ( num )
length_format_0x = format_0x.count(',')
length_format_0x = format_0x.count(',')
length_format_0x = format_0x.count('a')
length_format_0x = format_0x.count('z')
level = 0
level = config . get ( 'level' , None )
level = config . pop ( 'level' , None )
level = handler_config . get ( 'level' , None )
lexer = JsLexer ( )
lexer = lexer_class ( template_string , origin )
lexer_class , parser_class = DebugLexer , DebugParser
lexer_class , parser_class = Lexer , Parser
lib = get_library ( taglib )
lib = import_library ( taglib_module )
lib = libraries . get ( library_name , None )
libraries [ library_name ] = lib
libraries = { }
LIGHT_PALETTE = 'light'
limit_choices_to = formfield . limit_choices_to
limit_choices_to = limit_choices_to ( )
line = ''
line = '%s\n' % plural_form_line
line = buffer_ + line
line = line [ space : ]
line = sio . readline ( )
line = sio . readline ( size )
linebreaks = allow_lazy ( linebreaks , six . text_type )
lineno , offset = self . getpos ( )
lineno = lineno + self . __starttag_text . count ( "\n" )
lineno_comment_map . setdefault ( t . lineno ,  [ ] ) . append ( t . contents )
lineno_comment_map [ comment_lineno_cache ] = [ ]
lineno_comment_map = { }
lines . append ( line )
lines [ i ] = ( "%0" + width + "d. %s" ) % ( i + 1 , escape ( line ) )
lines [ i ] = ( "%0" + width + "d. %s" ) % ( i + 1 , line )
lines = [ ]
lines = value . split ( '\n' )
link [ NEXT ] = root
link [ PREV ] = last
link = [ last , root , key , result ]
link = cache_get ( key )
link_next [ PREV ] = link_prev
link_prev , link_next , key , result = link
link_prev [ NEXT ] = link_next
link_target_attribute_re = re . compile ( r'(<a [^>]*?)target=[^\s>]+' )
list_ = [ bytes_to_text ( elt , self . encoding ) for elt in list_ ]
list_ = super ( MultiValueDict , self ) . __getitem__ ( key )
list_length = len ( list_ )
lists = _iterlists
lit = b""
lit = b""
lit = b""
lit = b""
lit = b""
literal_match = self . literal_regex . match ( domain_part )
literal_regex = re . compile (   r'\[([A-f0-9:\.]+)\]$' ,  re . IGNORECASE )
load_template_source . is_usable = True
loaded_objects_in_fixture += 1
loaded_objects_in_fixture = 0
loader , args = loader [ 0 ] , loader [ 1 : ]
loader = find_template_loader ( loader_name )
loader = MigrationLoader ( connection )
loader = MigrationLoader ( connection )
loader = MigrationLoader ( None , ignore_no_migrations = True )
loaders . append ( loader )
loaders = [ ]
local , domain = middle . rsplit ( '@' , 1 )
local_attrs = self . build_attrs ( id = field % id_ )
locale = options . get ( 'locale' )
locale = options . get ( 'locale' )
locale = to_locale ( lang )
locale_dir = None
locale_dir = path
locale_dir = self . default_locale_path
locale_dirs = filter ( os . path . isdir , glob . glob ( '%s/*' % basedir ) )
locale_dirs = filter ( os . path . isdir , glob . glob ( '%s/*' % self . default_locale_path ) )
localedir = os . path . join ( app_config . path , 'locale' )
localedir = os . path . join ( os . path . dirname ( settingsfile ) , 'locale' )
LocaleRegexProvider . __init__ ( self , regex )
locales . append ( locale . split ( '_' ) [ 0 ] )
locales = [ locale ]
locales = all_locales
locales = locale or all_locales
locales = locale or all_locales
locales = set ( locales ) - set ( exclude )
locales = set ( locales ) - set ( exclude )
localize = kwargs . get ( 'localize' , False )
localpart , domain = addr . split ( '@' , 1 )
localpart = str ( Header ( localpart , encoding ) )
location = '//%s' % self . get_full_path ( )
location = kwargs . pop ( 'LOCATION' , '' )
location = params . pop ( 'LOCATION' , '' )
location = settings . MEDIA_ROOT
location = urljoin ( current_uri , location )
locations . extend ( ( dirpath , f ) for f in filenames if f . endswith ( '.po' ) )
locations = [ ]
lock = RLock ( )
LOCK_EX = 0x2
LOCK_EX = fcntl . LOCK_EX
LOCK_EX = LOCK_SH = LOCK_NB = 0
LOCK_NB = 0x1
LOCK_NB = fcntl . LOCK_NB
LOCK_SH = 0
LOCK_SH = fcntl . LOCK_SH
LockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , DWORD , LPOVERLAPPED ]
LockFileEx . restype = BOOL
LockFileEx = windll . kernel32 . LockFileEx
locks . lock ( fd , locks . LOCK_EX )
locks . lock ( fd , locks . LOCK_EX )
locks . unlock ( fd )
locks . unlock ( fd )
logger . addHandler ( handler )
logger . addHandler ( self . config [ 'handlers' ] [ h ] )
logger . disabled = True
logger . error ( 'Internal Server Error: %s' , request . path ,  exc_info = exc_info ,  extra = {  'status_code' : 500 ,  'request' : request  }  )
logger . handlers = [ ]
logger . level = logging . NOTSET
logger . propagate = propagate
logger . propagate = True
logger . removeHandler ( h )
logger . removeHandler ( handler )
logger . setLevel ( _checkLevel ( level ) )
logger . warning (  'Forbidden (Permission denied): %s' , request . path ,  extra = {  'status_code' : 403 ,  'request' : request  } )
logger . warning ( 'Bad Request (UnicodeDecodeError)' ,  exc_info = sys . exc_info ( ) ,  extra = {  'status_code' : 400 ,  }  )
logger . warning ( 'Not Found: %s' , request . path ,  extra = {  'status_code' : 404 ,  'request' : request  } )
logger = logging . getLogger ( 'django.request' )
logger = logging . getLogger ( 'django.request' )
logger = logging . getLogger ( 'py.warnings' )
logger = logging . getLogger ( name )
logger = root . manager . loggerDict [ log ]
loggers = config . get ( 'loggers' , EMPTY_DICT )
logging . _acquireLock ( )
logging . _handlers . clear ( )
logging . _releaseLock ( )
logging . captureWarnings ( True )
logging . Handler . __init__ ( self )
logging_config_func ( DEFAULT_LOGGING )
logging_config_func ( logging_settings )
logging_config_func = import_string ( logging_config )
lookup_str = callback . __module__ + "." + callback . __class__ . __name__
lookup_str = callback . __module__ + "." + callback . __name__
lookup_view = get_callable ( lookup_view , True )
lookup_view_s = "%s.%s" % ( m , n )
lookup_view_s = lookup_view
lookups . appendlist ( name , ( new_matches , p_pattern + pat , dict ( defaults , ** pattern . default_kwargs ) ) )
lookups . appendlist ( pattern . callback , ( bits , p_pattern , pattern . default_args ) )
lookups . appendlist ( pattern . name , ( bits , p_pattern , pattern . default_args ) )
lookups = MultiValueDict ( )
loop_dict [ 'counter' ] = i + 1
loop_dict [ 'counter0' ] = i
loop_dict [ 'first' ] = ( i == 0 )
loop_dict [ 'last' ] = ( i == len_values - 1 )
loop_dict [ 'revcounter' ] = len_values - i
loop_dict [ 'revcounter0' ] = len_values - i - 1
loop_dict = context [ 'forloop' ] = { 'parentloop' : parentloop }
loopvars = re . split ( r' *, *' , ' ' . join ( bits [ 1 : in_index ] ) )
LPOVERLAPPED = POINTER ( OVERLAPPED )
lst = []
lst1 = []
lst2 = []
LUHN_ODD_LOOKUP = ( 0 , 2 , 4 , 6 , 8 , 1 , 3 , 5 , 7 , 9 )
M . set ( key , real_value , coded_value )
m = _html_parser . attrfind . match ( rawdata , k )
m = base
m = data . get ( self . month_field % name )
m = dict ( zip ( new_keys , keys ) )
m = getattr ( lookup_view , '__module__' , None )
m = IDENTIFIER . match ( s )
m = int ( d ) - d
m = m + base [ medium ]
m = Media ( )
m = plural_forms_re . search ( fp . read ( ) )
m = re . match ( naiveip_re , options [ 'addrport' ] )
m = regex . match ( date )
m = regex . search ( text , pos )
m = self . CONVERT_PATTERN . match ( value )
m = self . DOT_PATTERN . match ( rest )
M = self . get ( key , Morsel ( ) )
m = self . INDEX_PATTERN . match ( rest )
m = self . WORD_PATTERN . match ( rest )
m2m_convert = lambda n : field . rel . to . _meta . pk . to_python ( n . getAttribute ( 'pk' ) )
m2m_convert = lambda v : smart_text ( field . rel . to . _meta . pk . to_python ( v ) )
m2m_data [ field . name ] = [ m2m_convert ( pk ) for pk in field_value ]
m2m_data [ field . name ] = self . _handle_m2m_field_node ( field_node , field )
m2m_data = { }
m2m_data = { }
m2m_value = lambda value : smart_text ( value . _get_pk_val ( ) , strings_only = True )
mail . attach_alternative ( html_message , 'text/html' )
mail . attach_alternative ( html_message , 'text/html' )
mail . mail_admins ( subject , message , fail_silently = True ,  html_message = html_message ,  connection = self . connection ( ) )
mail . outbox . extend ( messages )
mail . outbox = [ ]
mail . send ( fail_silently = fail_silently )
mail . send ( fail_silently = fail_silently )
mail = EmailMultiAlternatives ( '%s%s' % ( settings . EMAIL_SUBJECT_PREFIX , subject ) ,  message , settings . SERVER_EMAIL , [ a [ 1 ] for a in settings . ADMINS ] ,  connection = connection )
mail = EmailMultiAlternatives ( '%s%s' % ( settings . EMAIL_SUBJECT_PREFIX , subject ) ,  message , settings . SERVER_EMAIL , [ a [ 1 ] for a in settings . MANAGERS ] ,  connection = connection )
mail = EmailMultiAlternatives ( subject , message , from_email , recipient_list ,  connection = connection )
main_value_pair , params = parse_header ( line )
major = '.' . join ( str ( x ) for x in version [ : parts ] )
major = get_major_version ( version )
make_key = _make_key
manifest = OrderedDict (  ( app_name , list ( filter ( model_installed , model_list ) ) )  for app_name , model_list in all_models  )
mapped_tokens . append ( self . translate_token ( token ) )
mapped_tokens = [ ]
mapping = { 'alpha' : 'a' , 'beta' : 'b' , 'rc' : 'c' }
mapping = { 'openblock' : BLOCK_TAG_START ,  'closeblock' : BLOCK_TAG_END ,  'openvariable' : VARIABLE_TAG_START ,  'closevariable' : VARIABLE_TAG_END ,  'openbrace' : SINGLE_BRACE_START ,  'closebrace' : SINGLE_BRACE_END ,  'opencomment' : COMMENT_TAG_START ,  'closecomment' : COMMENT_TAG_END ,  }
mask = (  pyinotify . IN_MODIFY |  pyinotify . IN_DELETE |  pyinotify . IN_ATTRIB |  pyinotify . IN_MOVED_FROM |  pyinotify . IN_MOVED_TO |  pyinotify . IN_CREATE  )
match = _html_parser . endendtag . search ( rawdata , i + 1 )
match = _html_parser . endtagfind . match ( rawdata , i )
match = (  pattern == '*' or  pattern . startswith ( '.' ) and (  host . endswith ( pattern ) or host == pattern [ 1 : ]  ) or  pattern == host  )
match = condition . eval ( context )
match = date_re . match ( value )
match = datetime_re . match ( value )
match = kwarg_re . match ( bit )
match = kwarg_re . match ( bits [ 0 ] )
match = None
match = RE_DATE . match ( value )
match = self . regex . search ( path )
match = self . regex . search ( path )
match = tagfind . match ( rawdata , i + 1 )
match = time_re . match ( value )
matches = filter_re . finditer ( token )
matches = True
max_entries = params . get ( 'max_entries' , options . get ( 'MAX_ENTRIES' , 300 ) )
max_num = 1
max_num = DEFAULT_MAX_NUM
MAX_NUM_FORM_COUNT = 'MAX_NUM_FORMS'
max_value = float ( max_value )
max_value = self . max_expr . resolve ( context )
max_width = int ( self . max_width . resolve ( context ) )
max_width = min ( ( line . endswith ( '\n' ) and width + 1 or width ) , width )
MAXSIZE = int ( ( 1 << 31 ) - 1 )
MAXSIZE = int ( ( 1 << 63 ) - 1 )
MAXSIZE = sys . maxsize
MB = 1 << 20
media = Media ( )
media = media + field . widget . media
media = media + w . media
media = property ( _get_media )
media = sorted ( self . _css . keys ( ) )
media_attrs = kwargs
media_attrs = media . __dict__
MEDIA_TYPES = ( 'css' , 'js' )
mem_args = args [ : num_args ]
members = [ member for member in self . _archive . getmembers ( )  if member . name != 'pax_global_header' ]
MEMCACHE_MAX_KEY_LENGTH = 250
memo [ id ( self ) ] = obj
memo [ id ( self ) ] = result
memo [ id ( self ) ] = result
memo [ id ( self ) ] = result
memo [ id ( self ) ] = result
memo [ id ( self ) ] = self
memo = { }
memoryview = buffer
memoryview = memoryview
merge_migrations . append ( migration )
merge_migrations = [ ]
message , code , params = message . message , message . code , message . params
message . message ( )
message . message = error_messages [ message . code ]
message %= error . params
message = _ (  '%(datetime)s couldn\'t be interpreted '  'in time zone %(current_timezone)s; it '  'may be ambiguous or it may not exist.'  )
message = _ ( 'Ensure this value is %(limit_value)s (it is %(show_value)s).' )
message = _ ( 'Ensure this value is greater than or equal to %(limit_value)s.' )
message = _ ( 'Ensure this value is less than or equal to %(limit_value)s.' )
message = _ ( 'Enter a valid email address.' )
message = _ ( 'Enter a valid URL.' )
message = _ ( 'Enter a valid value.' )
message = '' . join ( tokens )
message = 'make sure the name begins with a letter or underscore'
message = 'Unknown field(s) (%s) specified for %s'
message = 'use only numbers, letters and underscores'
message = "'%s' already exists" % top_dir
message = "%s\n\nRequest repr(): %s" % ( self . format ( record ) , request_repr )
message = e
message = email_message . message ( )
message = error . message
message = list ( error ) [ 0 ]
message = message . error_dict
message = message . error_list
message = message % ( ', ' . join ( missing_fields ) ,  opts . model . __name__ )
message = trim_whitespace ( message )
message = ungettext_lazy (  'Ensure this value has at least %(limit_value)d character (it has %(show_value)d).' ,  'Ensure this value has at least %(limit_value)d characters (it has %(show_value)d).' ,  'limit_value' )
message = ungettext_lazy (  'Ensure this value has at most %(limit_value)d character (it has %(show_value)d).' ,  'Ensure this value has at most %(limit_value)d characters (it has %(show_value)d).' ,  'limit_value' )
message = ValidationError ( message )
message_context = context_match . group ( 1 )
message_context = message_context . strip ( '"' )
message_context = message_context . strip ( "'" )
message_context = None
messages . update ( error_messages or { } )
messages . update ( getattr ( c , 'default_error_messages' , { } ) )
messages = [ EmailMessage ( subject , message , sender , recipient ,  connection = connection )  for subject , message , sender , recipient in datatuple ]
messages = { }
messages = ValidationError ( messages )
meta = '<could not parse>'
meta = ( pformat ( META_override )  if META_override is not None  else pformat ( request . META ) )
meta = getattr ( form , 'Meta' , None )
meta = type ( str ( 'Meta' ) , ( object , ) , { } )
Meta = type ( str ( 'Meta' ) , parent , attrs )
meth = cls . __promise__ ( resultclass , k , v )
method = kwargs . pop ( 'method' )
middle = '<a href="%s"%s>%s</a>' % ( url , nofollow_attr , trimmed )
middle = middle [ : - len ( closing ) ]
middle = middle [ : - len ( punctuation ) ]
middle = middle [ len ( opening ) : ]
middleware = middleware_class ( * m_args , ** m_kwargs )
migration . ancestry = loader . graph . forwards_plan ( ( app_label , migration_name ) )
migration . branch = migration . ancestry [  ( migration . ancestry . index ( common_ancestor ) + 1 ) :  ]
migration . merged_operations . extend (  loader . get_migration ( node_app , node_name ) . operations  )
migration . merged_operations = [ ]
migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )
migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )
migration = executor . loader . get_migration_by_prefix ( app_label , migration_name )
migration = loader . get_migration ( app_label , migration_name )
migration_string = writer . as_string ( )
migrations_directory = os . path . dirname ( writer . path )
migrations_to_squash = [  executor . loader . get_migration ( al , mn )  for al , mn in executor . loader . graph . forwards_plan ( ( migration . app_label , migration . name ) )  if al == migration . app_label  ]
mime_type = 'application/atom+xml; charset=utf-8'
mime_type = 'application/rss+xml; charset=utf-8'
MIMEMessage . __setitem__ ( self , name , val )
MIMEMultipart . __init__ ( self , _subtype , boundary , _subparts , ** _params )
MIMEMultipart . __setitem__ ( self , name , val )
MIMEText . __init__ ( self , text , subtype , charset )
MIMEText . __init__ ( self , text , subtype , None )
MIMEText . __setitem__ ( self , name , val )
mimetype , _ = mimetypes . guess_type ( filename )
mimetype = DEFAULT_ATTACHMENT_MIME_TYPE
min = int ( m . group ( 'min' ) )
min_num = DEFAULT_MIN_NUM
MIN_NUM_FORM_COUNT = 'MIN_NUM_FORMS'
missing_args_message = "Enter at least one %s." % label
missing_args_message = "Enter at least one application label."
missing_args_message = "You must provide a project name."
missing_args_message = "You must provide an application name."
missing_args_message = ( "No database fixture specified. Please provide the "  "path of at least one fixture in the command line." )
missing_fields = ( set ( none_model_fields ) -  set ( new_class . declared_fields . keys ( ) ) )
mixed_subtype = 'mixed'
mod = import_module ( mod_name )
mod = import_module ( taglib_module )
mod_name , func_name = get_mod_func ( lookup_view )
mode = 'wb' if isinstance ( chunk , bytes ) else 'wt'
mode = stat . S_IMODE ( st . st_mode )
model , deps = model_dependencies . pop ( )
Model = _get_model ( d [ "model" ] )
model = app_config . get_model ( model_label )
model = apps . get_model ( exclude )
model = None
Model = self . _get_model_from_node ( node , "model" )
model = self . obj
model_dependencies . append ( ( model , deps ) )
model_dependencies . reverse ( )
model_dependencies = [ ]
model_dependencies = skipped
model_fields = Model . _meta . get_all_field_names ( )
model_identifier = node . getAttribute ( attr )
model_list . append ( model )
model_list = [ ]
model_list = app_config . get_models ( )
models . add ( model )
models . Model . save_base ( self . object , using = using , raw = True )
models . signals . post_migrate . send (  sender = app_config ,  app_config = app_config ,  verbosity = verbosity ,  interactive = interactive ,  using = db )
models . signals . post_syncdb . send (  sender = app_config . models_module ,  app = app_config . models_module ,  created_models = created_models ,  verbosity = verbosity ,  interactive = interactive ,  db = db )
models . signals . pre_migrate . send (  sender = app_config ,  app_config = app_config ,  verbosity = verbosity ,  interactive = interactive ,  using = db )
models . signals . pre_syncdb . send (  sender = app_config . models_module ,  app = app_config . models_module ,  create_models = create_models ,  verbosity = verbosity ,  interactive = interactive ,  db = db )
models = 'models'
models = app_config . get_models ( include_auto_created = True )
models = set ( )
modified_code = None
module = _import_module ( self . mod )
module = import_module ( '%s.management.commands.%s' % ( app_name , name ) )
module = import_module ( module_path )
module = importlib . import_module ( '.%s' % flup_module , 'flup' )
module = importlib . import_module ( serializer_module )
module = type ( 'BadSerializerModule' , ( object , ) , {  'Deserializer' : bad_serializer ,  'Serializer' : bad_serializer ,  } )
module_path , class_name = dotted_path . rsplit ( '.' , 1 )
Module_six_moves_urllib_error . _moved_attributes = _urllib_error_moved_attributes
Module_six_moves_urllib_parse . _moved_attributes = _urllib_parse_moved_attributes
Module_six_moves_urllib_request . _moved_attributes = _urllib_request_moved_attributes
Module_six_moves_urllib_response . _moved_attributes = _urllib_response_moved_attributes
Module_six_moves_urllib_robotparser . _moved_attributes = _urllib_robotparser_moved_attributes
module_values = set ( sys . modules . values ( ) )
modules = _format_modules_cache . setdefault ( lang , list ( iter_format_modules ( lang , settings . FORMAT_MODULE_PATH ) ) )
month = MONTHS . index ( m . group ( 'mon' ) . lower ( ) ) + 1
month = months [ date . month - 1 ]
month_field = '%s_month'
MONTHS = 'jan feb mar apr may jun jul aug sep oct nov dec' . split ( )
months = ( 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' , )
MONTHS = {  1 : _ ( 'January' ) , 2 : _ ( 'February' ) , 3 : _ ( 'March' ) , 4 : _ ( 'April' ) , 5 : _ ( 'May' ) , 6 : _ ( 'June' ) ,  7 : _ ( 'July' ) , 8 : _ ( 'August' ) , 9 : _ ( 'September' ) , 10 : _ ( 'October' ) , 11 : _ ( 'November' ) ,  12 : _ ( 'December' )  }
MONTHS_3 = {  1 : _ ( 'jan' ) , 2 : _ ( 'feb' ) , 3 : _ ( 'mar' ) , 4 : _ ( 'apr' ) , 5 : _ ( 'may' ) , 6 : _ ( 'jun' ) ,  7 : _ ( 'jul' ) , 8 : _ ( 'aug' ) , 9 : _ ( 'sep' ) , 10 : _ ( 'oct' ) , 11 : _ ( 'nov' ) , 12 : _ ( 'dec' )  }
MONTHS_3_REV = {  'jan' : 1 , 'feb' : 2 , 'mar' : 3 , 'apr' : 4 , 'may' : 5 , 'jun' : 6 , 'jul' : 7 , 'aug' : 8 ,  'sep' : 9 , 'oct' : 10 , 'nov' : 11 , 'dec' : 12  }
MONTHS_ALT = {  1 : pgettext_lazy ( 'alt. month' , 'January' ) ,  2 : pgettext_lazy ( 'alt. month' , 'February' ) ,  3 : pgettext_lazy ( 'alt. month' , 'March' ) ,  4 : pgettext_lazy ( 'alt. month' , 'April' ) ,  5 : pgettext_lazy ( 'alt. month' , 'May' ) ,  6 : pgettext_lazy ( 'alt. month' , 'June' ) ,  7 : pgettext_lazy ( 'alt. month' , 'July' ) ,  8 : pgettext_lazy ( 'alt. month' , 'August' ) ,  9 : pgettext_lazy ( 'alt. month' , 'September' ) ,  10 : pgettext_lazy ( 'alt. month' , 'October' ) ,  11 : pgettext_lazy ( 'alt. month' , 'November' ) ,  12 : pgettext_lazy ( 'alt. month' , 'December' )  }
MONTHS_AP = {  1 : pgettext_lazy ( 'abbrev. month' , 'Jan.' ) ,  2 : pgettext_lazy ( 'abbrev. month' , 'Feb.' ) ,  3 : pgettext_lazy ( 'abbrev. month' , 'March' ) ,  4 : pgettext_lazy ( 'abbrev. month' , 'April' ) ,  5 : pgettext_lazy ( 'abbrev. month' , 'May' ) ,  6 : pgettext_lazy ( 'abbrev. month' , 'June' ) ,  7 : pgettext_lazy ( 'abbrev. month' , 'July' ) ,  8 : pgettext_lazy ( 'abbrev. month' , 'Aug.' ) ,  9 : pgettext_lazy ( 'abbrev. month' , 'Sept.' ) ,  10 : pgettext_lazy ( 'abbrev. month' , 'Oct.' ) ,  11 : pgettext_lazy ( 'abbrev. month' , 'Nov.' ) ,  12 : pgettext_lazy ( 'abbrev. month' , 'Dec.' )  }
Morsel = http_cookies . Morsel
moves = sys . modules [ __name__ + ".moves" ] = _MovedItems ( __name__ + ".moves" )
msg . attach ( attachment )
msg . attach ( body_msg )
msg . attach ( body_msg )
msg . attach ( self . _create_attachment ( * attachment ) )
msg . attach ( self . _create_mime_attachment ( * alternative ) )
msg [ 'Cc' ] = ', ' . join ( self . cc )
msg [ 'Date' ] = formatdate ( )
msg [ 'From' ] = self . extra_headers . get ( 'From' , self . from_email )
msg [ 'Message-ID' ] = make_msgid ( )
msg [ 'Subject' ] = self . subject
msg [ 'To' ] = self . extra_headers . get ( 'To' , ', ' . join ( self . to ) )
msg [ name ] = value
msg += '\n'
msg += '\n%s:\n%s\n' % ( group_name , formatted )
msg += " The domain name provided is not valid according to RFC 1034/1035."
msg += " You may need to add %r to ALLOWED_HOSTS." % domain
msg += "System check identified %s (%s silenced)." % (  "no issues" if visible_issue_count == 0 else  "1 issue" if visible_issue_count == 1 else  "%s issues" % visible_issue_count ,  len ( all_issues ) - visible_issue_count ,  )
msg += ending
msg = '%sError importing module %s: "%s"' % (  error_prefix , dotted_path , e )
msg = 'Module "%s" does not define a "%s" attribute/class' % (  dotted_path , class_name )
msg = ""
msg = "[%s] %s\n" % ( self . log_date_time_string ( ) , format % args )
msg = "%s doesn't look like a module path" % dotted_path
msg = "Could not decode base64 data: %r" % e
msg = "Execution of %s failed: %s" % ( self . program , errors )
msg = "Execution of %s failed" % self . program
msg = "Invalid HTTP_HOST header: %r." % host
msg = "System check identified some issues:\n%s" % msg
msg = "Unclosed tag '%s'. Looking for one of: %s " % ( command , ', ' . join ( parse_until ) )
msg = (  "django.utils.text.javascript_quote() is deprecated. "  "Use django.utils.html.escapejs() instead."  )
msg = (  "The included urlconf '{name}' does not appear to have any "  "patterns in it. If you see valid patterns in the file then "  "the issue is probably caused by a circular import."  )
msg = (  "WSGI application '%(app_path)s' could not be loaded; "  "Error importing module: '%(exception)s'" % ( {  'app_path' : app_path ,  'exception' : e ,  } )  )
msg = ( "\nYou have installed Django's auth system, and "  "don't have any superusers defined.\nWould you like to create one "  "now? (yes/no): " )
msg = ( "%(model)s.Meta.%(opt)s cannot be a string. "  "Did you mean to type: ('%(value)s',)?" % {  'model' : new_class . __name__ ,  'opt' : opt ,  'value' : value ,  } )
msg = ( "The use of the language code '%s' is deprecated. "  "Please use the '%s' translation instead." )
msg = message . message ( )
msg = SafeMIMEMultipart ( _subtype = self . alternative_subtype , encoding = encoding )
msg = SafeMIMEMultipart ( _subtype = self . mixed_subtype , encoding = encoding )
msg = SafeMIMEText ( self . body , self . content_subtype , encoding )
msg = self . _create_message ( msg )
msg = self . style . HTTP_BAD_REQUEST ( msg )
msg = self . style . HTTP_INFO ( msg )
msg = self . style . HTTP_NOT_FOUND ( msg )
msg = self . style . HTTP_NOT_MODIFIED ( msg )
msg = self . style . HTTP_REDIRECT ( msg )
msg = self . style . HTTP_SERVER_ERROR ( msg )
msg = self . style . HTTP_SUCCESS ( msg )
msg_count += 1
msg_count += 1
msg_count = 0
msg_count = 0
msg_data = msg . as_bytes ( )
msg_data = msg_data . decode ( charset )
msg_with_ctxt = "%s%s%s" % ( context , CONTEXT_SEPARATOR , message )
msgattrib_options = [ '--no-obsolete' ]
msgid = '<%s.%s.%s%s@%s>' % ( utcdate , pid , randint , idstring , idhost )
msgmerge_options = [ '-q' , '--previous' ]
msgs , errors , status = popen_wrapper ( args )
msgs , errors , status = popen_wrapper ( args )
msgs , errors , status = popen_wrapper ( args )
msgs , errors , status = popen_wrapper ( args )
msgs = '\n' . join ( dropwhile ( len , msgs . split ( '\n' ) ) )
msgs = '\n' . join ( lines )
msgs = fp . read ( )
msgs = msgs . decode ( 'utf-8' )
msgs = msgs . decode ( 'utf-8' )
msgs = msgs . replace (  "#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\n" % self . domain , "" )
msgs = msgs . replace ( 'charset=CHARSET' , 'charset=UTF-8' )
msgs = msgs . replace ( old , new )
msgs = self . copy_plural_forms ( msgs , locale )
msgs_with_ctxt = ( "%s%s%s" % ( context , CONTEXT_SEPARATOR , singular ) ,  "%s%s%s" % ( context , CONTEXT_SEPARATOR , plural ) ,  number )
msguniq_options = [ '--to-code=utf-8' ]
mtime -= stat . st_ctime
mtime = stat . st_mtime
must_be_first = False
must_be_first = True
mw_class = import_string ( middleware_path )
n &= width
n = bytearray(shellcode)
n = bytearray(shellcode)
n = len(bytearray(shellcode))
n = len(bytearray(shellcode))
n = len(shellcode)
n = len(shellcode)
naiveip_re = re . compile ( r"""^(?: (?P<addr>     (?P<ipv4>\d{1,3}(?:\.\d{1,3}){3}) |         # IPv4 address     (?P<ipv6>\[[a-fA-F0-9:]+\]) |               # IPv6 address     (?P<fqdn>[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN ):)?(?P<port>\d+)$""" , re . X )
name , ( value , params ) = _parse_header ( line )
name , ext = os . path . splitext ( name )
name , val = forbid_multi_line_headers ( name , val , 'ascii' )
name , val = forbid_multi_line_headers ( name , val , self . encoding )
name , value = main_value_pair . split ( ':' , 1 )
name , value = match . groups ( )
name . append ( ch )
name = _resolve_name ( name [ level : ] , package , level )
name = '.' . join ( parts )
name = "_%d" % num_args
name = "." . join ( [ package . __name__ , module_name ] )
name = ""
name = ""
name = [ ]
name = args [ - 1 ]
name = args [ 1 ]
name = config . get ( 'name' , '' )
name = content . name
name = getattr ( file , 'name' , None )
name = getattr ( func , "_decorated_function" , func ) . __name__
name = match . lastgroup
name = member . name
name = name [ : 255 - len ( ext ) ] + ext
name = os . path . basename ( name )
name = os . path . join ( dir_name , "%s_%s%s" % ( file_root , next ( count ) , file_ext ) )
name = p [ : i ] . strip ( ) . lower ( ) . decode ( 'ascii' )
name = property ( _get_name , _set_name )
name = s . split ( '.' )
name = self . _pk_field . name
name = self . _save ( name , content )
name = self . fk . name
name = self . format ( 'O' )
name = self . get_available_name ( name )
name = self . get_available_name ( name )
name = self . html_initial_name
name = self . html_name
name = self . path ( name )
name = self . split_leading_dir ( name ) [ 1 ]
name = self . split_leading_dir ( name ) [ 1 ]
name = self . timezone . tzname ( self . data ) if self . timezone else None
name = sign + hhmm
name_str = "; " . join (  "%s in %s" % ( ", " . join ( names ) , app )  for app , names in conflicts . items ( )  )
name_str = "; " . join (  "%s in %s" % ( ", " . join ( names ) , app )  for app , names in conflicts . items ( )  )
NamedTemporaryFile = tempfile . NamedTemporaryFile
NamedTemporaryFile = TemporaryFile
namelist = self . _archive . namelist ( )
namemap = options . get ( 'with' , { } )
namespaces [ namespace ] = ( p_pattern + prefix , sub_pattern )
namespaces [ pattern . namespace ] = ( p_pattern , pattern )
namespaces = { }
nan = ( 1e200 * 1e200 ) // ( 1e200 * 1e200 )
nasm = encoded.replace("z", "zzz")
nasm = encoded.replace("z", "zzz")
nasm = nasm[:-1]
nasm = nasm[:-1]
nasm = nasm[:-2]
nasm = nasm[:-3]
nasm = nasm[2:]
nasm = nasm[3:]
nasm = str(encoded).replace("\\x", ",0x")
nbits = str(sys.argv[2])
nbits = sys.argv[2]
nbits = sys.argv[3]
needs_multipart_form = False
needs_multipart_form = True
neg , value = self . convert ( i , self . decimal_digits , self . digits , '-' )
neg , value = self . convert ( s , self . digits , self . decimal_digits , self . sign )
neg = 0
neg = 1
neg_inf = - 1e200 * 1e200
nesting -= 1
nesting += 1
nesting = 0
nesting = 1
netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )
netloc = netloc . encode ( 'idna' ) . decode ( 'ascii' )
new ^= xor
new ^= xor
new ^= xor
new ^= xor
new = '#: ' + orig_file [ 2 : ]
new = ~i & 0xff
new = ~i & 0xff
new = i & 0xff
new = i & 0xff
new = name
new = new ^ c
new = new ^ temp
new = new ^ xor
new = new << shift
new = new << shift
new = new << temp
new = new >> shift
new = z << shift
new_args . append ( args [ : ] + i_args )
new_args = [ ]
new_attr = name
new_attr = old_attr
new_class . base_fields = declared_fields
new_class . base_fields = fields
new_class . declared_fields = declared_fields
new_class . media = media_property ( new_class )
new_class = ( super ( DeclarativeFieldsMetaclass , mcs )  . __new__ ( mcs , name , bases , attrs ) )
new_class = ( super ( MediaDefiningClass , mcs )  . __new__ ( mcs , name , bases , attrs ) )
new_class = super ( ModelFormMetaclass , mcs ) . __new__ ( mcs , name , bases , attrs )
new_class = super ( RenameMethodsBase , cls ) . __new__ ( cls , name , bases , attrs )
new_conn_created = self . open ( )
new_context . _reset_dicts ( values )
new_context [ 'csrf_token' ] = csrf_token
new_context = context_class ( _dict , ** {  'autoescape' : context . autoescape ,  'current_app' : context . current_app ,  'use_l10n' : context . use_l10n ,  'use_tz' : context . use_tz ,  } )
new_context = copy ( self )
new_environ [ "RUN_MAIN" ] = 'true'
new_environ = os . environ . copy ( )
new_errors = check ( app_configs = app_configs )
new_file . write ( content )
new_filenames . append ( os . path . join ( dirpath , filename ) )
new_filenames = [ filename . __file__ for filename in new_modules  if hasattr ( filename , '__file__' ) ]
new_ip . append ( '0000' )
new_ip += hextet [ 1 ] . split ( ':' )
new_ip = [ ]
new_ip = hextet [ 0 ] . split ( ':' )
new_ip = ip_str . split ( ':' )
new_key = self . key_func ( key , self . key_prefix , version )
new_keys = [ self . make_key ( x , version = version ) for x in keys ]
new_matches = normalize ( parent_pat + pat )
new_method = base . __dict__ . get ( new_method_name )
new_method_name = renamed_method [ 1 ]
new_migration = subclass ( "%04i_merge" % ( biggest_number + 1 ) , app_label )
new_migration = subclass ( "0001_squashed_%s" % migration . name , app_label )
new_mod = name
new_modules = module_values - _cached_modules
new_msg = (  "Database %s couldn't be flushed. Possible reasons:\n"  "  * The database isn't running or isn't configured correctly.\n"  "  * At least one of the expected database tables doesn't exist.\n"  "  * The SQL was invalid.\n"  "Hint: Look at the output of 'django-admin.py sqlflush'. That's the SQL this command wasn't able to run.\n"  "The full error: %s" ) % ( connection . settings_dict [ 'NAME' ] , e )
new_name , num_repl = re . subn ( r'\W' , '_' , new_name )
new_name += '_field'
new_name = '%s_%d' % ( new_name , num )
new_name = '%sfield' % new_name
new_name = 'field%s' % new_name
new_name = 'number_%s' % new_name
new_name = col_name . lower ( )
new_name = new_name . replace ( '__' , '_' )
new_name = new_name [ : - 3 ]
new_obj = func ( obj , * arg_vals )
new_obj = func ( obj , autoescape = context . autoescape , * arg_vals )
new_operations = optimizer . optimize ( operations , migration . app_label )
new_path = path . join ( top_dir , relative_dir ,  filename . replace ( base_name , name ) )
new_path = path [ match . end ( ) : ]
new_permissions = stat . S_IMODE ( st . st_mode ) | stat . S_IWUSR
new_result . append ( item + i_item )
new_result = [ ]
new_second_item . extend ( item )
new_second_item = [ ]
new_value . append ( self . coerce ( choice ) )
new_value = _strip_once ( value )
new_value = [ ]
new_value = value + delta
new_value = value + delta
newline = "\n"
newline = unicode ( "\n" )
newlines = property ( lambda self : self . file . newlines )
newretval = post_callback ( retval )
next = advance_iterator
next = index + len ( self . _boundary )
next_item = list_ [ i + 1 ]
ngettext_lazy = ngettext
nm , addr = addr
nm = Header ( nm , 'utf-8' ) . encode ( )
nm = Header ( nm , encoding ) . encode ( )
no_settings_commands = [  'help' , 'version' , '--help' , '--version' , '-h' ,  'compilemessages' , 'makemessages' ,  'startapp' , 'startproject' ,  ]
NOCOLOR_PALETTE = 'nocolor'
node . replace ( decorated )
node . source = token . source
node = CycleNode ( values , name , silent = silent )
node = CycleNode ( values )
nodelist . append ( node . render ( context ) )
nodelist . append ( node )
nodelist . contains_nontext = True
nodelist = [ ]
nodelist = getattr ( self , attr , None )
nodelist = parser . parse ( ( 'elif' , 'else' , 'endif' ) )
nodelist = parser . parse ( ( 'elif' , 'else' , 'endif' ) )
nodelist = parser . parse ( ( 'endautoescape' , ) )
nodelist = parser . parse ( ( 'endblock' , ) )
nodelist = parser . parse ( ( 'endfilter' , ) )
nodelist = parser . parse ( ( 'endif' , ) )
nodelist = parser . parse ( ( 'endspaceless' , ) )
nodelist = parser . parse ( ( 'endverbatim' , ) )
nodelist = parser . parse ( ( 'endwith' , ) )
nodelist = parser . parse ( )
nodelist = self . create_nodelist ( )
nodelist_empty = None
nodelist_empty = parser . parse ( ( 'endfor' , ) )
nodelist_false = NodeList ( )
nodelist_false = NodeList ( )
nodelist_false = parser . parse ( ( 'endifchanged' , ) )
nodelist_false = parser . parse ( ( end_tag , ) )
nodelist_loop = parser . parse ( ( 'else' , end_tag ) )
nodelist_loop = parser . parse ( ( 'empty' , 'endfor' , ) )
nodelist_true = parser . parse ( ( 'else' , 'endifchanged' ) )
nodelist_true_output = None
nodes . append ( self )
nodes . extend ( node . get_nodes_by_type ( nodetype ) )
nodes . extend ( nodelist . get_nodes_by_type ( nodetype ) )
nodes = [ ]
nodes = [ ]
nofollow_attr = ' rel="nofollow"' if nofollow else ''
nofollow_attr = ''
non_atomic_requests = getattr ( view , '_non_atomic_requests' , set ( ) )
non_capturing_groups . append ( len ( result ) )
non_capturing_groups = [ ]
NON_FIELD_ERRORS = '__all__'
none_model_fields = [ k for k , v in six . iteritems ( fields ) if not v ]
none_value = ( 0 , '---' )
nonlocal_root = [ root ]
norm_patterns = [ p [ : - len ( dir_suffix ) ] if p . endswith ( dir_suffix ) else p for p in self . ignore_patterns ]
normalize_newlines = allow_lazy ( normalize_newlines , six . text_type )
not_found . append ( e . args [ 0 ] )
not_found = [ ]
not_installed_models = set ( pending_references . keys ( ) )
notifier . check_events ( timeout = None )
notifier . process_events ( )
notifier . read_events ( )
notifier . stop ( )
notifier = pyinotify . Notifier ( wm , EventHandler ( ) )
now = datetime . datetime . now ( utc if is_aware ( d ) else None )
now = datetime . datetime ( now . year , now . month , now . day )
now = datetime . now ( )
now = datetime . now ( ) . strftime ( '%B %d, %Y - %X' )
now = datetime . utcnow ( )
now = now . decode ( 'utf-8' )
now = now . replace ( microsecond = 0 )
now = now . replace ( microsecond = 0 )
now = now . replace ( tzinfo = None )
now = timezone . now ( )
ns = "http://www.w3.org/2005/Atom"
ns = app_list [ 0 ]
ns = current_app
ns = path . pop ( )
ns_pattern = ''
ns_pattern = ns_pattern + extra
ns_resolver = RegexURLResolver ( ns_pattern , resolver . url_patterns )
num += 1
num = 0
num = 3
num = 3
num = 3
num = 3
num = cursor . fetchone ( ) [ 0 ]
num = cursor . fetchone ( ) [ 0 ]
num_args += 1
num_args = 0
num_entries = len ( filelist )
num_existing = len ( existing )
num_loopvars = len ( self . loopvars )
num_pages = property ( _get_num_pages )
num_sent += 1
num_sent = 0
number = '' . join ( reversed ( digits ) )
number = int ( number )
number = self . validate_number ( number )
number = str ( number ) [ 1 : ]
number_equal = len ( [ current_number for current_number in self . _unget_history  if current_number == num_bytes ] )
number_value = rhs
number_value = rhs [ number ]
numbers = [  MigrationAutodetector . parse_number ( migration . name )  for migration in merge_migrations  ]
obj . __class__ = cls
obj . __class__ = self . __class__
obj . _constructor_args = ( args , kwargs )
obj . attrs = self . attrs . copy ( )
obj . children = copy . deepcopy ( self . children , memodict )
obj . delete ( )
obj . pk = Model . _default_manager . db_manager ( db ) . get_by_natural_key ( * natural_key ) . pk
obj . save ( )
obj . save ( using = self . using )
obj . widgets = copy . deepcopy ( self . widgets )
obj = '%s.%s' % ( app , model . _meta . object_name )
obj = "?"
obj = base . build_instance ( Model , data , db )
obj = base . build_instance ( Model , data , self . db )
obj = copy . copy ( self )
obj = field . rel . to . _default_manager . db_manager ( db ) . get_by_natural_key ( * field_value )
obj = field . rel . to . _default_manager . db_manager ( self . db ) . get_by_natural_key ( * field_value )
obj = force_str ( self . obj )
obj = form . instance
obj = form . save ( commit = False )
obj = getattr ( models . signals , name )
obj = mark_for_escaping ( new_obj )
obj = mark_safe ( new_obj )
obj = Model ( ** data )
obj = new_obj
obj = Node ( children , connector , negated )
obj = Node ( connector = self . connector , negated = self . negated )
obj = None
obj = self . _new_instance ( self . children , self . connector ,  self . negated )
obj = self . var
obj = self . var . resolve ( context )
obj = settings . TEMPLATE_STRING_IF_INVALID
obj = super ( klass , cls ) . __new__ ( cls )
obj = super ( MultiWidget , self ) . __deepcopy__ ( memo )
obj = template_localtime ( obj , context . use_tz )
obj_dict [ '_data' ] = dict ( ( k , self . getlist ( k ) ) for k in self )
obj_dict = self . __dict__ . copy ( )
obj_dict = super ( SimpleTemplateResponse , self ) . __getstate__ ( )
obj_list = self . target . resolve ( context , True )
obj_pk = field . rel . to . _default_manager . db_manager ( self . db ) . get_by_natural_key ( * field_value ) . pk
obj_pk = field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )
obj_pk = field . rel . to . _meta . pk . to_python ( n . getAttribute ( 'pk' ) )
obj_pk = getattr ( obj , field . rel . field_name )
obj_pk = obj . _get_pk_val ( )
obj_pk = obj_pk . pk
object_data . update ( initial )
object_data = { }
object_data = model_to_dict ( instance , opts . fields , opts . exclude )
objects = json . loads ( stream_or_string )
objects = model . _base_manager
objects = model . _default_manager
objects = serializers . deserialize ( ser_fmt , fixture ,  using = self . using , ignorenonexistent = self . ignore )
objects_in_fixture += 1
objects_in_fixture = 0
odds = sum ( LUHN_ODD_LOOKUP [ int ( c ) ] for c in candidate [ - 2 : : - 2 ] )
off = 6 * ( delta // 100 + delta // 400 )
offset = - offset
offset = ( len ( self . __starttag_text )  - self . __starttag_text . rfind ( "\n" ) )
offset = 60 * int ( tzinfo [ 1 : 3 ] ) + offset_mins
offset = date . tzinfo . utcoffset ( date )
offset = offset . seconds // 60
offset = offset + len ( self . __starttag_text )
offset = self . __offset . seconds // 60
offset = self . timezone . utcoffset ( self . data )
offset_mins = int ( tzinfo [ - 2 : ] ) if len ( tzinfo ) > 3 else 0
old = '#: ' + work_file
old = '#: ' + work_file [ 2 : ]
old_app_dir = os . path . normpath ( os . path . join ( app_dir , 'models/sql' ) )
old_attr = name
old_field_name = field_name
old_field_name = None
old_field_name = None
old_handler = None
old_handler = signal . signal ( signal . SIGTTOU , signal . SIG_IGN )
old_method = base . __dict__ . get ( old_method_name )
old_method_name = renamed_method [ 0 ]
old_path = path . join ( root , filename )
old_setting = context . autoescape
old_style_list = True
old_umask = os . umask ( 0 )
oldkey = root [ KEY ]
oldroot [ KEY ] = key
oldroot [ RESULT ] = result
oldroot = root
oldvalue = root [ RESULT ]
one_percent_re = re . compile ( r"""(?<!%)%(?!%)""" )
op . id = key
op = OPERATORS [ token ]
open ( init_path , "w" ) . close ( )
open_method , mode = self . compression_formats [ cmp_fmt ]
open_tags . insert ( 0 , tagname )
open_tags = [ ]
open_tags = open_tags [ i + 1 : ]
operations . extend ( smigration . operations )
operations = [ ]
OPERATORS = {  'or' : infix ( 6 , lambda context , x , y : x . eval ( context ) or y . eval ( context ) ) ,  'and' : infix ( 7 , lambda context , x , y : x . eval ( context ) and y . eval ( context ) ) ,  'not' : prefix ( 8 , lambda context , x : not x . eval ( context ) ) ,  'in' : infix ( 9 , lambda context , x , y : x . eval ( context ) in y . eval ( context ) ) ,  'not in' : infix ( 9 , lambda context , x , y : x . eval ( context ) not in y . eval ( context ) ) ,  '=' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) ,  '==' : infix ( 10 , lambda context , x , y : x . eval ( context ) == y . eval ( context ) ) ,  '!=' : infix ( 10 , lambda context , x , y : x . eval ( context ) != y . eval ( context ) ) ,  '>' : infix ( 10 , lambda context , x , y : x . eval ( context ) > y . eval ( context ) ) ,  '>=' : infix ( 10 , lambda context , x , y : x . eval ( context ) >= y . eval ( context ) ) ,  '<' : infix ( 10 , lambda context , x , y : x . eval ( context ) < y . eval ( context ) ) ,  '<=' : infix ( 10 , lambda context , x , y : x . eval ( context ) <= y . eval ( context ) ) ,  }
opfunc . __doc__ = getattr ( int , opname ) . __doc__
opfunc . __name__ = opname
opt_dict = { 'bold' : '1' , 'underscore' : '4' , 'blink' : '5' , 'reverse' : '7' , 'conceal' : '8' }
opt_label += '='
opt_label = option [ 0 ]
optimizer = MigrationOptimizer ( )
option = '--testrunner='
option = remaining_bits . pop ( 0 )
option_list = ( )
option_value = ''
option_value = force_text ( option_value )
options , args = parser . parse_args ( argv [ 2 : ] )
options , args = parser . parse_known_args ( self . argv [ 2 : ] )
options . update ( kwargs )
options [ 'secret_key' ] = get_random_string ( 50 , chars )
options [ k . lower ( ) ] = v
options [ option ] = value
options += [ ( app_config . label , 0 ) for app_config in app_configs ]
options += [ ( k , 1 ) for k in FASTCGI_OPTIONS ]
options += [ ( s_opt . get_opt_string ( ) , s_opt . nargs ) for s_opt in  parser . option_list ]
options += [ ( sorted ( s_opt . option_strings ) [ 0 ] , s_opt . nargs != 0 ) for s_opt in  parser . _actions if s_opt . option_strings ]
options = [ ( '--help' , None ) ]
options = [ opt for opt in options if opt [ 0 ] not in prev_opts ]
options = { }
options = FASTCGI_OPTIONS . copy ( )
options = params . get ( 'OPTIONS' , { } )
options = parser . parse_args ( argv [ 2 : ] )
options = self . render_options ( choices , [ value ] )
options = self . render_options ( choices , value )
options = sorted ( ( k , v ) for k , v in options if k . startswith ( curr ) )
opts . fields = None
opts = instance . _meta
opts = model . _meta
opts = new_class . _meta = ModelFormOptions ( getattr ( new_class , 'Meta' , None ) )
opts = self . _meta
opts = self . _meta
opts = tuple ( s for s in styles if s in opt_dict . keys ( ) )
orig = []
orig = getattr ( self . parent_instance , self . to_field )
orig = self . parent_instance . pk
orig_file = os . path . join ( self . dirpath , self . file )
orig_vars . pop ( '__dict__' , None )
orig_vars . pop ( '__weakref__' , None )
orig_vars . pop ( slots_var )
origin = make_origin ( display_name , self . load_template_source , template_name , template_dirs )
origin = StringOrigin ( template_string )
original = UnicodeDecodeError . __str__ ( self )
original_lookup = lookup_view
original_shellcode += '%02x- ' %x
original_shellcode += '%02x, ' %x
os . _exit ( 1 )
os . chdir ( our_home_dir )
os . chmod ( dst , mode )
os . chmod ( filename , new_permissions )
os . chmod ( full_path , self . file_permissions_mode )
os . chmod ( path , stat . S_IWRITE )
os . close ( fd )
os . close ( fd )
os . close ( fd )
os . dup2 ( se . fileno ( ) , sys . stderr . fileno ( ) )
os . dup2 ( si . fileno ( ) , sys . stdin . fileno ( ) )
os . dup2 ( so . fileno ( ) , sys . stdout . fileno ( ) )
os . environ [ 'DJANGO_LIVE_TEST_SERVER_ADDRESS' ] = options [ 'liveserver' ]
os . environ [ 'DJANGO_SETTINGS_MODULE' ] = options . settings
os . kill ( os . getpid ( ) , - exit_code )
os . makedirs ( basedir )
os . makedirs ( directory , self . directory_permissions_mode )
os . makedirs ( directory )
os . makedirs ( dirname )
os . makedirs ( filename )
os . makedirs ( original_path )
os . makedirs ( self . _dir , 0o700 )
os . makedirs ( self . default_locale_path )
os . makedirs ( self . file_path )
os . makedirs ( top_dir )
os . mkdir ( migrations_directory )
os . mkdir ( target_dir )
os . remove ( fname )
os . remove ( name )
os . remove ( old_file_name )
os . remove ( path_to_remove )
os . remove ( symlink_path )
os . remove ( tmp_path )
os . rename ( old_file_name , new_file_name )
os . rmdir ( original_path )
os . rmdir ( tmpdir )
os . setsid ( )
os . symlink ( original_path , symlink_path )
os . umask ( old_umask )
os . umask ( umask )
os . umask ( umask )
os . unlink ( pot_path )
os . unlink ( work_file )
os . utime ( dst , ( st . st_atime , st . st_mtime ) )
os . utime ( path , None )
os . write ( fd , current_chunk )
other = other . __cast ( )
other_dict = args [ 0 ]
out . write ( ' _(%s) ' % cmatch . group ( 1 ) )
out . write ( ' _(%s) ' % cmatch )
out . write ( ' _(%s) ' % fmatch )
out . write ( ' # %s' % line )
out . write ( ' #\n' )
out . write ( ' %s ' % p . split ( ':' , 1 ) [ 1 ] )
out . write ( ' gettext(%r) ' % g )
out . write ( ' gettext(%r) ' % join_tokens ( singular ,  trimmed ) )
out . write ( ' ngettext(%r, %r, count) ' % (  join_tokens ( singular , trimmed ) ,  join_tokens ( plural , trimmed ) ) )
out . write ( ' npgettext(%r, %r, %r,count) ' % (  message_context ,  join_tokens ( singular , trimmed ) ,  join_tokens ( plural , trimmed ) ) )
out . write ( ' pgettext(%r, %r) ' % (  message_context ,  join_tokens ( singular , trimmed ) ) )
out . write ( ' pgettext(%r, %r) ' % ( message_context , g ) )
out . write ( '# %s' % ' | ' . join ( lineno_comment_map [ comment_lineno_cache ] ) )
out . write ( blankout ( p , 'F' ) )
out . write ( blankout ( part , 'P' ) )
out . write ( blankout ( part , 'S' ) )
out . write ( blankout ( t . contents , 'B' ) )
out . write ( blankout ( t . contents , 'X' ) )
out += '</%s>' % tag
out += truncate_text
out = [ str ( x ) for x in [ self . id , self . first , self . second ] if x is not None ]
out = b'' . join ( parts ( ) )
out = self . compress ( clean_data )
out = StringIO ( '' )
out = text [ : end_text_pos ]
outdict [ name ] = value , params
outdict = { }
outer . update ( password . translate ( hmac . trans_5C ) )
outer_html = '<ul{id_attr}>{content}</ul>'
outfile . write ( data )
output , errors , status = popen_wrapper ( args )
output , errors = p . communicate ( )
output , hidden_fields = [ ] , [ ]
output , references = connection . creation . sql_create_model ( model , style , known_models )
output . append ( '* %s' % field )
output . append ( '\n' . join ( '  * %s' % e for e in errors ) )
output . append ( '\n\n' )
output . append ( '%s<li>%s%s</li>' % ( indent ,  escaper ( force_text ( title ) ) , sublist ) )
output . append ( '</optgroup>' )
output . append ( '</select>' )
output . append ( "### %s = %s" % ( key , user_settings [ key ] ) )
output . append ( "%s = %s  ###" % ( key , user_settings [ key ] ) )
output . append ( "%s = %s" % ( key , user_settings [ key ] ) )
output . append ( app_output )
output . append ( error_row % force_text ( bf_errors ) )
output . append ( format_html ( '<optgroup label="{0}">' , force_text ( option_value ) ) )
output . append ( format_html ( self . inner_html ,  choice_value = force_text ( w ) , sub_widgets = '' ) )
output . append ( format_html ( self . inner_html , choice_value = choice_value ,  sub_widgets = sub_ul_renderer . render ( ) ) )
output . append ( html [ field ] )
output . append ( label_output )
output . append ( last_row )
output . append ( normal_row % {  'errors' : force_text ( bf_errors ) ,  'label' : force_text ( label ) ,  'field' : six . text_type ( bf ) ,  'help_text' : help_text ,  'html_class_attr' : html_class_attr ,  'field_name' : bf . html_name ,  } )
output . append ( options )
output . append ( pformat ( sys . modules ) )
output . append ( self . render_option ( selected_choices , * option ) )
output . append ( self . render_option ( selected_choices , option_value , option_label ) )
output . append ( str_hidden )
output . append ( widget . render ( name + '_%s' % i , widget_value , final_attrs ) )
output . extend ( [ encode ( k , force_bytes ( v , self . encoding ) )  for v in list_ ] )
output . extend ( connection . creation . sql_destroy_indexes_for_model ( model , style ) )
output . extend ( connection . creation . sql_destroy_model ( model , references_to_delete , style ) )
output . extend ( connection . creation . sql_indexes_for_model ( model , style ) )
output . extend ( connection . ops . prepare_sql_script ( fp . read ( ) , _allow_fallback = True ) )
output . extend ( custom_sql_for_model ( model , style , connection ) )
output . extend ( f . post_create_sql ( style , model . _meta . db_table ) )
output . insert ( 0 , error_row % force_text ( top_errors ) )
output [ - 1 ] = last_row [ : - len ( row_ender ) ] + str_hidden + row_ender
output = ''
output = [ ]
output = [ ]
output = [ ]
output = [ ]
output = [ ]
output = [ format_html ( '<select multiple="multiple"{0}>' , flatatt ( final_attrs ) ) ]
output = [ format_html ( '<select{0}>' , flatatt ( final_attrs ) ) ]
output = [ pformat ( val ) for val in context ]
output = force_text ( output )
output = fp . read ( )
output = localize ( output , use_l10n = context . use_l10n )
output = next ( self . _producer )
output = options . get ( 'output' )
output = self . _leftover
output = self . filter_expression . resolve ( context )
output = self . handle ( * args , ** options )
output = self . nodelist . render ( context )
output = self . nodelist . render ( context )
output = template_localtime ( output , use_tz = context . use_tz )
output_transaction = False
output_transaction = True
output_transaction = True
over_bytes = len ( chunk ) % 4
over_chunk = field_stream . read ( 4 - over_bytes )
overlapped = OVERLAPPED ( )
P = '\033[35m'
P = '\033[35m'
P = '\033[35m'
p = i
p = i
p = int ( arg )
p = language . find ( '-' )
p = language . find ( '-' )
p = locale . find ( '_' )
p = PillowImageFile . Parser ( )
p = Popen ( args , shell = False , stdout = PIPE , stderr = PIPE ,  close_fds = os . name != 'nt' , universal_newlines = True )
p_pattern = p_pattern [ 1 : ]
p_pattern = pattern . regex . pattern
p1 , p2 = urlparse ( url1 ) , urlparse ( url2 )
package = import_module ( path )
package_name = package . __name__
package_path = package . __path__
padding = 4 - (len(temp) % 4)
padding = 4 - len(shellcode_original)
padding = 4 - len(shellcode_original) % 4
padding = len(shellcode_original) % 4
page_range = property ( _get_page_range )
palette . update ( PALETTES [ part ] )
palette [ role ] = definition
palette = PALETTES [ NOCOLOR_PALETTE ] . copy ( )
PALETTES = {  NOCOLOR_PALETTE : {  'ERROR' : { } ,  'WARNING' : { } ,  'NOTICE' : { } ,  'SQL_FIELD' : { } ,  'SQL_COLTYPE' : { } ,  'SQL_KEYWORD' : { } ,  'SQL_TABLE' : { } ,  'HTTP_INFO' : { } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { } ,  'HTTP_NOT_MODIFIED' : { } ,  'HTTP_BAD_REQUEST' : { } ,  'HTTP_NOT_FOUND' : { } ,  'HTTP_SERVER_ERROR' : { } ,  'MIGRATE_HEADING' : { } ,  'MIGRATE_LABEL' : { } ,  'MIGRATE_SUCCESS' : { } ,  'MIGRATE_FAILURE' : { } ,  } ,  DARK_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'yellow' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'cyan' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'yellow' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  } ,  LIGHT_PALETTE : {  'ERROR' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'WARNING' : { 'fg' : 'yellow' , 'opts' : ( 'bold' , ) } ,  'NOTICE' : { 'fg' : 'red' } ,  'SQL_FIELD' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'SQL_COLTYPE' : { 'fg' : 'green' } ,  'SQL_KEYWORD' : { 'fg' : 'blue' } ,  'SQL_TABLE' : { 'opts' : ( 'bold' , ) } ,  'HTTP_INFO' : { 'opts' : ( 'bold' , ) } ,  'HTTP_SUCCESS' : { } ,  'HTTP_REDIRECT' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_MODIFIED' : { 'fg' : 'green' } ,  'HTTP_BAD_REQUEST' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  'HTTP_NOT_FOUND' : { 'fg' : 'red' } ,  'HTTP_SERVER_ERROR' : { 'fg' : 'magenta' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_HEADING' : { 'fg' : 'cyan' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_LABEL' : { 'opts' : ( 'bold' , ) } ,  'MIGRATE_SUCCESS' : { 'fg' : 'green' , 'opts' : ( 'bold' , ) } ,  'MIGRATE_FAILURE' : { 'fg' : 'red' , 'opts' : ( 'bold' , ) } ,  }  }
param , value = list ( six . iteritems ( kwarg ) ) [ 0 ]
param = '' . join ( name )
param = elt [ 1 ]
param = None
params , varargs , varkw , defaults = getargspec ( func )
params , varargs , varkw , defaults = getargspec ( func )
params . update ( kwargs )
params = [ ]
params = [ source [ 1 ] ]
params = { 'datetime' : value , 'current_timezone' : current_timezone }
params = { 'limit_value' : self . limit_value , 'show_value' : cleaned }
params = { 'max' : self . max_length , 'length' : len ( file_name ) }
params = conf . copy ( )
params = kwargs
params = params [ 1 : ]
paras = [ '<p>%s</p>' % escape ( p ) . replace ( '\n' , '<br />' ) for p in paras ]
paras = [ '<p>%s</p>' % p . replace ( '\n' , '<br />' ) for p in paras ]
paras = re . split ( '\n{2,}' , value )
parent = ( form . Meta , object )
parent = ( object , )
parent = self . parent_name . resolve ( context )
parent_name = parser . compile_filter ( bits [ 1 ] )
parent_pat = pattern . regex . pattern
parentloop = { }
parentloop = context [ 'forloop' ]
parentmod , submod = get_mod_func ( mod_name )
parse = sys . modules [ __name__ + ".moves.urllib_parse" ]
parse_until = [ ]
parsed = False
parsed = True
parsed = urlparse ( force_text ( redirect_to ) )
parser . __loaded_blocks . append ( block_name )
parser . __loaded_blocks = [ block_name ]
parser . _namedCycleNodes [ name ] = node
parser . _namedCycleNodes = { }
parser . add_argument ( '--addrport' , default = '' ,  help = 'Port number or ipaddr:port to run the server on.' )
parser . add_argument ( '--all' , '-a' , action = 'store_true' , dest = 'all' ,  default = False , help = 'Updates the message files for all existing locales.' )
parser . add_argument ( '--all' , action = 'store_true' , dest = 'all' , default = False ,  help = 'Display all settings, regardless of their value. '  'Default values are prefixed by "###".' )
parser . add_argument ( '--app' , action = 'store' , dest = 'app_label' ,  default = None , help = 'Only look for fixtures in the specified app.' )
parser . add_argument ( '--backwards' , action = 'store_true' , dest = 'backwards' ,  default = False , help = 'Creates SQL to unapply the migration, rather than to apply it' )
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database onto which the cache tables will be '  'installed. Defaults to the "default" database.' )
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to flush. Defaults to the "default" database.' )
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS ,  help = 'Nominates a specific database to dump fixtures from. '  'Defaults to the "default" database.' )
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a database onto which to '  'open a shell. Defaults to the "default" database.' )
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a database to '  'introspect. Defaults to using the "default" database.' )
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a database to synchronize. '  'Defaults to the "default" database.' )
parser . add_argument ( '--database' , action = 'store' , dest = 'database' ,  default = DEFAULT_DB_ALIAS , help = 'Nominates a specific database to load '  'fixtures into. Defaults to the "default" database.' )
parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to create SQL for. Defaults to the '  '"default" database.' )
parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to print the SQL for. Defaults to the '  '"default" database.' )
parser . add_argument ( '--database' , default = DEFAULT_DB_ALIAS ,  help = 'Nominates a database to synchronize. Defaults to the "default" database.' )
parser . add_argument ( '--domain' , '-d' , default = 'django' , dest = 'domain' ,  help = 'The domain of the message files (default: "django").' )
parser . add_argument ( '--dry-run' , action = 'store_true' , dest = 'dry_run' , default = False ,  help = "Just show what migrations would be made; don't actually write them." )
parser . add_argument ( '--empty' , action = 'store_true' , dest = 'empty' , default = False ,  help = "Create an empty migration." )
parser . add_argument ( '--exclude' , '-x' , default = [ ] , dest = 'exclude' , action = 'append' ,  help = 'Locales to exclude. Default is none. Can be used multiple times.' )
parser . add_argument ( '--exclude' , '-x' , dest = 'exclude' , action = 'append' , default = [ ] ,  help = 'Locales to exclude. Default is none. Can be used multiple times.' )
parser . add_argument ( '--extension' , '-e' , dest = 'extensions' ,  action = 'append' , default = [ 'py' ] ,  help = 'The file extension(s) to render (default: "py"). '  'Separate multiple extensions with commas, or use '  '-e multiple times.' )
parser . add_argument ( '--extension' , '-e' , dest = 'extensions' ,  help = 'The file extension(s) to examine (default: "html,txt", or "js" '  'if the domain is "djangojs"). Separate multiple extensions with '  'commas, or use -e multiple times.' ,  action = 'append' )
parser . add_argument ( '--failfast' ,  action = 'store_true' , dest = 'failfast' , default = False ,  help = 'Tells Django to stop running the test suite after first '  'failed test.' ) ,
parser . add_argument ( '--fake' , action = 'store_true' , dest = 'fake' , default = False ,  help = 'Mark migrations as run without actually running them' )
parser . add_argument ( '--format' , default = 'json' , dest = 'format' ,  help = 'Specifies the output serialization format for fixtures.' )
parser . add_argument ( '--ignore' , '-i' , action = 'append' , dest = 'ignore_patterns' ,  default = [ ] , metavar = 'PATTERN' ,  help = 'Ignore files or directories matching this glob-style pattern. '  'Use multiple times to ignore more.' )
parser . add_argument ( '--ignorenonexistent' , '-i' , action = 'store_true' ,  dest = 'ignore' , default = False ,  help = 'Ignores entries in the serialized data for fields that do not '  'currently exist on the model.' )
parser . add_argument ( '--indent' , default = None , dest = 'indent' , type = int ,  help = 'Specifies the indent level to use when pretty-printing output.' )
parser . add_argument ( '--ipv6' , '-6' , action = 'store_true' , dest = 'use_ipv6' , default = False ,  help = 'Tells Django to use an IPv6 address.' )
parser . add_argument ( '--ipv6' , '-6' , action = 'store_true' , dest = 'use_ipv6' , default = False ,  help = 'Tells Django to use an IPv6 address.' )
parser . add_argument ( '--keep-pot' , action = 'store_true' , dest = 'keep_pot' ,  default = False , help = "Keep .pot file after making messages. Useful when debugging." )
parser . add_argument ( '--list-tags' , action = 'store_true' , dest = 'list_tags' ,  help = 'List available tags.' )
parser . add_argument ( '--list' , '-l' , action = 'store_true' , dest = 'list' , default = False ,  help = 'Show a list of all known migrations and which are applied' )
parser . add_argument ( '--liveserver' ,  action = 'store' , dest = 'liveserver' , default = None ,  help = 'Overrides the default address where the live server (used '  'with LiveServerTestCase) is expected to run from. The '  'default value is localhost:8081.' ) ,
parser . add_argument ( '--locale' , '-l' , default = [ ] , dest = 'locale' , action = 'append' ,  help = 'Creates or updates the message files for the given locale(s) (e.g. pt_BR). '  'Can be used multiple times.' )
parser . add_argument ( '--locale' , '-l' , dest = 'locale' , action = 'append' , default = [ ] ,  help = 'Locale(s) to process (e.g. de_AT). Default is to process all. '  'Can be used multiple times.' )
parser . add_argument ( '--merge' , action = 'store_true' , dest = 'merge' , default = False ,  help = "Enable fixing of migration conflicts." )
parser . add_argument ( '--name' , '-n' , dest = 'files' ,  action = 'append' , default = [ ] ,  help = 'The file name(s) to render. '  'Separate multiple extensions with commas, or use '  '-n multiple times.' )
parser . add_argument ( '--natural-foreign' , action = 'store_true' , dest = 'use_natural_foreign_keys' , default = False ,  help = 'Use natural foreign keys if they are available.' )
parser . add_argument ( '--natural-primary' , action = 'store_true' , dest = 'use_natural_primary_keys' , default = False ,  help = 'Use natural primary keys if they are available.' )
parser . add_argument ( '--no-color' , action = 'store_true' , dest = 'no_color' , default = False ,  help = "Don't colorize the command output." )
parser . add_argument ( '--no-default-ignore' , action = 'store_false' , dest = 'use_default_ignore_patterns' ,  default = True , help = "Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'." )
parser . add_argument ( '--no-initial-data' , action = 'store_false' ,  dest = 'load_initial_data' , default = True ,  help = 'Tells Django not to load any initial data after database synchronization.' )
parser . add_argument ( '--no-initial-data' , action = 'store_false' , dest = 'load_initial_data' , default = True ,  help = 'Tells Django not to load any initial data after database synchronization.' )
parser . add_argument ( '--no-initial-data' , action = 'store_false' , dest = 'load_initial_data' , default = True ,  help = 'Tells Django not to load any initial data after database synchronization.' )
parser . add_argument ( '--no-location' , action = 'store_true' , dest = 'no_location' ,  default = False , help = "Don't write '#: filename:line' lines." )
parser . add_argument ( '--no-obsolete' , action = 'store_true' , dest = 'no_obsolete' ,  default = False , help = "Remove obsolete message strings." )
parser . add_argument ( '--no-optimize' , action = 'store_true' , dest = 'no_optimize' , default = False ,  help = 'Do not try to optimize the squashed operations.' )
parser . add_argument ( '--no-startup' , action = 'store_true' , dest = 'no_startup' ,  help = 'When using plain Python, ignore the PYTHONSTARTUP environment variable and ~/.pythonrc.py script.' )
parser . add_argument ( '--no-wrap' , action = 'store_true' , dest = 'no_wrap' ,  default = False , help = "Don't break long message lines into several lines." )
parser . add_argument ( '--noinput' ,  action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' ) ,
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
parser . add_argument ( '--noinput' , action = 'store_false' , dest = 'interactive' , default = True ,  help = 'Tells Django to NOT prompt the user for input of any kind.' )
parser . add_argument ( '--noreload' , action = 'store_false' , dest = 'use_reloader' , default = True ,  help = 'Tells Django to NOT use the auto-reloader.' )
parser . add_argument ( '--nothreading' , action = 'store_false' , dest = 'use_threading' , default = True ,  help = 'Tells Django to NOT use threading.' )
parser . add_argument ( '--pks' , dest = 'primary_keys' ,  help = "Only dump objects with given primary keys. "  "Accepts a comma separated list of keys. "  "This option will only work when you specify one model." )
parser . add_argument ( '--plain' , action = 'store_true' , dest = 'plain' ,  help = 'Tells Django to use plain Python, not IPython or bpython.' )
parser . add_argument ( '--pythonpath' ,  help = 'A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".' )
parser . add_argument ( '--pythonpath' )
parser . add_argument ( '--settings' ,  help = 'The Python path to a settings module, e.g. "myproject.settings.main". If this isn\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.' )
parser . add_argument ( '--settings' )
parser . add_argument ( '--symlinks' , '-s' , action = 'store_true' , dest = 'symlinks' ,  default = False , help = 'Follows symlinks to directories when examining '  'source code and templates for translation strings.' )
parser . add_argument ( '--tag' , '-t' , action = 'append' , dest = 'tags' ,  help = 'Run only checks labeled with given tag.' )
parser . add_argument ( '--template' ,  help = 'The path or URL to load the template from.' )
parser . add_argument ( '--testrunner' ,  action = 'store' , dest = 'testrunner' ,  help = 'Tells Django to use specified test runner class instead of '  'the one specified by the TEST_RUNNER setting.' ) ,
parser . add_argument ( '--traceback' , action = 'store_true' ,  help = 'Raise on exception' )
parser . add_argument ( '--version' , action = 'version' , version = self . get_version ( ) )
parser . add_argument ( '-a' , '--all' , action = 'store_true' , dest = 'use_base_manager' , default = False ,  help = "Use Django's base manager to dump all models stored in the database, "  "including those that would otherwise be filtered or modified by a custom manager." )
parser . add_argument ( '-e' , '--exclude' , dest = 'exclude' , action = 'append' , default = [ ] ,  help = 'An app_label or app_label.ModelName to exclude '  '(use multiple --exclude to exclude multiple apps/models).' )
parser . add_argument ( '-i' , '--interface' , choices = self . shells , dest = 'interface' ,  help = 'Specify an interactive interpreter interface. Available options: "ipython" and "bpython"' )
parser . add_argument ( '-n' , '--natural' , action = 'store_true' , dest = 'use_natural_keys' , default = False ,  help = 'Use natural keys if they are available (deprecated: use --natural-foreign instead).' )
parser . add_argument ( '-o' , '--output' , default = None , dest = 'output' ,  help = 'Specifies file to which the output is written.' )
parser . add_argument ( '-v' , '--verbosity' , action = 'store' , dest = 'verbosity' , default = '1' ,  type = int , choices = [ 0 , 1 , 2 , 3 ] ,  help = 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output' )
parser . add_argument ( 'addrport' , nargs = '?' ,  help = 'Optional port number, or ipaddr:port' )
parser . add_argument ( 'app_label' ,  help = 'App label of the application containing the migration.' )
parser . add_argument ( 'app_label' ,  help = 'App label of the application to squash migrations for.' )
parser . add_argument ( 'app_label' , nargs = '?' ,  help = 'App label of an application to synchronize the state.' )
parser . add_argument ( 'args' , metavar = 'app_label' , nargs = '*' ,  help = 'Specify the app label(s) to create migrations for.' )
parser . add_argument ( 'args' , metavar = 'app_label' , nargs = '*' )
parser . add_argument ( 'args' , metavar = 'app_label' , nargs = '+' ,  help = 'One or more application label.' )
parser . add_argument ( 'args' , metavar = 'app_label[.ModelName]' , nargs = '*' ,  help = 'Restricts dumped data to the specified app_label or app_label.ModelName.' )
parser . add_argument ( 'args' , metavar = 'fixture' , nargs = '*' ,  help = 'Path(s) to fixtures to load before running the server.' )
parser . add_argument ( 'args' , metavar = 'fixture' , nargs = '+' ,  help = 'Fixture labels.' )
parser . add_argument ( 'args' , metavar = 'table_name' , nargs = '*' ,  help = 'Optional table names. Otherwise, settings.CACHES is used to '  'find cache tables.' )
parser . add_argument ( 'args' , metavar = 'test_label' , nargs = '*' ,  help = 'Module paths to test; can be modulename, modulename.TestCase or modulename.TestCase.test_method' )
parser . add_argument ( 'args' , metavar = self . label , nargs = '+' )
parser . add_argument ( 'args' , nargs = '*' )
parser . add_argument ( 'args' , nargs = '*' )
parser . add_argument ( 'args' , nargs = argparse . REMAINDER ,  help = 'Various KEY=val options.' )
parser . add_argument ( 'directory' , nargs = '?' , help = 'Optional destination directory' )
parser . add_argument ( 'migration_name' ,  help = 'Migration name to print the SQL for.' )
parser . add_argument ( 'migration_name' ,  help = 'Migrations will be squashed until and including this migration.' )
parser . add_argument ( 'migration_name' , nargs = '?' ,  help = 'Database state will be brought to the state after that migration.' )
parser . add_argument ( 'name' , help = 'Name of the application or project.' )
parser . add_library ( lib )
parser . add_library ( temp_lib )
parser . add_option ( '--no-color' , action = 'store_true' , dest = 'no_color' , default = False ,  help = "Don't colorize the command output." )
parser . add_option ( '--pythonpath' ,  help = 'A directory to add to the Python path, e.g. "/home/djangoprojects/myproject".' ) ,
parser . add_option ( '--settings' ,  help = 'The Python path to a settings module, e.g. "myproject.settings.main". If this isn\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.' )
parser . add_option ( '--traceback' , action = 'store_true' ,  help = 'Raise on exception' )
parser . add_option ( '-v' , '--verbosity' , action = 'store' , dest = 'verbosity' , default = '1' ,  type = 'choice' , choices = [ '0' , '1' , '2' , '3' ] ,  help = 'Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output' )
parser . add_option ( opt )
parser . delete_first_token ( )
parser . EntityDeclHandler = self . entity_decl
parser . ExternalEntityRefHandler = self . external_entity_ref_handler
parser . invalid_block_tag ( endblock , 'endblock' , acceptable_endblocks )
parser . print_help ( )
parser . skip_past ( 'endcomment' )
parser . StartDoctypeDeclHandler = self . start_doctype_decl
parser . UnparsedEntityDeclHandler = self . unparsed_entity_decl
parser = argparse.ArgumentParser()
parser = command . create_parser ( '' , name )
parser = CommandParser ( None , usage = "%(prog)s subcommand [options] [args]" , add_help = False )
parser = CommandParser ( self , prog = "%s %s" % ( os . path . basename ( prog_name ) , subcommand ) ,  description = self . help or None )
parser = MultiPartParser ( META , post_data , self . upload_handlers , self . encoding )
parser = OptionParser ( prog = prog_name ,  usage = self . usage ( subcommand ) ,  version = self . get_version ( ) )
parser = parser_class ( lexer . tokenize ( ) )
parser = self . _parser
parser = self . create_parser ( argv [ 0 ] , argv [ 1 ] )
parser = self . create_parser ( prog_name , subcommand )
parser = subcommand_cls . create_parser ( '' , cwords [ 0 ] )
parts . append ( "(?P<%s>%s)" % ( groupid , tok . regex ) )
parts . append ( decimals )
parts . append ( value )
parts . reverse ( )
parts = [ ]
parts = 2 if version [ 2 ] == 0 else 3
parts = config_string . lower ( ) . split ( ';' )
parts = fixture_name . rsplit ( '.' , 2 )
parts = parts [ : - 1 ]
parts = t . contents . split ( '|' )
parts = viewname . split ( ':' )
pass
pass
pass
pass
pass
password += b'\x00' * ( inner . block_size - len ( password ) )
password = digest ( password ) . digest ( )
password = force_bytes ( password )
patch_cache_control ( response , max_age = cache_timeout )
patch_response_headers ( response , cache_timeout = - 1 )
path , module = name . rsplit ( '.' , 1 )
path = [ path ]
path = force_text ( path )
path = join ( os . getcwdu ( ) , path )
path = kwargs . pop ( 'path' , None )
path = os . environ . get ( 'PATH' , '' ) . split ( os . pathsep )
path = os . path . join ( app_config . path , 'management' )
path = parts [ 1 : ]
path = path . lstrip ( '/' ) . lstrip ( '\\' )
path = path_override if path_override is not None else request . path
path = safe_join ( self . location , name )
path = self . path ( path )
path = str ( path )
path_info = '/'
path_info = get_bytes_from_wsgi ( environ , 'PATH_INFO' , '' )
path_info = get_bytes_from_wsgi ( environ , 'PATH_INFO' , '/' )
path_info = get_path_info ( environ )
path_rest = root [ prefix_length : ]
pathext = [ '' ]
pathext = os . environ . get ( 'PATHEXT' , '.COM;.EXE;.BAT;.CMD' ) . split ( os . pathsep )
paths = [ force_text ( p ) for p in paths ]
PATTERN = """     classdef< 'class' any+ ':'               suite< any*                      funcdef< 'def' unifunc='__unicode__'                               parameters< '(' NAME ')' > any+ >                      any* > >     """
pattern = pattern . lower ( )
pattern_iter = next_char ( iter ( pattern ) )
patterns = [ pattern for ( possibility , pattern , defaults ) in possibilities ]
patterns = getattr ( self . urlconf_module , "urlpatterns" , self . urlconf_module )
payload = text . encode ( utf8_charset . output_charset )
PB = 1 << 50
pdict [ name ] = value
pdict = { }
pending_references . setdefault ( refto , [ ] ) . extend ( refs )
pending_references . setdefault ( refto , [ ] ) . extend ( refs )
pending_references = { }
pending_references = { }
pflen = len ( prefixed )
pgettext_lazy = lazy ( pgettext , six . text_type )
phone2numeric = allow_lazy ( phone2numeric )
pickled = None
pickled = pickle . dumps ( new_value , pickle . HIGHEST_PROTOCOL )
pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )
pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )
pickled = pickle . dumps ( value , pickle . HIGHEST_PROTOCOL )
pickled = self . _cache [ key ]
pid = 1
pid = os . getpid ( )
piece += elt [ 0 ]
piece = '' . join ( source [ last : ] )
piece = '' . join ( source [ last : pos ] )
pieces . append ( force_text ( getattr ( self , piece ) ( ) ) )
pieces . append ( re_escaped . sub ( r'\1' , piece ) )
pieces = [ ]
pieces = accept_language_re . split ( lang_string . lower ( ) )
pk = self . data [ pk_key ]
pk = to_python ( pk )
pk_field = self . model . _meta . pk
pk_key = "%s-%s" % ( self . add_prefix ( i ) , self . model . _meta . pk . name )
pk_value = form . instance . pk
pk_value = getattr ( self . instance , self . fk . rel . field_name )
pk_value = None
pk_value = self . get_queryset ( ) [ index ] . pk
pkg_name = 'templates/' + template_name
pks = options . get ( 'primary_keys' )
pks = set ( force_text ( getattr ( o , key ) ) for o in qs )
plan = [ ( executor . loader . graph . nodes [ targets [ 0 ] ] , options [ 'backwards' ] ) ]
plan = executor . migration_plan ( executor . loader . graph . leaf_nodes ( ) )
plan = executor . migration_plan ( targets )
plat = sys . platform
plen = len ( provided ) + 1
plist . append ( f . strip ( ) )
plist = _parse_header_params ( b';' + line )
plist = [ ]
plural . append ( '%%(%s)s' % t . contents )
plural . append ( contents )
plural = [ ]
plural_form_line = force_str ( m . group ( 'value' ) )
plural_forms_re = re . compile ( r'^(?P<value>"Plural-Forms.+?\\n")\s*$' , re . MULTILINE | re . DOTALL )
plural_re = re . compile ( r"""^\s*plural$""" )
pluralmatch = plural_re . match ( t . contents )
po_path = os . path . join ( dirpath , f )
pofile = os . path . join ( basedir , '%s.po' % str ( self . domain ) )
pop = complain
pop_context = False
pop_context = True
pos = 0
pos = last = 0
pos = m . end ( 0 )
pos = self . file . tell ( )
pos_inf = 1e200 * 1e200
possibilities = self . reverse_dict . getlist ( lookup_view )
possible_sizes = [ x . chunk_size for x in upload_handlers if x . chunk_size ]
post = '<could not parse>'
post = ( pformat ( POST_override )  if POST_override is not None  else pformat ( request . POST ) )
POST = property ( _get_post , _set_post )
post_sql_fields = [ f for f in opts . local_fields if hasattr ( f , 'post_create_sql' ) ]
pot_path = os . path . join ( path , '%s.pot' % str ( self . domain ) )
potfile = os . path . join ( path , '%s.pot' % str ( self . domain ) )
potfile = os . path . join ( self . locale_dir , '%s.pot' % str ( domain ) )
potfiles . append ( potfile )
potfiles = [ ]
potfiles = self . build_potfiles ( )
prec = abs ( p ) + units + 1
prefix , rest = self . split_leading_dir ( path )
prefix += '/'
prefix = 'django_%s_template_' % self . app_or_project
prefix = 'django_%s_template_' % self . app_or_project
prefix = d [ 'prefix' ]
prefix = get_script_prefix ( )
prefix = self . add_prefix ( fieldname )
prefix = settings . MEDIA_URL
prefix = settings . STATIC_URL
prefix_length = len ( template_dir ) + 1
prefix_norm , prefix_args = normalize ( urlquote ( _prefix ) ) [ 0 ]
prefixed = name + "."
prefixed_name = self . add_prefix ( name )
PREV , NEXT , KEY , RESULT = 0 , 1 , 2 , 3
prev_opts = [ x . split ( '=' ) [ 0 ] for x in cwords [ 1 : cword - 1 ] ]
primary_keys = [ ]
primary_keys = pks . split ( ',' )
print ( ' ' . join ( sorted ( filter ( lambda x : x . startswith ( curr ) , subcommands ) ) ) )
print ( "Can't import flup." + flup_module )
print ( "In the tar file %s the member %s is invalid: %s" %  ( name , member . name , exc ) )
print ( "Running post-migrate handlers for application %s" % app_config . label )
print ( "Running pre-migrate handlers for application %s" % app_config . label )
print ( FASTCGI_HELP )
print ( message )
print ( opt_label )
print_ = getattr ( moves . builtins , "print" , None )
priority = 1.0
priority = float ( priority )
problem_fields = [  field  for model in apps . get_models ( ** kwargs )  if app_configs is None or model . _meta . app_config in app_configs  for field in model . _meta . local_fields  if isinstance ( field , models . BooleanField ) and not field . has_default ( )  ]
process_all = options . get ( 'all' )
processors . append ( func )
processors = ( )
processors = [ ]
processors = tuple ( processors )
program = 'msgfmt'
program_options = [ '--check-format' ]
project_name , target = options . pop ( 'name' ) , options . pop ( 'directory' )
project_name = settings . SETTINGS_MODULE . split ( '.' ) [ 0 ]
propagate = config . get ( 'propagate' , None )
props = config . pop ( '.' , None )
provided = list ( provided )
proxy = lazy ( func , resultclass ) ( ** kwargs )
proxy = lazy ( lambda ** kwargs : NumberAwareString ( ) , NumberAwareString ) ( ** kwargs )
push = block = block_context . pop ( self . name )
PVOID = c_void_p
PY2 = sys . version_info [ 0 ] == 2
PY3 = sys . version_info [ 0 ] == 3
pythonrc = os . path . expanduser ( pythonrc )
pytz = None
qn = connection . ops . quote_name
qs = f . value_from_object ( instance )
qs = pk . rel . to . _default_manager . get_queryset ( )
qs = qs . order_by ( self . model . _meta . pk . name )
qs = qs . using ( form . instance . _state . db )
qs = queryset . filter ( ** { self . fk . name : self . instance } )
qs = queryset . none ( )
qs = self . model . _default_manager . get_queryset ( )
qs = self . queryset
qs = self . queryset . filter ( ** { '%s__in' % key : value } )
quant . append ( ch )
quant = [ ]
quant = quant [ : - 1 ]
query = query . items ( )
query = query . lists ( )
query_string = query_string . decode ( )
queryset = objects . using ( using ) . order_by ( model . _meta . pk . name )
queryset = property ( _get_queryset , _set_queryset )
queryset = queryset . filter ( pk__in = primary_keys )
queryset = self . model . _default_manager
QuerySetPaginator = Paginator
questioner = InteractiveMigrationQuestioner ( )
questioner = MigrationQuestioner ( defaults = { 'ask_merge' : True } )
quit_command = 'CTRL-BREAK' if sys . platform == 'win32' else 'CONTROL-C'
quote = s [ 0 ]
r = dklen - ( l - 1 ) * hlen
r = o . isoformat ( )
r = r [ : - 6 ] + 'Z'
r = r [ : 12 ]
r = random.randint(1,255-6)
raise
raise
raise
raise
raise
raise AppRegistryNotReady (  "The translation infrastructure cannot be initialized before the "  "apps registry is ready. Check that you don't make non-lazy "  "gettext calls at import time." )
raise AttributeError
raise AttributeError
raise AttributeError ( "'%s' object has no attribute 'cleaned_data'" % self . __class__ . __name__ )
raise AttributeError ( "'%s' object has no attribute 'ordered_forms'" % self . __class__ . __name__ )
raise AttributeError ( "%s could not be imported " % self . name )
raise AttributeError ( "no such move, %r" % ( name , ) )
raise AttributeError ( "This %s instance has no `content` attribute. "  "Use `streaming_content` instead." % self . __class__ . __name__ )
raise AttributeError ( "This method is available only on the view class." )
raise AttributeError ( "This QueryDict instance is immutable" )
raise AttributeError ( "Unable to determine the file's size." )
raise AttributeError ( "You cannot set content to a 304 (Not Modified) response" )
raise AttributeError ( "You cannot set the upload handlers after the upload has been processed." )
raise AttributeError ( attr )
raise AttributeError ( self . warning )
raise BadHeaderError ( "Header values can't contain newlines (got %r for header %r)" % ( val , name ) )
raise BadHeaderError ( "Header values can't contain newlines (got %r)" % value )
raise BadSignature ( 'No "%s" found in value' % self . sep )
raise BadSignature ( 'Signature "%s" does not match' % sig )
raise base . DeserializationError (  "<%s> node has invalid model identifier: '%s'"  % ( node . nodeName , model_identifier ) )
raise base . DeserializationError (  "<%s> node is missing the required '%s' attribute"  % ( node . nodeName , attr ) )
raise base . DeserializationError ( "<field> node is missing the 'name' attribute" )
raise base . DeserializationError ( "Invalid model identifier: '%s'" % model_identifier )
raise base . SerializationError ( "Non-model object (%s) encountered during serialization" % type ( obj ) )
raise CommandError (  "AppCommand cannot handle app '%s' in legacy mode "  "because it doesn't have a models module."  % app_config . label )
raise CommandError (  "Cache table '%s' could not be created.\nThe error was: %s." %  ( tablename , force_text ( e ) ) )
raise CommandError (  "errors happened while running msgattrib\n%s" % errors )
raise CommandError (  "errors happened while running msgmerge\n%s" % errors )
raise CommandError (  "errors happened while running msguniq\n%s" % errors )
raise CommandError (  "errors happened while running xgettext on %s\n%s" %  ( self . file , errors ) )
raise CommandError (  "Multiple fixtures named '%s' in %s. Aborting." %  ( fixture_name , humanize ( fixture_dir ) ) )
raise CommandError (  "Problem installing fixture '%s': %s is not a known "  "serialization format." % ( '' . join ( parts [ : - 1 ] ) , parts [ - 1 ] ) )
raise CommandError (  "Unable to find a locale path to store translations for file %s" % file_path )
raise CommandError ( '"%s" is not a valid IPv6 address.' % self . addr )
raise CommandError ( '"%s" is not a valid port number '  'or address:port pair.' % options [ 'addrport' ] )
raise CommandError ( 'There is no system check with the "%s" tag.' % invalid_tag )
raise CommandError ( 'Unknown app in excludes: %s' % exclude )
raise CommandError ( 'Unknown model in excludes: %s' % exclude )
raise CommandError ( 'You appear not to have the %r program installed or on your path.' %  connection . client . executable_name )
raise CommandError ( 'You must set settings.ALLOWED_HOSTS if DEBUG is False.' )
raise CommandError ( 'Your Python does not support IPv6.' )
raise CommandError ( "%r conflicts with the name of an existing "  "Python module and cannot be used as a "  "project name. Please try another name." %  project_name )
raise CommandError ( "%r conflicts with the name of an existing "  "Python module and cannot be used as an app "  "name. Please try another name." % app_name )
raise CommandError ( "%r is not a valid %s name. Please %s." %  ( name , app_or_project , message ) )
raise CommandError ( "%r is not a valid port number." % self . port )
raise CommandError ( "%s already exists, overlaying a "  "project or app into an existing "  "directory won't replace conflicting "  "files" % new_path )
raise CommandError ( "%s. Are you sure your INSTALLED_APPS setting is correct?" % e )
raise CommandError ( "App '%s' does not have migrations (so squashmigrations on it makes no sense)" % app_label )
raise CommandError ( "App '%s' does not have migrations (you cannot selectively sync unmigrated apps)" % app_label )
raise CommandError ( "App '%s' does not have migrations" % app_label )
raise CommandError ( "App '%s' has migrations. Only the sqlmigrate and sqlflush commands can be used when an app has migrations." % app_config . label )
raise CommandError ( "Can't find %s. Make sure you have GNU "  "gettext tools 0.15 or newer installed." % program )
raise CommandError ( "Can't find %s. Make sure you have GNU gettext "  "tools 0.15 or newer installed." % self . program )
raise CommandError ( "Can't resolve dependencies for %s in serialized app list." %  ', ' . join ( '%s.%s' % ( model . _meta . app_label , model . _meta . object_name )  for model , deps in sorted ( skipped , key = lambda obj : obj [ 0 ] . __name__ ) )  )
raise CommandError ( "Cannot find a migration matching '%s' from app '%s'. Is it in INSTALLED_APPS?" % (  migration_name , app_label ) )
raise CommandError ( "Cannot find a migration matching '%s' from app '%s'." % (  migration_name , app_label ) )
raise CommandError ( "Cannot find a migration matching '%s' from app '%s'." % ( migration_name , app_label ) )
raise CommandError ( "Command doesn't accept any arguments" )
raise CommandError ( "Conflicting migrations detected (%s).\nTo fix them run 'python manage.py makemigrations --merge'" % name_str )
raise CommandError ( "Conflicting migrations detected (%s).\nTo fix them run 'python manage.py makemigrations --merge'" % name_str )
raise CommandError ( "couldn't download URL %s to %s: %s" %  ( url , filename , e ) )
raise CommandError ( "couldn't extract file %s to %s: %s" %  ( filename , tempdir , e ) )
raise CommandError ( "couldn't handle %s template %s." %  ( self . app_or_project , template ) )
raise CommandError ( "currently makemessages only supports domains "  "'django' and 'djangojs'" )
raise CommandError ( "Database inspection isn't supported for the currently selected database backend." )
raise CommandError ( "Destination directory '%s' does not "  "exist, please create it first." % top_dir )
raise CommandError ( "Django doesn't know which syntax to use for your SQL statements,\n" +  "because you haven't properly specified the ENGINE setting for the database.\n" +  "see: https://docs.djangoproject.com/en/dev/ref/settings/#databases" )
raise CommandError ( "Error: %s" % message )
raise CommandError ( "Incompatible values of 'leave_locale_alone' "  "(%s) and 'can_import_settings' (%s) command "  "options." % ( self . leave_locale_alone ,  self . can_import_settings ) )
raise CommandError ( "More than one migration matches '%s' in app '%s'. Please be more specific." % (  migration_name , app_label ) )
raise CommandError ( "More than one migration matches '%s' in app '%s'. Please be more specific." % (  migration_name , app_label ) )
raise CommandError ( "More than one migration matches '%s' in app '%s'. Please be more specific." % ( migration_name , app_label ) )
raise CommandError ( "No migrations present for: %s" % ( ", " . join ( invalid_apps ) ) )
raise CommandError ( "The %s file has a BOM (Byte Order Mark). "  "Django only supports .po files encoded in "  "UTF-8 and without any BOM." % po_path )
raise CommandError ( "This script should be run from the Django Git "  "checkout or your project or app tree, or with "  "the settings module specified." )
raise CommandError ( "Type '%s help %s' for usage information." % (  os . path . basename ( sys . argv [ 0 ] ) , sys . argv [ 1 ] ) )
raise CommandError ( "Unable to serialize database: %s" % e )
raise CommandError ( "Unknown application: %s" % app_label )
raise CommandError ( "Unknown application: %s" % app_label )
raise CommandError ( "Unknown command: %r" % name )
raise CommandError ( "Unknown model: %s.%s" % ( app_label , model_label ) )
raise CommandError ( "Unknown serialization format: %s" % format )
raise CommandError ( "You can only use --pks option with one model" )
raise CommandError ( "you must provide %s %s name" % (  "an" if app_or_project == "app" else "a" , app_or_project ) )
raise CommandError ( "You must supply at least one app label when using --empty." )
raise CommandError ( message )
raise CommandError ( msg )
raise CommandError ( msg )
raise ContentNotRenderedError ( 'The response content must be '  'rendered before it can be accessed.' )
raise ContentNotRenderedError ( 'The response content must be '  'rendered before it can be iterated over.' )
raise ContentNotRenderedError ( 'The response content must be '  'rendered before it can be pickled.' )
raise ContextPopException
raise DisallowedHost ( msg )
raise DisallowedRedirect ( "Unsafe redirect to URL with protocol '%s'" % parsed . scheme )
raise DjangoUnicodeDecodeError ( s , * e . args )
raise DTDForbidden ( name , sysid , pubid )
raise e
raise EmptyPage ( 'That page contains no results' )
raise EmptyPage ( 'That page number is less than 1' )
raise EntitiesForbidden ( name , None , base , sysid , pubid , notation_name )
raise EntitiesForbidden ( name , value , base , sysid , pubid , notation_name )
raise EnvironmentError (  "Cache directory '%s' does not exist "  "and could not be created'" % self . _dir )
raise Exception ( "This %s instance cannot tell its position" % self . __class__ . __name__ )
raise Exception ( "This %s instance is not writable" % self . __class__ . __name__ )
raise ExternalReferenceForbidden ( context , base , sysid , pubid )
raise FieldError ( message )
raise ImportError
raise ImportError (  "Could not import '%s'. The path must be fully qualified." %  lookup_view )
raise ImportError ( "No IPython" )
raise ImproperlyConfigured (  '"%s" is not a valid regular expression: %s' %  ( regex , six . text_type ( e ) ) )
raise ImproperlyConfigured (  'Command %s defines both "requires_model_validation" '  'and "requires_system_checks", which is illegal. Use only '  '"requires_system_checks".' % self . __class__ . __name__ )
raise ImproperlyConfigured (  "Calling modelform_factory without defining 'fields' or "  "'exclude' explicitly is prohibited."  )
raise ImproperlyConfigured (  "Calling modelformset_factory without defining 'fields' or "  "'exclude' explicitly is prohibited."  )
raise ImproperlyConfigured (  "Creating a ModelForm without either the 'fields' attribute "  "or the 'exclude' attribute is prohibited; form %s "  "needs updating." % name  )
raise ImproperlyConfigured ( 'Could not create directory for saving email messages: %s (%s)' % ( self . file_path , err ) )
raise ImproperlyConfigured ( 'Could not write to directory: %s' % self . file_path )
raise ImproperlyConfigured ( 'Loader does not define a "load_template" callable template source loader' )
raise ImproperlyConfigured ( 'Path for saving email messages exists, but is not a directory: %s' % self . file_path )
raise ImproperlyConfigured ( 'Path for saving emails is invalid: %r' % self . file_path )
raise ImproperlyConfigured ( 'The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.' )
raise ImproperlyConfigured ( "Error importing template source loader %s - can't pass arguments to function-based loader." % loader )
raise ImproperlyConfigured ( "You must define a '%s' cache" % DEFAULT_CACHE_ALIAS )
raise ImproperlyConfigured ( msg . format ( name = self . urlconf_name ) )
raise InputStreamExhausted ( )
raise InvalidCacheBackendError (  "Could not find backend '%s': %s" % ( backend , e ) )
raise InvalidCacheBackendError (  "Could not find config for '%s' in settings.CACHES" % alias  )
raise InvalidCacheBackendError ( "Could not find backend '%s': %s" % (  backend , e ) )
raise InvalidTemplateLibrary ( "ImportError raised loading %s: %s" %  ( taglib_module , e ) )
raise InvalidTemplateLibrary ( "Template library %s does not have "  "a variable named 'register'" %  taglib_module )
raise InvalidTemplateLibrary ( "Template library %s not found, "  "tried %s" %  ( library_name ,  ',' . join ( tried_modules ) ) )
raise InvalidTemplateLibrary ( "Unsupported arguments to "  "Library.filter: (%r, %r)" , ( name , filter_func ) )
raise InvalidTemplateLibrary ( "Unsupported arguments to "  "Library.tag: (%r, %r)" , ( name , compile_function ) )
raise IOError ( "%s exists and is not a directory." % directory )
raise IOError ( "Destination file %s exists and allow_overwrite is False" % new_file_name )
raise KeyError (  "Key %r not found in '%s'" % ( name , self . __class__ . __name__ ) )
raise KeyError ( 'Unknown media type "%s"' % name )
raise KeyError ( 'Your dictionary lacks key \'%s\'. '  'Please provide it, because it is required to '  'determine whether string is singular or plural.'  % number )
raise KeyError ( "Unknown language code %s and %s." % ( lang_code , generic_lang_code ) )
raise KeyError ( "Unknown language code %s." % lang_code )
raise KeyError ( key )
raise KeyError ( key )
raise LookupError ( lang_code )
raise MultiPartParserError ( 'Invalid boundary in multipart: %s' % boundary )
raise MultiPartParserError ( 'Invalid Content-Type: %s' % content_type )
raise MultiPartParserError ( 'multipartparser.exhaust() was passed a non-iterable or stream parameter' )
raise MultiPartParserError ( "Invalid content length: %r" % content_length )
raise MultiValueDictKeyError ( repr ( key ) )
raise NoReverseMatch (  "%s is not a registered namespace inside '%s'" %  ( key , ':' . join ( resolved_path ) ) )
raise NoReverseMatch ( "%s is not a registered namespace" %  key )
raise NoReverseMatch ( "Error importing '%s': %s." % ( lookup_view , e ) )
raise NoReverseMatch ( "Reverse for '%s' with arguments '%s' and keyword "  "arguments '%s' not found. %d pattern(s) tried: %s" %  ( lookup_view_s , args , kwargs , len ( patterns ) , patterns ) )
raise NotImplementedError (  "Subclasses of AppCommand must provide"  "a handle_app_config() method." )
raise NotImplementedError ( 'Awaiting Implementation' )
raise NotImplementedError ( 'may be implemented in a future release' )
raise NotImplementedError ( 'Subclasses must define this method.' )
raise NotImplementedError ( 'Subclasses must implement this method.' )
raise NotImplementedError ( 'Subclasses must implement this method.' )
raise NotImplementedError ( 'subclasses of BaseArchive must provide a list() method' )
raise NotImplementedError ( 'subclasses of BaseArchive must provide an extract() method' )
raise NotImplementedError ( 'subclasses of BaseCache must provide a clear() method' )
raise NotImplementedError ( 'subclasses of BaseCache must provide a delete() method' )
raise NotImplementedError ( 'subclasses of BaseCache must provide a get() method' )
raise NotImplementedError ( 'subclasses of BaseCache must provide a set() method' )
raise NotImplementedError ( 'subclasses of BaseCache must provide an add() method' )
raise NotImplementedError ( 'subclasses of BaseCommand must provide a handle() method' )
raise NotImplementedError ( 'subclasses of BaseEmailBackend must override send_messages() method' )
raise NotImplementedError ( 'subclasses of BaseLoader must provide a load_template_source() method' )
raise NotImplementedError ( 'subclasses of Deserializer must provide a __next__() method' )
raise NotImplementedError ( 'subclasses of FileUploadHandler must provide a file_complete() method' )
raise NotImplementedError ( 'subclasses of FileUploadHandler must provide a receive_data_chunk() method' )
raise NotImplementedError ( 'subclasses of LabelCommand must provide a handle_label() method' )
raise NotImplementedError ( 'subclasses of LazyObject must provide a _setup() method' )
raise NotImplementedError ( 'subclasses of NoArgsCommand must provide a handle_noargs() method' )
raise NotImplementedError ( 'subclasses of Origin must provide a reload() method' )
raise NotImplementedError ( 'subclasses of Serializer must provide a start_object() method' )
raise NotImplementedError ( 'subclasses of Serializer must provide a start_serialization() method' )
raise NotImplementedError ( 'subclasses of Serializer must provide an handle_field() method' )
raise NotImplementedError ( 'subclasses of Serializer must provide an handle_fk_field() method' )
raise NotImplementedError ( 'subclasses of Serializer must provide an handle_m2m_field() method' )
raise NotImplementedError ( 'subclasses of Storage must provide a created_time() method' )
raise NotImplementedError ( 'subclasses of Storage must provide a delete() method' )
raise NotImplementedError ( 'subclasses of Storage must provide a listdir() method' )
raise NotImplementedError ( 'subclasses of Storage must provide a modified_time() method' )
raise NotImplementedError ( 'subclasses of Storage must provide a size() method' )
raise NotImplementedError ( 'subclasses of Storage must provide a url() method' )
raise NotImplementedError ( 'subclasses of Storage must provide an accessed_time() method' )
raise NotImplementedError ( 'subclasses of Storage must provide an exists() method' )
raise NotImplementedError ( 'subclasses of SyndicationFeed must provide a write() method' )
raise NotImplementedError ( 'subclasses of Tokenparser must provide a top() method' )
raise NotImplementedError ( 'subclasses of Widget must provide a render() method' )
raise NotImplementedError ( "This backend doesn't support absolute paths." )
raise OverflowError ( 'dklen too big' )
raise PageNotAnInteger ( 'That page number is not an integer' )
raise parser . error_class (  "Not expecting '%s' as infix operator in if tag." % self . id  )
raise parser . error_class (  "Not expecting '%s' in this position in if tag." % self . id  )
raise parser . error_class ( "Unexpected end of expression in if tag." )
raise RawPostDataException ( "You cannot access body after reading from request's data stream" )
raise Resolver404 ( { 'path' : path } )
raise Resolver404 ( { 'tried' : tried , 'path' : new_path } )
raise RuntimeError (  "The method to extend accepted command-line arguments by the "  "test management command has changed in Django 1.8. Please "  "create an add_arguments class method to achieve this." )
raise self . error ( None , "Unclosed tags: %s " % ', ' . join ( parse_until ) )
raise self . error ( token , "Empty block tag" )
raise self . error ( token , "Empty variable tag" )
raise self . error ( token , "Invalid block tag: '%s', expected %s" %  ( command , get_text_list ( [ "'%s'" % p for p in parse_until ] ) ) )
raise self . error ( token , "Invalid block tag: '%s'" % command )
raise self . error_class ( "Unused '%s' at end of if expression." %  self . current_token . display ( ) )
raise self . exception
raise self . source_error ( source , msg )
raise self . warning
raise SerializerDoesNotExist ( format )
raise SignatureExpired (  'Signature age %s > %s seconds' % ( age , max_age ) )
raise StopFutureHandlers ( )
raise StopIteration
raise StopIteration ( )
raise StopIteration ( )
raise StopIteration ( )
raise SuspiciousFileOperation ( "Attempted access to '%s' denied." % name )
raise SuspiciousMultipartForm (  "The multipart parser got stuck, which shouldn't happen with"  " normal uploaded files. Check for malicious upload activity;"  " if there is none, report this to the Django developers."  )
raise SyntaxError ( "Translation blocks must not include other block tags: %s (%sline %d)" % ( t . contents , filemsg , t . lineno ) )
raise SystemRestart
raise TemplateDoesNotExist
raise TemplateDoesNotExist ( ', ' . join ( not_found ) )
raise TemplateDoesNotExist ( "No template names provided" )
raise TemplateDoesNotExist ( error_msg )
raise TemplateDoesNotExist ( name )
raise TemplateDoesNotExist ( template_name )
raise TemplateEncodingError ( "Templates can only be constructed "  "from unicode or UTF-8 strings." )
raise TemplateSyntaxError (  "'%s' did not receive value(s) for the argument(s): %s" %  ( name , ", " . join ( "'%s'" % p for p in unhandled_params ) ) )
raise TemplateSyntaxError (  "'%s' is decorated with takes_context=True so it must "  "have a first argument of 'context'" % name )
raise TemplateSyntaxError (  "'%s' received multiple values for keyword argument '%s'" %  ( name , param ) )
raise TemplateSyntaxError (  "'%s' received some positional argument(s) after some "  "keyword argument(s)" % name )
raise TemplateSyntaxError (  "'%s' received too many positional arguments" %  name )
raise TemplateSyntaxError (  "'%s' received unexpected keyword argument '%s'" %  ( name , param ) )
raise TemplateSyntaxError (  "'%s' tag takes at least 2 arguments and the "  "second last argument must be 'as'" % function_name )
raise TemplateSyntaxError ( '"filter %s" is not permitted.  Use the "autoescape" tag instead.' % filter_name )
raise TemplateSyntaxError ( '"with" in %r tag needs at least '  'one keyword argument.' % bits [ 0 ] )
raise TemplateSyntaxError ( 'The %r option was specified more '  'than once.' % option )
raise TemplateSyntaxError ( 'Unknown argument for %r tag: %r.' %  ( bits [ 0 ] , option ) )
raise TemplateSyntaxError ( "'%s' cannot appear more than once in the same template" % bits [ 0 ] )
raise TemplateSyntaxError ( "'%s' is not a valid tag library: %s" %  ( taglib , e ) )
raise TemplateSyntaxError ( "'%s' is not a valid tag or filter in tag library '%s'" %  ( name , taglib ) )
raise TemplateSyntaxError ( "'%s' tag takes only one argument" % bits [ 0 ] )
raise TemplateSyntaxError ( "'%s' tag with name '%s' appears more than once" % ( bits [ 0 ] , block_name ) )
raise TemplateSyntaxError ( "'%s' takes at least one argument"  " (path to a view)" % bits [ 0 ] )
raise TemplateSyntaxError ( "'%s' takes one argument" % bits [ 0 ] )
raise TemplateSyntaxError ( "'autoescape' argument should be 'on' or 'off'" )
raise TemplateSyntaxError ( "'autoescape' tag requires exactly one argument." )
raise TemplateSyntaxError ( "'cycle' tag requires at least two arguments" )
raise TemplateSyntaxError ( "'firstof' statement requires at least one argument" )
raise TemplateSyntaxError ( "'for' statements should have at least four"  " words: %s" % token . contents )
raise TemplateSyntaxError ( "'for' statements should use the format"  " 'for x in y': %s" % token . contents )
raise TemplateSyntaxError ( "'for' tag received an invalid argument:"  " %s" % token . contents )
raise TemplateSyntaxError ( "'now' statement takes one argument" )
raise TemplateSyntaxError ( "'regroup' tag takes five arguments" )
raise TemplateSyntaxError ( "'ssi' tag takes one argument: the path to"  " the file to be included" )
raise TemplateSyntaxError ( "'templatetag' statement takes one argument" )
raise TemplateSyntaxError ( "%r expected at least one variable "  "assignment" % bits [ 0 ] )
raise TemplateSyntaxError ( "%r must be the first tag "  "in the template." % node )
raise TemplateSyntaxError ( "%r received an invalid token: %r" %  ( bits [ 0 ] , remaining_bits [ 0 ] ) )
raise TemplateSyntaxError ( "%r tag takes at least one argument: the name of the template to be included." % bits [ 0 ] )
raise TemplateSyntaxError ( "%r takes two arguments" % bits [ 0 ] )
raise TemplateSyntaxError ( "%s requires %d arguments, %d provided" %  ( name , alen - dlen , plen ) )
raise TemplateSyntaxError ( "back called without some previous "  "parsing" )
raise TemplateSyntaxError ( "Could not find variable at "  "start of %s." % token )
raise TemplateSyntaxError ( "Could not parse some characters: "  "%s|%s|%s" %  ( token [ : upto ] , token [ upto : start ] ,  token [ start : ] ) )
raise TemplateSyntaxError ( "Could not parse the remainder: '%s' "  "from '%s'" % ( token [ upto : ] , token ) )
raise TemplateSyntaxError ( "expected another tag, found "  "end of string: %s" % subject )
raise TemplateSyntaxError ( "Invalid arguments provided to assignment_tag" )
raise TemplateSyntaxError ( "Invalid arguments provided to simple_tag" )
raise TemplateSyntaxError ( "Invalid filter: '%s'" % filter_name )
raise TemplateSyntaxError ( "Invalid syntax in widthratio tag. Expecting 'as' keyword" )
raise TemplateSyntaxError ( "Invalid templatetag argument: '%s'."  " Must be one of: %s" %  ( tag , list ( TemplateTagNode . mapping ) ) )
raise TemplateSyntaxError ( "Malformed arguments to url tag" )
raise TemplateSyntaxError ( "Named cycle '%s' does not exist" % name )
raise TemplateSyntaxError ( "next-to-last argument to 'regroup' tag must"  " be 'as'" )
raise TemplateSyntaxError ( "No named cycles in template. '%s' is not defined" % name )
raise TemplateSyntaxError ( "Only 'silent' flag is allowed after cycle's name, not '%s'." % args [ - 1 ] )
raise TemplateSyntaxError ( "Searching for value. "  "Unexpected end of string in column %d: %s" %  ( i , subject ) )
raise TemplateSyntaxError ( "Searching for value. Expected another "  "value but found end of string: %s" %  subject )
raise TemplateSyntaxError ( "Searching for value. Unexpected "  "end of string in column %d: %s" %  ( i , subject ) )
raise TemplateSyntaxError ( "Second (optional) argument to %s tag"  " must be 'parsed'" % bits [ 0 ] )
raise TemplateSyntaxError ( "second argument to 'regroup' tag must be 'by'" )
raise TemplateSyntaxError ( "Variables and attributes may "  "not begin with underscores: '%s'" %  var )
raise TemplateSyntaxError ( "widthratio final argument must be a number" )
raise TemplateSyntaxError ( "widthratio takes at least three arguments" )
raise TemplateSyntaxError ( error_msg )
raise TypeError
raise TypeError (  "The argument `field` must be `None` when the `error` "  "argument contains errors for multiple fields."  )
raise TypeError (  "Variable must be a string or number, got %s" % type ( var ) )
raise TypeError ( 'formfield_callback must be a function or callable' )
raise TypeError ( 'In order to allow non-dict objects to be '  'serialized set the safe parameter to False' )
raise TypeError ( 'Level not an integer or a '  'valid string: %r' % level )
raise TypeError ( 'other_dict must be a mapping (dictionary-like) object.' )
raise TypeError ( "can't delete _wrapped." )
raise TypeError ( "end must be None or a string" )
raise TypeError ( "If the flags are set, regex must be a regular expression string." )
raise TypeError ( "invalid keyword arguments to print()" )
raise TypeError ( "Lazy object returned unexpected type." )
raise TypeError ( "Non-integer base36 conversion input." )
raise TypeError ( "relative imports require the 'package' argument" )
raise TypeError ( "sep must be None or a string" )
raise TypeError ( "strftime of dates before 1900 does not handle" + illegal_formatting . group ( 0 ) )
raise TypeError ( "update expected at most 1 arguments, got %d" % len ( args ) )
raise TypeError ( msg )
raise TypeError ( s )
raise UnrecognizedArchiveFormat (  "File object not a recognized archive format." )
raise UnrecognizedArchiveFormat (  "Path not a recognized archive format: %s" % filename )
raise v
raise ValidationError (  _ ( 'ManagementForm data is missing or has been tampered with' ) ,  code = 'missing_management_form' ,  )
raise ValidationError (  self . error_messages [ 'invalid_choice' ] ,  code = 'invalid_choice' ,  params = { 'value' : choice } ,  )
raise ValidationError (  self . error_messages [ 'invalid_choice' ] ,  code = 'invalid_choice' ,  params = { 'value' : val } ,  )
raise ValidationError (  self . error_messages [ 'invalid_choice' ] ,  code = 'invalid_choice' ,  params = { 'value' : val } ,  )
raise ValidationError (  self . error_messages [ 'invalid_choice' ] ,  code = 'invalid_choice' ,  params = { 'value' : value } ,  )
raise ValidationError (  self . error_messages [ 'invalid_pk_value' ] ,  code = 'invalid_pk_value' ,  params = { 'pk' : pk } ,  )
raise ValidationError (  self . error_messages [ 'max_decimal_places' ] ,  code = 'max_decimal_places' ,  params = { 'max' : self . decimal_places } ,  )
raise ValidationError (  self . error_messages [ 'max_digits' ] ,  code = 'max_digits' ,  params = { 'max' : self . max_digits } ,  )
raise ValidationError (  self . error_messages [ 'max_whole_digits' ] ,  code = 'max_whole_digits' ,  params = { 'max' : ( self . max_digits - self . decimal_places ) } ,  )
raise ValidationError ( _ ( 'Enter a valid integer.' ) , code = 'invalid' )
raise ValidationError ( _ ( 'Enter a valid IPv4 or IPv6 address.' ) , code = 'invalid' )
raise ValidationError ( _ ( 'Enter a valid IPv6 address.' ) , code = 'invalid' )
raise ValidationError ( error_message , code = 'invalid' )
raise ValidationError ( errors )
raise ValidationError ( errors )
raise ValidationError ( errors )
raise ValidationError ( self . error_messages [ 'contradiction' ] , code = 'contradiction' )
raise ValidationError ( self . error_messages [ 'empty' ] , code = 'empty' )
raise ValidationError ( self . error_messages [ 'invalid_choice' ] , code = 'invalid_choice' )
raise ValidationError ( self . error_messages [ 'invalid_choice' ] , code = 'invalid_choice' )
raise ValidationError ( self . error_messages [ 'invalid_date' ] , code = 'invalid_date' )
raise ValidationError ( self . error_messages [ 'invalid_list' ] , code = 'invalid_list' )
raise ValidationError ( self . error_messages [ 'invalid_time' ] , code = 'invalid_time' )
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )
raise ValidationError ( self . error_messages [ 'invalid' ] , code = 'invalid' )
raise ValidationError ( self . error_messages [ 'list' ] , code = 'list' )
raise ValidationError ( self . error_messages [ 'max_length' ] , code = 'max_length' , params = params )
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )
raise ValidationError ( self . error_messages [ 'required' ] , code = 'required' )
raise ValidationError ( self . message , code = self . code , params = params )
raise ValidationError ( self . message , code = self . code )
raise ValidationError ( ungettext (  "Please submit %d or fewer forms." ,  "Please submit %d or fewer forms." , self . max_num ) % self . max_num ,  code = 'too_many_forms' ,  )
raise ValidationError ( ungettext (  "Please submit %d or more forms." ,  "Please submit %d or more forms." , self . min_num ) % self . min_num ,  code = 'too_few_forms' )
raise value
raise value . with_traceback ( tb )
raise ValueError
raise ValueError (  "'%s.%s' has more than one ForeignKey to '%s.%s'."  % ( model . _meta . app_label , model . _meta . object_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )
raise ValueError (  "'%s.%s' has no field named '%s'."  % ( model . _meta . app_label , model . _meta . object_name , fk_name ) )
raise ValueError (  "'%s.%s' has no ForeignKey to '%s.%s'."  % ( model . _meta . app_label , model . _meta . object_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )
raise ValueError (  "'%s' has no field named '%s'." % ( self . __class__ . __name__ , field ) )
raise ValueError (  "%s.process_response didn't return an "  "HttpResponse object. It returned None instead."  % ( middleware_method . __self__ . __class__ . __name__ ) )
raise ValueError (  "%s.process_template_response didn't return an "  "HttpResponse object. It returned None instead."  % ( middleware_method . __self__ . __class__ . __name__ ) )
raise ValueError (  "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "  "one of those settings to True." )
raise ValueError (  "fk_name '%s' is not a ForeignKey to '%s.%'."  % ( fk_name , parent_model . _meta . app_label , parent_model . _meta . object_name ) )
raise ValueError (  "make_aware expects a naive datetime, got %s" % value )
raise ValueError (  "You can only use `unpack_ipv4` if `protocol` is set to 'both'" )
raise ValueError ( 'empty_label list/tuple must have 3 elements.' )
raise ValueError ( 'ModelForm has no model class specified.' )
raise ValueError ( 'must define at least one ordering operation: < > <= >=' )
raise ValueError ( 'No handler found with '  'name %r' % name )
raise ValueError ( 'Not a valid Python identifier: %r' % s )
raise ValueError ( 'Sign character found in converter base digits.' )
raise ValueError ( 'The joined path (%s) is located outside of the base '  'path component (%s)' % ( final_path , base_path ) )
raise ValueError ( 'Unable to add filter %r: %s' % ( f , e ) )
raise ValueError ( 'Unable to add handler %r: %s' % ( h , e ) )
raise ValueError ( 'Unable to configure '  'filter %r: %s' % ( name , e ) )
raise ValueError ( 'Unable to configure '  'formatter %r: %s' % ( name , e ) )
raise ValueError ( 'Unable to configure handler '  '%r: %s' % ( name , e ) )
raise ValueError ( 'Unable to configure logger '  '%r: %s' % ( name , e ) )
raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
raise ValueError ( 'Unable to configure root '  'logger: %s' % e )
raise ValueError ( 'Unable to convert '  '%r at %r' % ( value , rest ) )
raise ValueError ( 'Unable to set formatter '  '%r: %s' % ( formatter , e ) )
raise ValueError ( 'Unable to set target handler '  '%r: %s' % ( config [ 'target' ] , e ) )
raise ValueError ( 'Unknown level: %r' % level )
raise ValueError ( "'package' not set to a string" )
raise ValueError ( "@python_2_unicode_compatible cannot be applied "  "to %s because it doesn't define __str__()." %  klass . __name__ )
raise ValueError ( "%r is not in a valid HTTP date format" % date )
raise ValueError ( "attempted relative import beyond top-level package" )
raise ValueError ( "Base36 conversion input too large." )
raise ValueError ( "Base36 input too large" )
raise ValueError ( "Could not find common ancestor of %s" % migration_names )
raise ValueError ( "dictionary doesn't specify a version" )
raise ValueError ( "Don't mix *args and **kwargs in call to reverse()!" )
raise ValueError ( "Invalid header: %r" % line )
raise ValueError ( "Invalid timezone: %r" % timezone )
raise ValueError ( "JSON can't represent timezone-aware times." )
raise ValueError ( "Key '%s' not found" % key )
raise ValueError ( "Key '%s' not found" % key )
raise ValueError ( "Key '%s' not found" % key )
raise ValueError ( "Key '%s' not found" % key )
raise ValueError ( "MultiValueDict.update() takes either a MultiValueDict or dictionary" )
raise ValueError ( "Negative base36 conversion input." )
raise ValueError ( "Non-reversible reg-exp portion: '(?%s'" % ch )
raise ValueError ( "Non-reversible reg-exp portion: '(?P%s'" % ch )
raise ValueError ( "Not a string literal: %r" % s )
raise ValueError ( "The %s could not be %s because the data didn't"  " validate." % ( opts . object_name , fail_message ) )
raise ValueError ( "The file cannot be reopened." )
raise ValueError ( "The protocol '%s' is unknown. Supported: %s"  % ( protocol , list ( ip_address_validator_map ) ) )
raise ValueError ( "The view %s.%s didn't return an HttpResponse object. It returned None instead."  % ( callback . __module__ , view_name ) )
raise ValueError ( "This file is not accessible via a URL." )
raise ValueError ( "Unable to convert %r" % value )
raise ValueError ( "Unsupported version: %s" % config [ 'version' ] )
raise ValueError ( "Zip-compressed fixtures must contain one file." )
raise ValueError ( e )
raise VariableDoesNotExist ( "Failed lookup for key "  "[%s] in %r" ,  ( bit , current ) )
raise ViewDoesNotExist (  "Could not import '%s.%s'. View is not callable." %  ( mod_name , func_name ) )
raise ViewDoesNotExist (  "Could not import '%s'. Parent module %s does not exist." %  ( lookup_view , mod_name ) )
raise ViewDoesNotExist (  "Could not import '%s'. View does not exist in module %s." %  ( lookup_view , mod_name ) )
randint = random . randrange ( 100000 )
random . seed (  hashlib . sha256 (  ( "%s%s%s" % (  random . getstate ( ) ,  time . time ( ) ,  settings . SECRET_KEY ) ) . encode ( 'utf-8' )  ) . digest ( ) )
ratio = ( value / max_value ) * max_width
RAW = "raw"
raw_cookie = get_str_from_wsgi ( self . environ , 'HTTP_COOKIE' , '' )
raw_data = field_stream . read ( )
raw_query_string = get_bytes_from_wsgi ( self . environ , 'QUERY_STRING' , '' )
rawdata = force_str ( rawdata )
rawdata = self . rawdata
re_camel_case = re . compile ( r'(((?<=[a-z])[A-Z])|([A-Z](?![A-Z]|$)))' )
re_chars = re . compile ( r'<.*?>|(.)' , re . U | re . S )
RE_DATE = re . compile ( r'(\d{4})-(\d\d?)-(\d\d?)$' )
re_escaped = re . compile ( r'\\(.)' )
re_formatchars = re . compile ( r'(?<!\\)([aAbBcdDeEfFgGhHiIjlLmMnNoOPrsStTUuwWyYzZ])' )
re_newlines = re . compile ( r'\r\n|\r' )
re_tag = re . compile ( r'<(/)?([^ ]+?)(?:(\s*/)| .*?)?>' , re . S )
re_words = re . compile ( r'<.*?>|((?:\w[-\w]*|&.*?;)+)' , re . U | re . S )
read = property ( lambda self : self . file . read )
readinto = property ( lambda self : self . file . readinto )
readline . parse_and_bind ( "tab:complete" )
readline . set_completer ( rlcompleter . Completer ( imported_objects ) . complete )
readline = property ( lambda self : self . file . readline )
readlines = property ( lambda self : self . file . readlines )
reason_phrase = None
REASON_PHRASES = {  100 : 'CONTINUE' ,  101 : 'SWITCHING PROTOCOLS' ,  102 : 'PROCESSING' ,  200 : 'OK' ,  201 : 'CREATED' ,  202 : 'ACCEPTED' ,  203 : 'NON-AUTHORITATIVE INFORMATION' ,  204 : 'NO CONTENT' ,  205 : 'RESET CONTENT' ,  206 : 'PARTIAL CONTENT' ,  207 : 'MULTI-STATUS' ,  208 : 'ALREADY REPORTED' ,  226 : 'IM USED' ,  300 : 'MULTIPLE CHOICES' ,  301 : 'MOVED PERMANENTLY' ,  302 : 'FOUND' ,  303 : 'SEE OTHER' ,  304 : 'NOT MODIFIED' ,  305 : 'USE PROXY' ,  306 : 'RESERVED' ,  307 : 'TEMPORARY REDIRECT' ,  308 : 'PERMANENT REDIRECT' ,  400 : 'BAD REQUEST' ,  401 : 'UNAUTHORIZED' ,  402 : 'PAYMENT REQUIRED' ,  403 : 'FORBIDDEN' ,  404 : 'NOT FOUND' ,  405 : 'METHOD NOT ALLOWED' ,  406 : 'NOT ACCEPTABLE' ,  407 : 'PROXY AUTHENTICATION REQUIRED' ,  408 : 'REQUEST TIMEOUT' ,  409 : 'CONFLICT' ,  410 : 'GONE' ,  411 : 'LENGTH REQUIRED' ,  412 : 'PRECONDITION FAILED' ,  413 : 'REQUEST ENTITY TOO LARGE' ,  414 : 'REQUEST-URI TOO LONG' ,  415 : 'UNSUPPORTED MEDIA TYPE' ,  416 : 'REQUESTED RANGE NOT SATISFIABLE' ,  417 : 'EXPECTATION FAILED' ,  418 : "I'M A TEAPOT" ,  422 : 'UNPROCESSABLE ENTITY' ,  423 : 'LOCKED' ,  424 : 'FAILED DEPENDENCY' ,  426 : 'UPGRADE REQUIRED' ,  428 : 'PRECONDITION REQUIRED' ,  429 : 'TOO MANY REQUESTS' ,  431 : 'REQUEST HEADER FIELDS TOO LARGE' ,  500 : 'INTERNAL SERVER ERROR' ,  501 : 'NOT IMPLEMENTED' ,  502 : 'BAD GATEWAY' ,  503 : 'SERVICE UNAVAILABLE' ,  504 : 'GATEWAY TIMEOUT' ,  505 : 'HTTP VERSION NOT SUPPORTED' ,  506 : 'VARIANT ALSO NEGOTIATES' ,  507 : 'INSUFFICIENT STORAGE' ,  508 : 'LOOP DETECTED' ,  510 : 'NOT EXTENDED' ,  511 : 'NETWORK AUTHENTICATION REQUIRED' ,  }
recipients = [ sanitize_address ( addr , email_message . encoding )  for addr in email_message . recipients ( ) ]
references_to_delete . setdefault ( f . rel . to , [ ] ) . append ( ( model , f ) )
references_to_delete = { }
regex = ''
regex = force_text ( self . _regex )
regex = property ( _get_regex , _set_regex )
regex = re . compile (  r'^(?:[a-z0-9\.\-]*)://'  r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}(?<!-)\.?)|'  r'localhost|'  r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'  r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'  r'(?::\d+)?'  r'(?:/?|[/?]\S+)$' , re . IGNORECASE )
regex = re . compile ( regex , re . UNICODE )
regex = re_words if words else re_chars
regex = self . _regex
regex_compiled = re . compile ( '^%s/' % language_code , re . UNICODE )
regex_match = language_code_prefix_re . match ( path )
regexes = self . regexes
register = Library ( )
register = registry . register
register_serializer ( format , BUILTIN_SERIALIZERS [ format ] , serializers )
register_serializer ( format , settings . SERIALIZATION_MODULES [ format ] , serializers )
register_to . _registry = before_import_registry
register_to = kwargs . get ( 'register_to' )
registry = CheckRegistry ( )
rel_model = field . rel . to
rel_model = field . rel . to
rel_to = "self" if relations [ i ] [ 1 ] == table_name else table2model ( relations [ i ] [ 1 ] )
related = getattr ( obj , field . name )
related = getattr ( obj , field . name )
related = related . natural_key ( )
related_att = getattr ( obj , field . get_attname ( ) )
relations = { }
relations = connection . introspection . get_relations ( cursor , table_name )
relative_dir = path_rest . replace ( base_name , name )
reloader ( wrapped_main_func , args , kwargs )
reloader = jython_reloader
reloader = python_reloader
reloader_thread ( )
remaining -= len ( emitting )
remaining = self . _remaining if size is None else size
remaining_bits = bits [ 1 : ]
remaining_bits = bits [ 2 : ]
remove = complain
remove_tags = allow_lazy ( remove_tags , six . text_type )
RemovedInNextVersionWarning = RemovedInDjango19Warning
renamed = False
renamed = True
renamed_methods = (  ( '_get_memcache_timeout' , 'get_backend_timeout' , RemovedInDjango19Warning ) ,  )
renamed_methods = ( )
render_context = self . context . render_context
renderer = CheckboxFieldRenderer
renderer = kwargs . pop ( 'renderer' , None )
renderer = None
renderer = RadioFieldRenderer
rendering_attrs = [ 'template_name' , 'context_data' , '_post_render_callbacks' ]
rendering_attrs = SimpleTemplateResponse . rendering_attrs + [ '_request' , '_current_app' ]
repeat = 0
repeat = random.randint(1, entropy)
replacement = _BROWSERS_DEPRECATED_LOCALES . get ( lang_code )
replaces . append ( ( migration . app_label , migration . name ) )
replaces . extend ( migration . replaces )
replaces = [ ]
repo_dir = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) )
reporter = ExceptionReporter ( request , is_email = True , * exc_info )
repr_attr = self . _setupfunc
repr_attr = self . _wrapped
representative = ESCAPE_MAPPINGS . get ( ch , ch )
request . resolver_match = resolver_match
request = None
REQUEST = property ( _get_request )
request = record . request
request = self . request_class ( environ )
request = sys . modules [ __name__ + ".moves.urllib_request" ]
request_class = WSGIRequest
request_finished . connect ( update_watch )
request_finished = Signal ( )
request_middleware . append ( mw_instance . process_request )
request_middleware = [ ]
request_queue_size = 10
request_repr = '\n{0}' . format ( filter . get_request_repr ( request ) )
request_repr = "unavailable"
request_started = Signal ( )
requires_system_checks = False
requires_system_checks = False
res , args = flatten_result ( item )
res = ''
res = "\\x%02x," % len(bytearray(sc))
res = "\\x%02x," % len(bytearray(sc))
res = "\\x%02x," % len(bytearray(tmp))
res = (op1 + op2) % 128
res = func ( * self . __args , ** self . __kw )
res = instance . __dict__ [ self . name ] = self . func ( instance )
res = op[0:2]
res = subject [ p : i ]
res = to_digits [ 0 ]
res = x ^ y
res1 = ((x & val1) << val2)
res1 = ((x & val1) >> val2)
res1 = ((x & val1) >> val2)
res1 = (x << val2) 
res1 = (x << val2) & (val1)
res1 = (x << val2) & (val1)
res1 = (x << val2) & (val1)
res1 = (x << val2) ^ (val1)
res1 = (x << val2) ^ (val1)
res1 = (x >> val2) ^ (val1)
res1 = x & val1
res2 = (t & val1)
res2 = (x & ~val1)
res2 = (x & val1)
res2 = ~x & m
res2 = res2 << (max_bits*val2)
res2 = res2 >> (max_bits*val2)
res2 = res2 >> (max_bits+val2)
res2 = res2 >> max_bits-val2
res2 = x & val1
res2 = x & val1
res2 = x % val1
res2 = x << (max_bits - val2)
res2 = x << (max_bits - val2)
res2 = x << (max_bits / val2)
res2 = x val1
RESET = '0'
reset_sequences = options . get ( 'reset_sequences' , True )
reset_translations ( )
resolve ( path , urlconf )
resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )
resolved_args , resolved_kwargs = self . get_resolved_arguments ( context )
resolved_args = [ context ] + resolved_args
resolved_args = [ var . resolve ( context ) for var in self . args ]
resolved_kwargs = dict ( ( k , v . resolve ( context ) ) for k , v in self . kwargs . items ( ) )
resolved_path . append ( ns )
resolved_path = [ ]
resolver = get_ns_resolver ( ns_pattern , resolver )
resolver = get_resolver ( urlconf )
resolver = urlresolvers . RegexURLResolver ( r'^/' , urlconf )
resolver_match = resolver . resolve ( request . path_info )
resource = resource . decode ( settings . FILE_CHARSET )
resource = resource_string ( app_config . name , pkg_name )
resource_string = None
response . _closable_objects . append ( request )
response . _handler_class = self . __class__
response . add_post_render_callback ( _set_response_etag )
response . add_post_render_callback ( callback )
response . content = b''
response . streaming_content = [ ]
response [ 'Cache-Control' ] = cc
response [ 'Content-Length' ] = '0'
response [ 'ETag' ] = '"%s"' % hashlib . md5 ( response . content ) . hexdigest ( )
response [ 'Expires' ] = http_date ( time . time ( ) + cache_timeout )
response [ 'Last-Modified' ] = http_date ( )
response [ 'Location' ] = request . build_absolute_uri ( response [ 'Location' ] )
response [ 'Vary' ] = ', ' . join ( vary_headers + additional_headers )
response = _set_response_etag ( response )
response = callback ( request , ** param_dict )
response = debug . technical_404_response ( request , e )
response = func ( request , response )
response = http . HttpResponseBadRequest ( )
response = middleware . process_template_response ( request , response )
response = middleware_method ( request , callback , callback_args , callback_kwargs )
response = middleware_method ( request , e )
response = middleware_method ( request , response )
response = middleware_method ( request , response )
response = middleware_method ( request )
response = None
response = response . render ( )
response = self . apply_response_fixes ( request , response )
response = self . get_exception_response ( request , resolver , 400 )
response = self . get_exception_response ( request , resolver , 403 )
response = self . get_exception_response ( request , resolver , 404 )
response = self . get_response ( request )
response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )
response = self . handle_uncaught_exception ( request , resolver , sys . exc_info ( ) )
response = sys . modules [ __name__ + ".moves.urllib_response" ]
response = view_func ( request , * args , ** kwargs )
response = wrapped_callback ( request , * callback_args , ** callback_kwargs )
response_fixes = [  http . fix_location_header ,  http . conditional_content_removal ,  ]
response_headers . append ( ( str ( 'Set-Cookie' ) , str ( c . output ( header = '' ) ) ) )
response_headers = [ ( str ( k ) , str ( v ) ) for k , v in response . items ( ) ]
rest = rest [ m . end ( ) : ]
rest = value
result , upto = [ ] , 0
result . _choices = copy . deepcopy ( self . _choices , memo )
result . append ( "." )
result . append ( ( lang , priority ) )
result . append ( ch )
result . append ( Group ( ( ( "%%(%s)s" % name ) , name ) ) )
result . append ( Group ( ( ( "%%(%s)s" % param ) , None ) ) )
result . append ( Group ( ( ( "%%(%s)s" % param ) , param ) ) )
result . append ( self . create_token ( bit , in_tag ) )
result . append ( self . create_token ( last_bit , ( upto , upto + len ( last_bit ) ) , False ) )
result . append ( self . create_token ( self . template_string [ start : end ] , ( start , end ) , True ) )
result . append ( self . create_token ( self . template_string [ upto : start ] , ( upto , start ) , False ) )
result . extend ( [ result [ - 1 ] ] * ( count - 1 ) )
result . fields = tuple ( [ x . __deepcopy__ ( memo ) for x in self . fields ] )
result . key = key
result . parent = self
result . pop ( )
result . queryset = result . queryset
result . setFormatter ( formatter )
result . setLevel ( _checkLevel ( level ) )
result . setlist ( copy . deepcopy ( key , memo ) , copy . deepcopy ( value , memo ) )
result . setlist ( key , value )
result . sort ( key = lambda k : k [ 1 ] , reverse = True )
result . validators = self . validators [ : ]
result . widget = copy . deepcopy ( self . widget , memo )
result [ - 1 ] = Choice ( [ None , result [ - 1 ] ] )
result [ i ] += piece
result ^= _bin_to_long ( u )
result += ':' + ipv4_address
result += ugettext ( ', ' ) + avoid_wrapping ( name2 % count2 )
result = ':' . join ( hextets [ 0 : 6 ] )
result = ":" . join ( hextets )
result = "\\x%02x" % len(bytearray(shellcode))
result = ( template , make_origin ( display_name , loader , name , dirs ) )
result = [ '' ]
result = [ ]
result = 0
result = avoid_wrapping ( name % count )
result = block . nodelist . render ( context )
result = c ( ** kwargs )
result = cache_get ( key , root )
result = copy . copy ( self )
result = cursor . fetchone ( )
result = datetime . datetime . combine ( * data_list )
result = datetime . datetime ( value . year , value . month , value . day )
result = datetime . datetime ( year , month , day , hour , min , sec )
result = factory ( ** kwargs )
result = force_text ( message )
result = func ( * args )
result = getattr ( _default , translation_function ) ( eol_message )
result = getattr ( t , translation_function ) ( eol_message )
result = handler . handle_raw_input ( self . _input_data ,  self . _meta ,  self . _content_length ,  self . _boundary ,  encoding )
result = logging . Filter ( name )
result = logging . Formatter ( fmt , dfmt )
result = middleware . process_exception ( request , e )
result = middleware . process_request ( request )
result = middleware . process_view ( request , view_func , args , kwargs )
result = new_result
result = None
result = result [ : start ] + [ inner ]
result = self . __class__ ( '' , mutable = True , encoding = self . encoding )
result = self . __class__ ( )
result = self . _resolve ( )
result = self . buffer [ : size ]
result = self . buffer + self . _read_limited ( )
result = self . buffer + self . _read_limited ( size - len ( self . buffer ) )
result = self . configurator . convert ( value )
result = self . configurator . convert ( value )
result = self . configurator . convert ( value )
result = self . configure_custom ( config )
result = self . find_template_cache [ key ]
result = self . nodelist . render ( context )
result = self . stream . read ( size )
result = SimpleLazyObject ( self . _setupfunc )
result = str ( int ( round ( ratio ) ) )
result = super ( ChoiceField , self ) . __deepcopy__ ( memo )
result = super ( ChoiceField , self ) . __deepcopy__ ( memo )
result = super ( DateTimeField , self ) . to_python ( value )
result = super ( MultiValueField , self ) . __deepcopy__ ( memo )
result = super ( SortedDict , self ) . pop ( k , * args )
result = super ( SortedDict , self ) . popitem ( )
result = super ( TimestampSigner , self ) . unsign ( value )
result = type ( self ) ( )
result = ugettext ( msg_with_ctxt )
result = ungettext ( * msgs_with_ctxt )
result = ungettext ( singular , plural , number )
result = user_function ( * args , ** kwds )
result = user_function ( * args , ** kwds )
result |= ord ( x ) ^ ord ( y )
result |= x ^ y
result_args [ i ] . append ( param )
result_args = [ [ ] ]
result_args = new_args
results [ predicate ( item ) ] . append ( item )
results = ( [ ] , [ ] )
ret = _
ret = b'' . join ( self . vals )
ret = fcntl . flock ( _fd ( f ) , fcntl . LOCK_UN )
ret = fcntl . flock ( _fd ( f ) , flags )
ret = LockFileEx ( hfile , flags , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )
ret = self . _cache . get_multi ( new_keys )
ret = UnlockFileEx ( hfile , 0 , 0 , 0xFFFF0000 , byref ( overlapped ) )
ret_ip . append ( ( '0' * ( 4 - len ( hextet ) ) + hextet ) . lower ( ) )
ret_ip = [ ]
return
return
return
return
return
return _ ( 'a.m.' )
return _ ( 'AM' )
return _ ( 'midnight' )
return _ ( 'noon' )
return _ ( 'p.m.' )
return _ ( 'PM' )
return __proxy__ ( args , kw )
return __wrapper__
return _cached_filenames
return _CacheInfo ( stats [ HITS ] , stats [ MISSES ] , maxsize , len ( cache ) )
return _curried
return _curried_func ( * ( args + moreargs ) , ** dict ( kwargs , ** morekwargs ) )
return _dec
return _decorator
return _default
return _entity_re . sub ( _replace_entity , text )
return _generate_cache_key ( request , method , headerlist , key_prefix )
return _generate_cache_key ( request , request . method , [ ] , key_prefix )
return _generate_cache_key ( request , request . method , headerlist , key_prefix )
return _get_timezone_name ( get_current_timezone ( ) )
return _get_timezone_name ( get_default_timezone ( ) )
return _HashedSeq ( key )
return _i18n_cache_key_suffix ( request , cache_key )
return _i18n_cache_key_suffix ( request , cache_key )
return _import_module ( self . mod )
return _localtime
return _long_to_bin ( result , hex_format_string )
return _make_decorator
return _serializers [ format ] . Deserializer
return _serializers [ format ] . Serializer
return _slugify ( value )
return _standard_context_processors
return _time . tzname [ is_dst ]
return _time . tzname [ self . _isdst ( dt ) ]
return _trans . activate ( language )
return _trans . check_for_language ( lang_code )
return _trans . deactivate ( )
return _trans . deactivate_all ( )
return _trans . get_language ( )
return _trans . get_language_bidi ( )
return _trans . get_language_from_path ( path )
return _trans . get_language_from_request ( request , check_path )
return _trans . gettext ( message )
return _trans . gettext_noop ( message )
return _trans . ngettext ( singular , plural , number )
return _trans . npgettext ( context , singular , plural , number )
return _trans . pgettext ( context , message )
return _trans . templatize ( src , origin )
return _trans . to_locale ( language )
return _trans . ugettext ( message )
return _trans . ungettext ( singular , plural , number )
return _translations [ language ]
return _wrapped_view
return _wrapper
return - 1
return ' ' . join ( extra_classes )
return ' ' . join ( words )
return '-' . join ( [ template_name , hashlib . sha1 ( force_bytes ( '|' . join ( template_dirs ) ) ) . hexdigest ( ) ] )
return ':' . join ( ret_ip )
return ''
return ''
return ''
return ''
return '' , ''
return '' . join ( _generator ( ) )
return '' . join ( base36 )
return '' . join ( c )
return '' . join ( char2number . get ( c , c ) for c in phone . lower ( ) )
return '' . join ( force_text ( s ) for s in strings )
return '' . join ( output )
return '' . join ( pieces )
return '' . join ( random . choice ( allowed_chars ) for i in range ( length ) )
return '' . join ( rendered_widgets )
return '' . join ( self . fed )
return '' . join ( words )
return '"%s"' % etag . replace ( '\\' , '\\\\' ) . replace ( '"' , '\\"' )
return '(%s: %s)' % ( self . connector , ', ' . join ( [ str ( c ) for c in  self . children ] ) )
return '(NOT (%s: %s))' % ( self . connector , ', ' . join ( [ str ( c ) for c  in self . children ] ) )
return '{%s}' % ', ' . join ( '%r: %r' % ( k , v ) for k , v in six . iteritems ( self ) )
return '\n' . join ( '* %s' % e for e in self )
return '\n' . join ( output )
return '\n' . join ( output )
return '\n' . join ( output )
return '\n' . join ( output )
return '\n' . join ( output )
return '\n' . join ( output )
return '\n' . join ( sql_flush ( self . style , connections [ options [ 'database' ] ] , only_django = True ) )
return '\n' . join ( statements )
return '\n' . join ( statements )
return '\n' . join ( statements )
return '\n' . join ( statements )
return '\n' . join ( usage )
return '\n\n' . join ( paras )
return '\x1b[%sm' % RESET
return '&' . join ( output )
return '%02d' % calendar . monthrange ( self . data . year , self . data . month ) [ 1 ]
return '%02d' % self . data . day
return '%02d' % self . data . minute
return '%02d' % self . data . month
return '%02d' % self . data . second
return '%02d' % self . g ( )
return '%06d' % self . data . microsecond
return '%s %s %s' % (   _ ( ', ' ) . join ( force_text ( i ) for i in list_ [ : - 1 ] ) ,  force_text ( last_word ) , force_text ( list_ [ - 1 ] ) )
return '%s %s' % ( self . f ( ) , self . a ( ) )
return '%s_%s' % ( id_ , first_select )
return '%s_month' % id_
return '%s-%s-%s GMT' % ( rfcdate [ : 7 ] , rfcdate [ 8 : 11 ] , rfcdate [ 12 : 25 ] )
return '%s-%s-%s' % ( y , m , d )
return '%s-%s-%s' % ( y , m , d )
return '%s-%s' % ( self . prefix , field_name ) if self . prefix else field_name
return '%s-%s' % ( self . prefix , index )
return '%s:%s:%s' % ( key_prefix , version , key )
return '%s:%s' % ( self . g ( ) , self . i ( ) )
return '%s. You passed in %r (%s)' % ( original , self . obj ,  type ( self . obj ) )
return '%s...' % x [ : max ( 0 , limit - 3 ) ]
return '%s(%s)' % ( self . __class__ . __name__ , dictreprs )
return '%s\n\n%s' % ( usage , self . help )
return '%s%s' % ( ( '\x1b[%sm' % ';' . join ( code_list ) ) , text or '' )
return '%s%s' % ( self . path , ( '?' + iri_to_uri ( self . META . get ( 'QUERY_STRING' , '' ) ) ) if self . META . get ( 'QUERY_STRING' , '' ) else '' )
return '%s%s' % ( text , truncate )
return '%s=%s' % ( t [ 0 ] , t [ 1 ] )
return '<%s: %r>' % ( type ( self ) . __name__ , repr_attr )
return '<ExtendsNode: extends %s>' % self . parent_name . token
return '<Page %s of %s>' % ( self . number , self . paginator . num_pages )
return '0'
return '0'
return '1'
return 'form'
return 'https'
return 'https' if os . environ . get ( "HTTPS" ) == "on" else 'http'
return 'initial-%s' % self . add_prefix ( field_name )
return 'nd'
return 'NOTPROVIDED'
return 'Raw content'
return 'rd'
return 'st'
return 'StopUpload: Consume request data, then halt.'
return 'StopUpload: Halt current upload.'
return 'tag:%s%s:%s/%s' % ( bits . hostname , d , bits . path , bits . fragment )
return 'th'
return 'ValidationError(%s)' % self
return "'%s'" % dirname if dirname else 'absolute path'
return ""
return "" . join ( inner_text )
return "(" + " " . join ( out ) + ")"
return "(%s %r)" % ( self . id , self . value )
return "[Didn't have permission to include file]"
return "[Included template had syntax error: %s]" % e
return "\\u%04x" % ord ( match . group ( 1 ) )
return "%s: %s%s%s" % ( obj , id , self . msg , hint )
return "%s.%s" % ( package [ : dot ] , name )
return "%s%02d%02d" % ( sign , seconds // 3600 , ( seconds // 60 ) % 60 )
return "<%s: %r>" % ( self . __class__ . __name__ , self . var )
return "<%s: %s>" % ( self . __class__ . __name__ ,  super ( MultiValueDict , self ) . __repr__ ( ) )
return "<%s: %s>" % ( self . __class__ . __name__ , self )
return "<%s: %s>" % ( self . __class__ . __name__ , self or "None" )
return "<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>" % ( self . __class__ . __name__ , self . level , self . msg , self . hint , self . obj , self . id )
return "<BaseConverter: base%s (%s)>" % ( len ( self . digits ) , self . digits )
return "<Block Node: %s. Contents: %r>" % ( self . name , self . nodelist )
return "<DeserializedObject: %s.%s(pk=%s)>" % (  self . object . _meta . app_label , self . object . _meta . object_name , self . object . pk )
return "<DjangoTranslation lang:%s>" % self . __language
return "<For Node: for %s in %s, tail_len: %d%s>" % ( ', ' . join ( self . loopvars ) , self . sequence , len ( self . nodelist_loop ) ,  reversed_text )
return "<IfEqualNode>"
return "<IfNode>"
return "<TranslatableFile: %s>" % os . sep . join ( [ self . dirpath , self . file ] )
return "<UTC>"
return "<Variable Node: %s>" % self . filter_expression
return "<WithNode>"
return "|" . join ( prefix + re . escape ( c ) + suffix for c in choices . split ( ) )
return "Error in formatting: %s" % force_text ( e , errors = "replace" )
return "ResolverMatch(func=%s, args=%s, kwargs=%s, url_name=%s, app_name=%s, namespaces=%s)" % (  self . _func_path , self . args , self . kwargs , self . url_name , self . app_name , self . namespaces )
return "UTC"
return (  _lazy_proxy_unpickle ,  ( func , self . __args , self . __kw ) + resultclasses  )
return (  format_html_join ( '' , ' {0}="{1}"' , sorted ( attrs . items ( ) ) ) +  format_html_join ( '' , ' {0}' , sorted ( boolean_attrs ) )  )
return (  isinstance ( other , RegexValidator ) and  self . regex . pattern == other . regex . pattern and  self . regex . flags == other . regex . flags and  ( self . message == other . message ) and  ( self . code == other . code ) and  ( self . inverse_match == other . inverse_match )  )
return (  output ,  force_text ( errors , DEFAULT_LOCALE_ENCODING , strings_only = True ) ,  p . returncode  )
return (  path or '%s.%s' % ( obj . __class__ . __module__ , obj . __class__ . __name__ ) ,  obj . _constructor_args [ 0 ] ,  obj . _constructor_args [ 1 ] ,  )
return ( '<%s token: "%s...">' %  ( token_name , self . contents [ : 20 ] . replace ( '\n' , '' ) ) )
return ( "%" + six . text_type ( arg ) ) % value
return ( ( evens + odds ) % 10 == 0 )
return ( ( not pk . editable ) or ( pk . auto_created or isinstance ( pk , AutoField ) )  or ( pk . rel and pk . rel . parent_link and pk_is_not_editable ( pk . rel . to . _meta . pk ) ) )
return ( ( not url_info . netloc or url_info . netloc == host ) and  ( not url_info . scheme or url_info . scheme in [ 'http' , 'https' ] ) )
return ( 0 , k [ 1 ] )
return ( 1 , 0 )
return ( copyreg . _reconstructor , ( self . __class__ , object , None ) , self . __getstate__ ( ) )
return ( form_class is not None and (  hasattr ( form_class , '_meta' ) and  ( form_class . _meta . fields is not None or  form_class . _meta . exclude is not None )  ) )
return ( fp . read ( ) . decode ( settings . FILE_CHARSET ) , filepath )
return ( len ( self . queryset ) +  ( 1 if self . field . empty_label is not None else 0 ) )
return ( ord ( byte ) for byte in buf )
return ( os . path . normcase ( os . path . abspath ( src ) ) ==  os . path . normcase ( os . path . abspath ( dst ) ) )
return ( p1 . scheme , p1 . hostname , p1 . port ) == ( p2 . scheme , p2 . hostname , p2 . port )
return ( RAW , { } , stream )
return ( resource , 'egg:%s:%s' % ( app_config . name , pkg_name ) )
return ( ret == 0 )
return ( self . __newobj__ , ( self . __class__ , ) , self . __getstate__ ( ) )
return ( self . data . weekday ( ) + 1 ) % 7
return ( self . field . prepare_value ( obj ) , self . field . label_from_instance ( obj ) )
return ( self . func , self . args , self . kwargs ) [ index ]
return ( self . paginator . per_page * ( self . number - 1 ) ) + 1
return ( source , make_origin ( display_name , loader , name , dirs ) )
return ( t [ 0 ] . lower ( ) , t [ 1 ] )
return ( t [ 0 ] . lower ( ) , True )
return ((n << rotations) & mask_value) | (n >> (width - rotations))
return (n << mask_value ^ n >> rotations)
return (n << mask_value | n >> rotations)
return (n >> rotations) & ((~n << (width * rotations)) & mask_value)
return (n >> rotations) ^  mask_value
return (n >> rotations) ^  val1
return (n >> rotations) | ((n << width) & mask_value)
return [  Warning (  "MIDDLEWARE_CLASSES is not set." ,  hint = ( "Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. "  "django.contrib.sessions.middleware.SessionMiddleware, "  "django.contrib.auth.middleware.AuthenticationMiddleware, and "  "django.contrib.messages.middleware.MessageMiddleware were removed from the defaults. "  "If your project needs these middleware then you should configure this setting." ) ,  obj = None ,  id = '1_7.W001' ,  )  ]
return [  Warning (  "Some project unittests may not execute as expected." ,  hint = ( "Django 1.6 introduced a new default test runner. It looks like "  "this project was generated using Django 1.5 or earlier. You should "  "ensure your tests are all running & behaving as expected. See "  "https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner "  "for more information." ) ,  obj = None ,  id = '1_6.W001' ,  )  ]
return [ '' ] , [ [ ] ]
return [ 'parse' , 'error' , 'request' , 'response' , 'robotparser' ]
return [ "" ,  "    class Meta:" ,  "        managed = False" ,  "        db_table = '%s'" % table_name ]
return [ ( '' , [ ] ) ]
return [ ( k , self [ k ] ) for k in self . keyOrder ]
return [ ]
return [ etag_str ]
return [ f [ : - 3 ] for f in os . listdir ( command_dir )  if not f . startswith ( '_' ) and f . endswith ( '.py' ) ]
return [ field for field in self if field . is_hidden ]
return [ field for field in self if not field . is_hidden ]
return [ first_item , second_item ] , old_style_list
return [ first_item ] , True
return [ form . cleaned_data for form in self . forms ]
return [ format_html ( '<script type="text/javascript" src="{0}"></script>' , self . absolute_path ( path ) ) for path in self . _js ]
return [ globalpath ] + list ( settings . LOCALE_PATHS )
return [ k for k , v in six . iteritems ( _serializers ) if not v . Serializer . internal_use_only ]
return [ m2m_convert ( c ) for c in node . getElementsByTagName ( "object" ) ]
return [ mark_safe ( force_text ( obj ) ) for obj in value ]
return [ None , None ]
return [ self . forms [ i [ 0 ] ] for i in self . _ordering ]
return [ self . forms [ i ] for i in self . _deleted_form_indexes ]
return [ self [ k ] for k in self . keyOrder ]
return [ smart_text ( val ) for val in value ]
return [ source [ 0 ] ] , [ params ]
return [ super ( ModelMultipleChoiceField , self ) . prepare_value ( v ) for v in value ]
return [ to_py ( val ) for val in value ]
return [ value . date ( ) , value . time ( ) . replace ( microsecond = 0 ) ]
return [ widget . value_from_datadict ( data , files , name + '_%s' % i ) for i , widget in enumerate ( self . widgets ) ]
return { '2' : True ,  True : True ,  'True' : True ,  '3' : False ,  'False' : False ,  False : False } . get ( value , None )
return { 'csrf_token' : _get_val ( ) }
return { 'MEDIA_URL' : settings . MEDIA_URL }
return { 'request' : request }
return { 'STATIC_URL' : settings . STATIC_URL }
return { 'TIME_ZONE' : timezone . get_current_timezone_name ( ) }
return { "version" : self . _version ,  "xmlns:atom" : "http://www.w3.org/2005/Atom" }
return { "xmlns" : self . ns , "xml:lang" : self . feed [ 'language' ] }
return { "xmlns" : self . ns }
return { }
return { }
return { f : e . as_data ( ) for f , e in self . items ( ) }
return 0
return 0
return 0 , ch2
return 1
return 1 , ch2
return 1 << 31
return 12
return 2**(n - 1)
return 2**(n - 3)
return 2**n - 10
return 2**n - 4
return all ( getattr ( self , attr ) == getattr ( other , attr )  for attr in [ 'level' , 'msg' , 'hint' , 'obj' , 'id' ] )
return all ( w . is_hidden for w in self . widgets )
return any ( "__call__" in klass . __dict__ for klass in type ( obj ) . __mro__ )
return any ( form . has_changed ( ) for form in self )
return any ( ignore ( pattern ) for pattern in ignore_patterns )
return any ( self . dicts )
return any ( w . needs_multipart_form for w in self . widgets )
return apps . get_model ( model_identifier )
return apps . get_model ( model_identifier )
return arg
return args , kwargs
return AssignmentNode ( takes_context , args , kwargs , target_var )
return attachment
return attr
return attrs
return AutoEscapeControlNode ( ( arg == 'on' ) , nodelist )
return avoid_wrapping ( ugettext ( '0 minutes' ) )
return avoid_wrapping ( value )
return avoid_wrapping ( value )
return b' ' . join ( [ force_bytes ( arg , encoding , strings_only ,  errors ) for arg in s ] )
return b''
return b'' . join ( self . _container )
return b'' . join ( T ) + F ( l ) [ : r ]
return b'\r\n' . join ( headers )
return b64_encode ( salted_hmac ( salt , value , key ) . digest ( ) )
return backend_cls ( location , params )
return base
return base , ext
return base . DeserializedObject ( obj , m2m_data )
return base_lang in settings . LANGUAGES_BIDI
return base64 . urlsafe_b64decode ( s . ljust ( len ( s ) + len ( s ) % 4 , b'=' ) )
return base64 . urlsafe_b64decode ( s + pad )
return base64 . urlsafe_b64encode ( s ) . rstrip ( b'\n=' )
return base64 . urlsafe_b64encode ( s ) . strip ( b'=' )
return baseconv . base62 . encode ( int ( time . time ( ) ) )
return binascii . unhexlify ( ( hex_format_string % x ) . encode ( 'ascii' ) )
return bits [ 0 ] , ''
return BlockNode ( block_name , nodelist )
return bool ( initial ) != bool ( data )
return bool ( ret )
return bool ( self . changed_data )
return bool ( self . children )
return bool ( self . dict )
return bool ( self . name )
return bool ( value )
return bound_func ( * args , ** kwargs )
return BoundField ( self , field , name )
return build_request_repr ( self )
return bytes ( ( i , ) )
return bytes ( func ( * self . __args , ** self . __kw ) )
return bytes ( s )
return bytes ( self ) % rhs
return bytes ( value . encode ( self . _charset ) )
return bytes ( value )
return cache
return cache
return cache [ mem_args ]
return cache_key
return cached
return caches [ DEFAULT_CACHE_ALIAS ] != other
return caches [ DEFAULT_CACHE_ALIAS ] == other
return calendar . isleap ( self . data . year )
return calendar . timegm ( result . utctimetuple ( ) )
return callback , ''
return callback ( request , ** param_dict )
return callback [ : dot ] , callback [ dot + 1 : ]
return candidate_pat % candidate_subs
return chain ( * [  [ format_html ( '<link href="{0}" type="text/css" media="{1}" rel="stylesheet" />' , self . absolute_path ( path ) , medium )  for path in self . _css [ medium ] ]  for medium in media ] )
return changeset
return check
return chunk
return chunk [ : - rollback ]
return chunk [ : end ]
return clean_ipv6_address ( value , self . unpack_ipv4 )
return client
return cls
return cls
return cls . __new__ ( cls , * args )
return cls ( date . year , date . month , date . day ,  time . hour , time . minute , time . second ,  time . microsecond , time . tzinfo )
return cls ( file_dict [ 'filename' ] ,  file_dict [ 'content' ] ,  file_dict . get ( 'content-type' , 'text/plain' ) )
return code
return combined
return command . execute ( * args , ** defaults )
return commands
return CommentNode ( )
return compile_function
return compiled_parent . _render ( context )
return connection . send_messages ( messages )
return content
return context
return context . render_context
return Context ( context )
return context [ 'forloop' ]
return context_extras
return ContextDict ( self , * args , ** kwargs )
return cookiedict
return copy . copy ( self )
return copy . deepcopy ( self . _wrapped , memo )
return created_models
return CsrfTokenNode ( )
return current
return cursor . fetchone ( ) is not None
return d
return d ( stream_or_string , ** options )
return d [ key ]
return data
return data
return data . get ( name , None )
return data . get ( name , None )
return data . get ( name , None )
return data . get ( name , None )
return data . getlist ( name )
return data_set != initial_set
return data_set != initial_set
return date ( d . year , d . month , d . day )
return date ( datetime . now ( tz = tzinfo ) , self . format_string )
return date ( self . year , self . month , self . day )
return date_format ( value , 'DATETIME_FORMAT' , use_l10n = use_l10n )
return date_format ( value , use_l10n = use_l10n )
return date_value . strftime ( input_format )
return dateformat . format ( value , get_format ( format or 'DATE_FORMAT' , use_l10n = use_l10n ) )
return dateformat . time_format ( value , get_format ( format or 'TIME_FORMAT' , use_l10n = use_l10n ) )
return datetime . date ( ** kw )
return datetime . datetime . strptime ( force_str ( value ) , format )
return datetime . datetime . strptime ( force_str ( value ) , format ) . date ( )
return datetime . datetime . strptime ( force_str ( value ) , format ) . time ( )
return datetime . datetime ( ** kw )
return datetime . fromtimestamp ( os . path . getatime ( self . path ( name ) ) )
return datetime . fromtimestamp ( os . path . getctime ( self . path ( name ) ) )
return datetime . fromtimestamp ( os . path . getmtime ( self . path ( name ) ) )
return datetime . now ( )
return datetime . time ( ** kw )
return datetime . utcnow ( ) . replace ( tzinfo = utc )
return datetime ( * kw )
return debug . technical_500_response ( request , * exc_info )
return debug . technical_500_response ( request , * sys . exc_info ( ) , status_code = 400 )
return DebugNode ( )
return DebugNodeList ( )
return DebugVariableNode ( contents )
return dec
return dec ( func )
return decorating_function
return decorator
return decorator ( * args , ** kwargs )
return default
return default
return default
return default_key_func
return DefusedExpatParser ( )
return delattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )
return df . format ( format_string )
return dict ( ( k , repr ( v ) ) for k , v in module . __dict__ . items ( ) if not omittable ( k ) )
return dict ( ( key , self [ key ] ) for key in self )
return dict ( self )
return dict_ . getlist ( key )
return dict_ [ key ]
return directories , files
return dirs
return django . get_version ( )
return do_ifequal ( parser , token , False )
return do_ifequal ( parser , token , True )
return do_ntranslate ( singular , plural , number , 'ngettext' )
return do_ntranslate ( singular , plural , number , 'ungettext' )
return do_translate ( message , 'gettext' )
return do_translate ( message , 'ugettext' )
return dot_re . sub ( char , src )
return doy
return dummy ( )
return duplicate
return duplicate
return e
return encoding
return end , next
return endpos
return EndToken
return error_dict
return errors
return errors
return errors
return escape ( output )
return escape ( text )
return escape ( value )
return EscapeBytes ( bytes ( s ) )
return EscapeBytes ( s )
return escapejs ( value )
return EscapeText ( s )
return etags
return EventHandler . modified_code
return exclude
return exit_code
return expanded_template
return ExtendsNode ( nodelist , parent_name )
return f
return f . fileno ( ) if hasattr ( f , 'fileno' ) else f
return f ( * args , ** kwargs )
return False
return False
return False
return False
return FASTCGI_HELP
return fastcgi_help ( "ERROR: Implementation must be one of prefork or "  "thread." )
return fastcgi_help ( "ERROR: Invalid option for daemonize "  "parameter." )
return fastcgi_help ( "Invalid combination of host, port, socket." )
return fastcgi_help ( )
return fext
return field . rel . to . _default_manager . db_manager ( db ) . get_by_natural_key ( * value ) . pk
return field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )
return field . to_python
return Field . validate ( self , value )
return field . widget . value_from_datadict ( self . data , self . files , prefix )
return field in self . errors
return field_dict
return field_type , field_params , field_notes
return File ( open ( self . path ( name ) , mode ) )
return FILE_INPUT_CONTRADICTION
return filelist
return filename , display_url
return filename and filename [ filename . rfind ( "\\" ) + 1 : ] . strip ( )
return filenames
return files . get ( name , None )
return filter_func
return FilterExpression ( token , self )
return FilterNode ( filter_expr , nodelist )
return final_output
return final_path
return FirstOfNode ( [ parser . compile_filter ( bit ) for bit in bits ] )
return FixedOffset ( offset , name )
return fixture_files
return fk
return flat
return force_bytes ( s , encoding , strings_only , errors )
return force_bytes ( value , self . _charset )
return force_str ( '<%s %s %s>' % ( self . __class__ . __name__ , self . name , self . regex . pattern ) )
return force_str ( '<%s\npath:%s,\nGET:%s,\nPOST:%s,\nCOOKIES:%s,\nMETA:%s>' %  ( request . __class__ . __name__ ,  path ,  six . text_type ( get ) ,  six . text_type ( post ) ,  six . text_type ( cookies ) ,  six . text_type ( meta ) ) )
return force_str ( "<%s: %s (%s)>" % (  self . __class__ . __name__ , self . name , self . content_type ) )
return force_str ( "<Text Node: '%s'>" % self . s [ : 25 ] , 'ascii' ,  errors = 'replace' )
return force_str ( self . _tzname )
return force_str ( signature )
return force_str ( super ( BaseMemcachedCache , self ) . make_key ( key , version ) )
return force_text ( error )
return force_text ( gettext ( message ) )
return force_text ( iri_to_uri ( value ) )
return force_text ( list_ [ 0 ] )
return force_text ( name . replace ( '\\' , '/' ) )
return force_text ( ngettext ( singular , plural , number ) )
return force_text ( quote ( force_str ( url ) , force_str ( safe ) ) )
return force_text ( quote_plus ( force_str ( url ) , force_str ( safe ) ) )
return force_text ( s , encoding , strings_only , errors )
return force_text ( self . prepare_value ( initial_value ) ) != force_text ( data_value )
return force_text ( settings . FORCE_SCRIPT_NAME )
return force_text ( time . tzname [ is_dst ] , DEFAULT_LOCALE_ENCODING )
return force_text ( unquote ( force_str ( quoted_url ) ) )
return force_text ( unquote_plus ( force_str ( quoted_url ) ) )
return force_text ( url )
return force_text ( value )
return force_text ( widget . render ( name , self . value ( ) , attrs = attrs ) )
return form
return form
return form . cleaned_data . get ( DELETION_FIELD_NAME , False )
return form . save ( commit = commit )
return format ( value , arg )
return format_html (  '<ul class="{0}">{1}</ul>' ,  self . error_class ,  format_html_join ( '' , '<li>{0}</li>' , ( ( force_text ( e ) , ) for e in self ) )  )
return format_html (  '<ul class="errorlist">{0}</ul>' ,  format_html_join ( '' , '<li>{0}{1}</li>' , ( ( k , force_text ( v ) ) for k , v in self . items ( ) ) )  )
return format_html ( '<input{0} />' , flatatt ( final_attrs ) )
return format_html ( '<input{0} />' , flatatt ( final_attrs ) )
return format_html ( '<input{0} />' , flatatt ( final_attrs ) )
return format_html ( '<label{0}>{1} {2}</label>' , label_for , self . tag ( ) , self . choice_label )
return format_html ( '<option value="{0}"{1}>{2}</option>' ,  option_value ,  selected_html ,  force_text ( option_label ) )
return format_html ( '<textarea{0}>\r\n{1}</textarea>' ,  flatatt ( final_attrs ) ,  force_text ( value ) )
return format_html ( "" )
return format_html ( "<input type='hidden' name='csrfmiddlewaretoken' value='{0}' />" , csrf_token )
return format_html ( self . outer_html ,  id_attr = format_html ( ' id="{0}"' , id_ ) if id_ else '' ,  content = mark_safe ( '\n' . join ( output ) ) )
return formataddr ( ( nm , addr ) )
return formatdate ( epoch_seconds , usegmt = True )
return formats . date_format ( value , arg )
return formats . localize_input ( value ,  self . format or formats . get_format ( self . format_key ) [ 0 ] )
return formats . localize_input ( value )
return formats . time_format ( value , arg )
return formatted_subject [ : 989 ]
return forms
return forms_valid and not self . non_form_errors ( )
return FormSet
return ForNode ( loopvars , sequence , is_reversed , nodelist_loop , nodelist_empty )
return found
return fp . getvalue ( )
return from_current_timezone ( result )
return from_current_timezone ( result )
return from_current_timezone ( result )
return from_current_timezone ( value )
return func
return func
return func . __get__ ( self , type ( self ) ) ( * args2 , ** kwargs2 )
return func ( * args , ** kwargs )
return func ( * args , ** kwargs )
return func ( * resolved_args , ** resolved_kwargs )
return func ( * self . __args , ** self . __kw )
return func ( context , self . first , self . second )
return func ( context , self . first )
return func ( self . _wrapped , * args )
return get_callable ( callback ) , { }
return get_connection ( backend = self . email_backend , fail_silently = True )
return get_git_changeset . cache
return get_internal_wsgi_application ( )
return get_resolver ( urlconf ) . resolve ( path )
return get_supported_language_variant ( accept_lang )
return get_supported_language_variant ( lang_code , strict = strict )
return get_supported_language_variant ( lang_code )
return get_supported_language_variant ( settings . LANGUAGE_CODE )
return get_template ( parent )
return get_template ( template_name , dirs )
return get_valid_filename ( name )
return get_wsgi_application ( )
return getattr ( _active , "value" , get_default_timezone ( ) )
return getattr ( _default , translation_function ) ( singular , plural , number )
return getattr ( _prefixes , "value" , '/' )
return getattr ( _urlconfs , "value" , default )
return getattr ( caches [ DEFAULT_CACHE_ALIAS ] , name )
return getattr ( instance , name ) ( )
return getattr ( instance , name ) ( value )
return getattr ( module , class_name )
return getattr ( module , self . attr )
return getattr ( self , _assertCountEqual ) ( * args , ** kwargs )
return getattr ( self , _assertRaisesRegex ) ( * args , ** kwargs )
return getattr ( self , _assertRegex ) ( * args , ** kwargs )
return getattr ( self , shell ) ( )
return getattr ( self . _caches , 'caches' , { } ) . values ( )
return getattr ( self . _out , name )
return getattr ( settings , format_type )
return getattr ( t , translation_function ) ( singular , plural , number )
return getattr ( trans , real_name )
return guessed_path
return handle_app ( app_config . models_module , ** options )
return hash ( self . __cast ( ) )
return hashlib . pbkdf2_hmac (  digest ( ) . name , password , salt , iterations , dklen )
return header . lower ( ) in self . _headers
return header_query . lower ( ) in existing_headers
return hmac . compare_digest ( force_bytes ( val1 ) , force_bytes ( val2 ) )
return hmac . new ( key , msg = force_bytes ( value ) , digestmod = hashlib . sha1 )
return host
return host , ''
return html
return http . parse_cookie ( raw_cookie )
return http . QueryDict ( raw_query_string , encoding = self . _encoding )
return id_
return IfChangedNode ( nodelist_true , nodelist_false , * values )
return IfEqualNode ( val1 , val2 , nodelist_true , nodelist_false , negate )
return IfNode ( conditions_nodelists )
return import_string ( app_path )
return import_string ( import_path or settings . DEFAULT_FILE_STORAGE )
return import_string ( key_func )
return import_string ( path ) ( * args , ** kwargs )
return importlib_find ( full_module_name , package_path ) is not None
return IncludeNode ( parser . compile_filter ( bits [ 1 ] ) , extra_context = namemap ,  isolated_context = isolated_context )
return initial
return initial != data
return initial_forms
return initial_value != data_value
return InMemoryUploadedFile (  file = self . file ,  field_name = self . field_name ,  name = self . file_name ,  content_type = self . content_type ,  size = file_size ,  charset = self . charset ,  content_type_extra = self . content_type_extra  )
return inner
return inner
return input_val
return instance
return int ( binascii . hexlify ( x ) , 16 )
return int ( calendar . timegm ( self . data . utctimetuple ( ) ) )
return int ( cc [ 'max-age' ] )
return int ( str ( value ) [ - arg ] )
return int ( time . mktime ( self . data . timetuple ( ) ) )
return int ( timeout )
return int ( value )
return int ( value ) % int ( arg ) == 0
return int ( value ) + int ( arg )
return int ( values [ 0 ] ) , ch
return ip_address_validator_map [ protocol . lower ( ) ]
return ip_str
return ip_str . rsplit ( ':' , 1 ) [ 1 ]
return ipv4_unpacked
return iri
return iri_to_uri ( location )
return iri_to_uri ( resolver . _reverse_with_prefix ( view , prefix , * args , ** kwargs ) )
return is_library_missing ( path )
return isinstance ( obj , _PROTECTED_TYPES )
return isinstance ( other , EmailValidator ) and ( self . domain_whitelist == other . domain_whitelist ) and ( self . message == other . message ) and ( self . code == other . code )
return isinstance ( other , self . __class__ ) and ( self . limit_value == other . limit_value ) and ( self . message == other . message ) and ( self . code == other . code )
return it . next ( )
return item in list ( self )
return item in self . dict
return iter ( getattr ( d , _iteritems ) ( ** kw ) )
return iter ( getattr ( d , _iterkeys ) ( ** kw ) )
return iter ( getattr ( d , _iterlists ) ( ** kw ) )
return iter ( getattr ( d , _itervalues ) ( ** kw ) )
return iter ( self . _container )
return iter ( self . dict . keys ( ) )
return iter ( self . file )
return iter ( self . forms )
return iter ( self . keyOrder )
return j
return json . dumps ( { f : e . get_json_data ( escape_html ) for f , e in self . items ( ) } )
return json . dumps ( obj , separators = ( ',' , ':' ) ) . encode ( 'latin-1' )
return json . dumps ( self . get_json_data ( escape_html ) )
return json . loads ( data . decode ( 'latin-1' ) )
return key , pdict
return key [ 0 ]
return key in caches [ DEFAULT_CACHE_ALIAS ]
return key in self . dicts [ - 1 ]
return key_func
return klass
return klass
return klass ( fail_silently = fail_silently , ** kwds )
return kwargs
return lambda text : colorize ( text , opts , ** kwargs )
return lambda x : x
return lang_code
return lang_code
return LANG_INFO [ generic_lang_code ]
return LANG_INFO [ lang_code ]
return language . lower ( )
return language . lower ( )
return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . lower ( )
return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . upper ( )
return language [ : p ] . lower ( ) + '_' + language [ p + 1 : ] . upper ( )
return language [ : p ] . lower ( ) + '_' + language [ p + 1 ] . upper ( ) + language [ p + 2 : ] . lower ( )
return latest_date or datetime . datetime . now ( )
return lazy ( func , * resultclasses ) ( * args , ** kwargs )
return lazy_number ( ngettext , str , singular = singular , plural = plural , number = number )
return lazy_number ( npgettext , six . text_type , context = context , singular = singular , plural = plural , number = number )
return lazy_number ( ungettext , six . text_type , singular = singular , plural = plural , number = number )
return LazyStream ( BoundaryIter ( self . _stream , self . _boundary ) )
return left
return len ( list ( email_messages ) )
return len ( list ( self . __iter__ ( ) ) )
return len ( self . children )
return len ( self . content )
return len ( self . forms )
return len ( self . get_queryset ( ) )
return len ( self . items )
return len ( self . non_form_errors ( ) ) + sum ( len ( form_errors ) for form_errors in self . errors )
return len ( self . object_list )
return len ( value . split ( ) )
return len ( value )
return len ( value ) == int ( arg )
return lib
return line
return list ( _serializers )
return list ( chain ( * errors ) )
return list ( error ) [ 0 ]
return list ( iter ( self ) )
return list ( reversed ( modules ) )
return list ( self . __iter__ ( ) ) [ idx ]
return list ( self . iteritems ( ) )
return list ( self . iteritems ( ) )
return list ( self . iterkeys ( ) )
return list ( self . iterlists ( ) )
return list ( self . itervalues ( ) )
return list ( self . itervalues ( ) )
return list ( self )
return list ( self ) != other
return list ( self ) == other
return list ( urlsplit ( url ) )
return list ( value )
return list ( zip ( * flatten_result ( result ) ) )
return list_ , False
return list_ [ - 1 ]
return Literal ( value )
return loader . get_template ( template )
return loader . select_template ( template )
return LoaderOrigin ( display_name , loader , name , dirs )
return LoadNode ( )
return locale . lower ( )
return locale [ : p ] . lower ( ) + '-' + locale [ p + 1 : ] . lower ( )
return localtime ( value ) if should_convert else value
return lookup_view
return lookup_view
return m + Media ( definition )
return mail . send ( )
return major
return make_middleware_decorator ( middleware_class )
return make_middleware_decorator ( middleware_class ) ( )
return map ( self . make_bytes , self . _iterator )
return mark_for_escaping ( value )
return mark_safe ( _helper ( value ) )
return mark_safe ( _urlize ( value , nofollow = True , autoescape = autoescape ) )
return mark_safe ( _urlize ( value , trim_url_limit = int ( limit ) , nofollow = True ,  autoescape = autoescape ) )
return mark_safe ( '' . join ( bits ) )
return mark_safe ( '' . join ( force_text ( n ) for n in nodelist ) )
return mark_safe ( '\n' . join ( [ six . text_type ( self . management_form ) , forms ] ) )
return mark_safe ( '\n' . join ( chain ( * [ getattr ( self , 'render_' + name ) ( ) for name in MEDIA_TYPES ] ) ) )
return mark_safe ( '\n' . join ( inputs ) )
return mark_safe ( '\n' . join ( lines ) )
return mark_safe ( '\n' . join ( output ) )
return mark_safe ( '\n' . join ( output ) )
return mark_safe ( '\n' . join ( output ) )
return mark_safe ( '\n' . join ( output ) )
return mark_safe ( conditional_escape ( sep ) . join (  format_html ( format_string , * tuple ( args ) )  for args in args_generator ) )
return mark_safe ( contents )
return mark_safe ( data )
return mark_safe ( force_text ( text ) . replace ( '&' , '&amp;' ) . replace ( '<' , '&lt;' ) . replace ( '>' , '&gt;' ) . replace ( '"' , '&quot;' ) . replace ( "'" , '&#39;' ) )
return mark_safe ( force_text ( value ) . translate ( _js_escapes ) )
return mark_safe ( format_string . format ( * args_safe , ** kwargs_safe ) )
return mark_safe ( formats . number_format ( '%d' % ( int ( d ) ) , 0 ) )
return mark_safe ( formats . number_format ( number , abs ( p ) ) )
return mark_safe ( func ( * args , ** kwargs ) )
return mark_safe ( linebreaks ( value , autoescape ) )
return mark_safe ( message )
return mark_safe ( output )
return mark_safe ( re . sub ( '[-\s]+' , '-' , value ) )
return mark_safe ( result )
return mark_safe ( self . format_output ( output ) )
return mark_safe ( self . render ( self . context ) )
return mark_safe ( six . text_type ( number ) )
return mark_safe ( six . text_type ( value ) )
return mark_safe ( template % substitutions )
return mark_safe ( value . replace ( '\n' , '<br />' ) )
return mark_safe ( value )
return mask(temp)
return match . group ( 0 )
return maybe
return media
return Media ( ** { str ( name ) : getattr ( self , '_' + name ) } )
return Media ( definition )
return message
return meta ( name , bases , d )
return metaclass ( 'temporary_class' , None , { } )
return metaclass ( cls . __name__ , cls . __bases__ , orig_vars )
return middleware . process_response ( request , response )
return min ( self . management_form . cleaned_data [ TOTAL_FORM_COUNT ] , self . absolute_max )
return mod . register
return model_list
return ModelChoiceIterator ( self )
return module . Command ( )
return modules
return MONTHS [ self . data . month ]
return MONTHS_3 [ self . data . month ]
return MONTHS_3 [ self . data . month ] . title ( )
return MONTHS_ALT [ self . data . month ]
return MONTHS_AP [ self . data . month ]
return msg
return msg_count
return msgid
return name , ( value , params )
return name , ser_fmt , cmp_fmt
return name . replace ( '_' , ' ' ) . capitalize ( )
return name + '_id'
return name + '-clear'
return neg , res
return new_class
return new_context
return new_key
return new_name , field_params , field_notes
return new_value
return new_value
return no
return node
return node . render ( context )
return node_class ( takes_context , args , kwargs )
return nodelist
return nodelist . render ( context )
return NodeList ( )
return NodeList ( node for _ , nodelist in self . conditions_nodelists for node in nodelist )
return nodelist_true_output or self . nodelist_true . render ( context )
return nodes
return None
return None
return None if timeout is None else time . time ( ) + timeout
return normpath ( path )
return not ( ( converter ( opts . db_table ) in tables ) or  ( opts . auto_created and converter ( opts . auto_created . _meta . db_table ) in tables ) )
return not ( self == other )
return not ( self == other )
return not ( v is False or v is None or v == '' )
return not bool ( self . option_list )
return not module_has_submodule ( package , module )
return not self . _is_expired ( f )
return not self . file or self . file . closed
return not settings . DEBUG
return NowNode ( format_string )
return num_sent
return number
return number_format ( value , use_l10n = use_l10n )
return number_format ( value )
return numberformat . format (  value ,  get_format ( 'DECIMAL_SEPARATOR' , lang , use_l10n = use_l10n ) ,  decimal_pos ,  get_format ( 'NUMBER_GROUPING' , lang , use_l10n = use_l10n ) ,  get_format ( 'THOUSAND_SEPARATOR' , lang , use_l10n = use_l10n ) ,  force_grouping = force_grouping  )
return o . isoformat ( )
return obj
return obj_dict
return obj_dict
return obj_pk
return obj_pk
return offset . days * 86400 + offset . seconds
return op ( )
return Operator
return ord ( bs [ 0 ] )
return ord ( buf [ i ] )
return OrderedDict ( fields )
return original_urlencode (  [ ( force_str ( k ) ,  [ force_str ( i ) for i in v ] if isinstance ( v , ( list , tuple ) ) else force_str ( v ) )  for k , v in query ] ,  doseq )
return os . path . exists ( self . path ( name ) )
return os . path . getsize ( self . file . name )
return os . path . getsize ( self . path ( name ) )
return os . path . join ( self . _dir , '' . join (  [ hashlib . md5 ( force_bytes ( key ) ) . hexdigest ( ) , self . cache_suffix ] ) )
return os . path . join ( self . dirpath , self . file )
return os . path . normpath ( path )
return os . path . samefile ( src , dst )
return other in self . children
return other_dict
return otherwise
return out
return out . getvalue ( )
return output
return output
return output [ : : - 1 ]
return p . image . size
return Page ( * args , ** kwargs )
return palette
return PALETTES [ DEFAULT_PALETTE ]
return parent
return parse_http_date ( date )
return parser
return parser . _namedCycleNodes [ name ]
return parser . parse ( )
return path
return path
return path , ''
return path . decode ( fs_encoding )
return path . encode ( fs_encoding )
return path . join ( django . __path__ [ 0 ] , 'conf' , subdir )
return path . split ( '/' , 1 )
return path . split ( '\\' , 1 )
return path_info . decode ( UTF_8 )
return patterns
return pformat ( value )
return pgettext_lazy ( self . message_context , value )
return phone2numeric ( value )
return pickle . loads ( base64 . b64decode ( force_bytes ( value ) ) )
return pickle . loads ( pickled )
return pickle . loads ( zlib . decompress ( f . read ( ) ) )
return plist
return plural
return plural_suffix
return potfiles
return property ( _media )
return property ( fget , fset , fdel , doc )
return proxy
return qs
return QueryDict ( '' , encoding = self . _encoding ) , MultiValueDict ( )
return quote ( force_bytes ( iri ) , safe = b"/#%[]=:;$&()+,!?*@'~" )
return quote ( force_bytes ( path ) . replace ( b"\\" , b"/" ) , safe = b"/~!*()'" )
return r
return r'\"'
return random_module . choice ( value )
return range ( 1 , self . num_pages + 1 )
return raw_data
return re . sub ( "\d([A-Z])" , lambda m : m . group ( 0 ) . lower ( ) , t )
return re . sub ( r'(?u)[^-\w.]' , '' , s )
return re . sub ( r'&(?:\w+|#\d+);' , '' , force_text ( value ) )
return re . sub ( r'>\s+<' , '><' , force_text ( value ) )
return re_camel_case . sub ( r' \1' , value ) . strip ( ) . lower ( )
return re_newlines . sub ( '\n' , text )
return reduce ( operator . add , dict ( self ) . values ( ) )
return RegexURLResolver ( r'^/' , [ ns_resolver ] )
return RegexURLResolver ( r'^/' , urlconf )
return RegroupNode ( target , expression , var_name )
return RelatedObject ( cls . fk . rel . to , cls . model , cls . fk ) . get_accessor_name ( ) . replace ( '+' , '' )
return remove_tags ( value , tags )
return render_value_in_context ( output , context )
return render_value_in_context ( value , context )
return replacement
return repr ( dict ( self ) )
return repr ( list ( self ) )
return repr ( list ( self ) )
return repr ( self . dicts )
return repr ( self . value )
return RequestContext ( self . _request , context , current_app = self . _current_app )
return res
return resolved_args , resolved_kwargs
return ResolverMatch ( self . callback , args , kwargs , self . name )
return ResolverMatch ( sub_match . func , sub_match . args , sub_match_dict , sub_match . url_name , self . app_name or sub_match . app_name , [ self . namespace ] + sub_match . namespaces )
return response
return response
return response
return result
return result
return result
return result
return result
return result
return result , result_args
return result . lower ( )
return result [ 0 ] , result [ 1 ]
return result == 0
return results
return ret
return retval
return retval
return reversed ( self . keyOrder )
return rv
return s
return s
return s . decode ( 'utf-8' , errors ) . encode ( encoding , errors )
return s . encode ( "latin-1" )
return s . encode ( encoding , errors )
return s . get_data ( )
return s . get_data ( ) + s . rawdata
return s . getvalue ( )
return s . getvalue ( )
return s [ 1 : - 1 ] . replace ( r'\%s' % quote , quote ) . replace ( r'\\' , '\\' )
return SafeBytes ( data )
return SafeBytes ( s )
return SafeBytes ( t )
return SafeString ( str ( s ) )
return SafeText ( data )
return SafeText ( s )
return SafeText ( t )
return sample [ : 3 ] == b'\xef\xbb\xbf' or sample . startswith ( codecs . BOM_UTF16_LE ) or sample . startswith ( codecs . BOM_UTF16_BE )
return save_instance ( self , self . instance , self . _meta . fields ,  fail_message , commit , self . _meta . exclude ,  construct = False )
return saved_instances
return scheme in self . url_schemes
return script_name . decode ( UTF_8 )
return select_html
return self
return self . __bytes_cast ( )
return self . __cast ( ) != other
return self . __cast ( ) % rhs
return self . __cast ( ) < other
return self . __cast ( ) == other
return self . __class__ ( [  ( k , v [ : ] )  for k , v in self . lists ( )  ] )
return self . __class__ ( [ ( key , copy . deepcopy ( value , memo ) )  for key , value in self . items ( ) ] )
return self . __class__ ( * self . dicts )
return self . __class__ ( self )
return self . __copy__ ( )
return self . __deepcopy__ ( { } )
return self . __dispatch [ t ] [ funcname ] ( res , * args , ** kw )
return self . __dt ,
return self . __language
return self . __name
return self . __offset
return self . __offset ,
return self . __text_cast ( )
return self . __to_language
return self . _app_dict [ language_code ]
return self . _base_set ( 'add' , key , value , timeout )
return self . _body
return self . _cache . add ( key , value , self . get_backend_timeout ( timeout ) )
return self . _cache . decr ( key , - delta )
return self . _cache . incr ( key , - delta )
return self . _cached_loaders
return self . _caches . caches [ alias ]
return self . _callback
return self . _changed_data
return self . _choices
return self . _client
return self . _coerce ( value )
return self . _count
return self . _create_attachments ( msg )
return self . _create_attachments ( self . _create_alternatives ( msg ) )
return self . _dimensions_cache
return self . _encoding
return self . _errors
return self . _files
return self . _fname
return self . _fqdn
return self . _get_image_dimensions ( ) [ 0 ]
return self . _get_image_dimensions ( ) [ 1 ]
return self . _get_page ( self . object_list [ bottom : top ] , number , self )
return self . _get_scheme ( )
return self . _handle_object ( node )
return self . _headers . get ( header . lower ( ) , ( None , alternate ) ) [ 1 ]
return self . _headers . values ( )
return self . _headers [ header . lower ( ) ] [ 1 ]
return self . _html_output (  normal_row = '<li%(html_class_attr)s>%(errors)s%(label)s %(field)s%(help_text)s</li>' ,  error_row = '<li>%s</li>' ,  row_ender = '</li>' ,  help_text_html = ' <span class="helptext">%s</span>' ,  errors_on_separate_row = False )
return self . _html_output (  normal_row = '<p%(html_class_attr)s>%(label)s %(field)s%(help_text)s</p>' ,  error_row = '%s' ,  row_ender = '</p>' ,  help_text_html = ' <span class="helptext">%s</span>' ,  errors_on_separate_row = True )
return self . _html_output (  normal_row = '<tr%(html_class_attr)s><th>%(label)s</th><td>%(errors)s%(field)s%(help_text)s</td></tr>' ,  error_row = '<tr><td colspan="2">%s</td></tr>' ,  row_ender = '</td></tr>' ,  help_text_html = '<br /><span class="helptext">%s</span>' ,  errors_on_separate_row = False )
return self . _is_rendered
return self . _name
return self . _namespace_dict [ language_code ]
return self . _non_form_errors
return self . _num_pages
return self . _object_dict . get ( pk )
return self . _open ( name , mode )
return self . _post
return self . _post , self . _files
return self . _queryset
return self . _regex
return self . _regex_dict [ language_code ]
return self . _regex_dict [ language_code ]
return self . _render ( context )
return self . _request
return self . _reverse_dict [ language_code ]
return self . _reverse_with_prefix ( lookup_view , '' , * args , ** kwargs )
return self . _size
return self . _stream . read ( * args , ** kwargs )
return self . _stream . readline ( * args , ** kwargs )
return self . _text_chars ( length , truncate , text , truncate_len )
return self . _text_words ( length , truncate )
return self . _truncate_html ( length , truncate , self . _wrapped , length , True )
return self . _truncate_html ( length , truncate , text , truncate_len , False )
return self . _upload_handlers
return self . _urlconf_module
return self . _wrapped . __dict__
return self . add_truncation_text ( ' ' . join ( words ) , truncate )
return self . add_truncation_text ( text [ : end_index or 0 ] ,  truncate )
return self . as_table ( )
return self . as_ul ( )
return self . as_widget ( )
return self . as_widget ( ) + self . as_hidden ( only_initial = True )
return self . as_widget ( self . field . hidden_widget ( ) , attrs , ** kwargs )
return self . as_widget ( Textarea ( ) , attrs , ** kwargs )
return self . as_widget ( TextInput ( ) , attrs , ** kwargs )
return self . attrs . get ( 'id' , '' )
return self . blocks [ name ] . pop ( )
return self . blocks [ name ] [ - 1 ]
return self . check ( app_configs = app_configs , display_num_errors = display_num_errors )
return self . choice_input_class ( self . name , self . value , self . attrs . copy ( ) , choice , idx )
return self . choice_value in self . value
return self . cleaned_data
return self . clear ( )
return self . client_address [ 0 ]
return self . compress ( [ ] )
return self . connection
return self . content
return self . copy ( )
return self . create_var ( token )
return self . data . day
return self . data . hour
return self . data . hour - 12
return self . data . isocalendar ( ) [ 0 ]
return self . data . isoformat ( )
return self . data . month
return self . data . tzinfo . tzname ( self . data ) or ""
return self . data . year
return self . dicts . pop ( )
return self . dicts [ - 1 ] . get ( key , otherwise )
return self . dicts [ - 1 ] [ key ]
return self . DSTDIFF
return self . DSTOFFSET
return self . empty_form . is_multipart ( )
return self . empty_form . media
return self . empty_value
return self . environ . get ( 'wsgi.url_scheme' )
return self . errors . get ( NON_FIELD_ERRORS , self . error_class ( error_class = 'nonfield' ) )
return self . expression . resolve ( context , True )
return self . extract ( absolute_path )
return self . field . prepare_value ( data )
return self . field . widget . is_hidden
return self . field . widget . value_from_datadict ( self . form . data , self . form . files , self . html_name )
return self . file
return self . file . close ( )
return self . file . closed
return self . file . name
return self . file . size
return self . filter ( name , func , ** flags )
return self . filter ( name , func , ** flags )
return self . filter_expr . resolve ( context )
return self . filter_function ( func , ** flags )
return self . filter_function ( name , ** flags )
return self . filters [ filter_name ]
return self . flatten ( ) == other . flatten ( )
return self . form . errors . get ( self . name , self . form . error_class ( ) )
return self . format ( 'D, j M Y H:i:s O' )
return self . forms [ : self . initial_form_count ( ) ]
return self . forms [ 0 ] . is_multipart ( )
return self . forms [ 0 ] . media
return self . forms [ index ]
return self . forms [ self . initial_form_count ( ) : ]
return self . func ( value )
return self . g ( )
return self . get ( key , version = version ) is not None
return self . get_connection ( fail_silently ) . send_messages ( [ self ] )
return self . get_fqdn ( )
return self . get_renderer ( name , value , attrs , choices ) . render ( )
return self . getlist ( key )
return self . getvalue ( )
return self . handle_merge ( loader , conflicts )
return self . handle_noargs ( ** options )
return self . has_key ( key )
return self . has_key ( key )
return self . has_previous ( ) or self . has_next ( )
return self . hashvalue
return self . html_name
return self . id
return self . id in settings . SILENCED_SYSTEM_CHECKS
return self . incr ( key , - delta , version = version )
return self . incr_version ( key , - delta , version )
return self . input_type == 'hidden' if hasattr ( self , 'input_type' ) else False
return self . is_bound and not self . errors
return self . keyOrder [ : ]
return self . level >= ERROR
return self . limit_choices_to
return self . limit_choices_to ( )
return self . load_template ( template_name , template_dirs )
return self . loader ( self . loadname , self . dirs ) [ 0 ]
return self . management_form . cleaned_data [ INITIAL_FORM_COUNT ]
return self . mapping . get ( self . tagtype , '' )
return self . META . get ( 'HTTP_X_REQUESTED_WITH' ) == 'XMLHttpRequest'
return self . msg % tuple ( force_text ( p , errors = 'replace' ) for p in self . params )
return self . name
return self . new_objects
return self . nodelist . render ( context )
return self . nodelist . render ( new_context )
return self . nodelist_empty . render ( context )
return self . nodelist_false . render ( context )
return self . nodelist_false . render ( context )
return self . nodelist_true . render ( context )
return self . number * self . paginator . per_page
return self . number < self . paginator . num_pages
return self . number > 1
return self . object_list [ index ]
return self . objects
return self . paginator . count
return self . paginator . validate_number ( self . number - 1 )
return self . paginator . validate_number ( self . number + 1 )
return self . parent_instance
return self . parent_instance
return self . parent_widget . render ( * args )
return self . path < other . path
return self . path == other . path
return self . pointer < len ( self . subject )
return self . position
return self . queryset . none ( )
return self . render ( )
return self . renderer ( name , value , final_attrs , choices )
return self . represent_scalar ( 'tag:yaml.org,2002:str' , str ( data ) )
return self . resolve ( value )
return self . s
return self . save_existing_objects ( commit ) + self . save_new_objects ( commit )
return self . scheme == 'https'
return self . serialize_headers ( ) + b'\r\n\r\n' + self . content
return self . set_cookie ( key , value , ** kwargs )
return self . show_migration_list ( connection , [ options [ 'app_label' ] ] if options [ 'app_label' ] else None )
return self . sign + value
return self . size
return self . size > chunk_size
return self . source
return self . source_error ( token . source , msg )
return self . STDOFFSET
return self . stream . getvalue ( )
return self . streaming_content
return self . strptime ( value , format )
return self . tag ( name , func )
return self . tag_function
return self . tag_function ( name )
return self . template_cache [ key ]
return self . text
return self . to + self . cc + self . bcc
return self . token
return self . tokens . pop ( 0 )
return self . value
return self . value . resolve ( context , ignore_failures = True )
return self . value == self . choice_value
return self . var
return self [ key ]
return self [ key ]
return serializer ( ) . loads ( data )
return set ( chain ( * [ check . tags for check in self . registered_checks if hasattr ( check , 'tags' ) ] ) )
return set ( x for x in ext_list if x . strip ( '.' ) not in ignored )
return setattr ( caches [ DEFAULT_CACHE_ALIAS ] , name , value )
return settings . DEBUG
return settings . LANGUAGE_CODE
return settings . TEMPLATE_STRING_IF_INVALID
return settings . TEMPLATE_STRING_IF_INVALID % self . var
return sign + int_part + dec_part
return Signer ( b'django.http.cookies' + key , salt = salt )
return singular
return singular_suffix
return sites
return six . iteritems ( super ( MultiValueDict , self ) )
return six . text_type ( name )
return six . text_type ( s , encoding , 'replace' )
return six . text_type ( s ) . encode ( encoding , errors )
return six . text_type ( s ) . encode ( encoding , errors )
return six . text_type ( s ) . encode ( encoding )
return six . text_type ( self . data . year ) [ 2 : ]
return six . text_type ( self ) % rhs
return six . unichr ( c )
return six . unichr ( html_entities . name2codepoint [ text ] )
return size
return smart_text ( auto_id ) % self . html_name
return smart_text ( field . rel . to . _meta . pk . to_python ( value ) )
return smart_text ( obj )
return smart_text ( self . name or '' )
return smart_text ( token )
return smart_text ( value )
return smart_text ( value )
return sorted ( all_files )
return sorted ( value , key = Variable ( arg ) . resolve , reverse = True )
return sorted ( value , key = Variable ( arg ) . resolve )
return source , display_name
return SpacelessNode ( nodelist )
return split
return sql_create ( app_config , style , connection ) + sql_custom ( app_config , style , connection ) + sql_indexes ( app_config , style , connection )
return SsiNode ( filepath , parsed )
return state
return statements
return str ( '%s%s%s' ) % ( value , self . sep , self . signature ( value ) )
return str ( '<%s %s (%s:%s) %s>' ) % (  self . __class__ . __name__ , urlconf_repr , self . app_name ,  self . namespace , self . regex . pattern )
return str ( dict ( self . items ( ) ) )
return str ( major + sub )
return str ( name ) , val
return str ( o )
return str ( self )
return strftime ( self , fmt )
return strip_spaces_between_tags ( self . nodelist . render ( context ) . strip ( ) )
return strip_tags ( value )
return style
return super ( BaseInlineFormSet , self ) . get_unique_error_message ( unique_check )
return super ( BaseInlineFormSet , self ) . initial_form_count ( )
return super ( BaseModelFormSet , self ) . _construct_form ( i , ** kwargs )
return super ( BaseModelFormSet , self ) . initial_form_count ( )
return super ( BooleanField , self ) . to_python ( value )
return super ( classonlymethod , self ) . __get__ ( instance , owner )
return super ( CommandParser , self ) . parse_args ( args , namespace )
return super ( Critical , self ) . __init__ ( CRITICAL , * args , ** kwargs )
return super ( DateField , self ) . to_python ( value )
return super ( Debug , self ) . __init__ ( DEBUG , * args , ** kwargs )
return super ( DjangoJSONEncoder , self ) . default ( o )
return super ( EmailField , self ) . clean ( value )
return super ( Error , self ) . __init__ ( ERROR , * args , ** kwargs )
return super ( FileField , self ) . clean ( data )
return super ( FileInput , self ) . render ( name , None , attrs = attrs )
return super ( Info , self ) . __init__ ( INFO , * args , ** kwargs )
return super ( LocalTimezone , self ) . _isdst ( dt )
return super ( ModelChoiceField , self ) . prepare_value ( value )
return super ( ModelMultipleChoiceField , self ) . prepare_value ( value )
return super ( MultiValueDict , self ) . __getitem__ ( key )
return super ( NullBooleanSelect , self ) . render ( name , value , attrs , choices )
return super ( PasswordInput , self ) . render ( name , value , attrs )
return super ( PythonSerializer , self ) . getvalue ( )
return super ( PythonSerializer , self ) . getvalue ( )
return super ( QueryDict , self ) . pop ( key , * args )
return super ( QueryDict , self ) . popitem ( )
return super ( QueryDict , self ) . setdefault ( key , default )
return super ( QueryDict , self ) . setlistdefault ( key , default_list )
return super ( SimpleTemplateResponse , self ) . __iter__ ( )
return super ( SimpleTemplateResponse , self ) . content
return super ( SlugField , self ) . clean ( value )
return super ( SortedDict , self ) . setdefault ( key , default )
return super ( TimeField , self ) . to_python ( value )
return super ( TimestampSigner , self ) . sign ( value )
return super ( type ( dt ) , dt ) . strftime ( fmt )
return super ( URLField , self ) . clean ( value )
return super ( Warning , self ) . __init__ ( WARNING , * args , ** kwargs )
return supported
return supported_code
return sys . modules [ name ]
return sys . modules [ name ]
return sys . modules [ name ] is not None
return t
return t . render ( Context ( dictionary ) )
return t . render ( context )
return t . render ( context_instance )
return t . to_language ( )
return t [ 0 ]
return t [ 0 ] . lower ( ) , t [ 1 ]
return t [ 0 ] . lower ( ) , True
return tag in self . tags_available ( )
return tempdir
return template
return template , None
return template . render ( context . new ( values ) )
return template . render ( context )
return Template ( source , origin , name )
return TEMPLATE_FRAGMENT_KEY_TEMPLATE % ( fragment_name , args . hexdigest ( ) )
return template_name
return TemplateLiteral ( self . template_parser . compile_filter ( value ) , value )
return TemplateSyntaxError ( msg )
return TemplateTagNode ( tag )
return templatetags_modules
return text
return text
return text . __html__ ( )
return tf . format ( format_string )
return the_path
return time_format ( value , 'TIME_FORMAT' , use_l10n = use_l10n )
return time_format ( value , arg )
return time_str + '-0000'
return time_str + '%+03d:%02d' % ( hour , minute )
return time_str + '%+03d%02d' % ( hour , minute )
return time_str + 'Z'
return timedelta ( 0 )
return timedelta ( seconds = - time . altzone )
return timedelta ( seconds = - time . altzone ) - timedelta ( seconds = - time . timezone )
return timedelta ( seconds = - time . timezone )
return timesince ( d , now , reversed = True )
return timesince ( value , arg )
return timesince ( value )
return TimestampSigner ( key , salt = salt ) . sign ( base64d )
return timeuntil ( value , arg )
return timezone . localize ( value , is_dst = None )
return timezone . make_aware ( value , current_timezone )
return timezone . make_naive ( value , current_timezone )
return timezone . tzname ( None )
return timezone . zone
return token
return total_forms
return tpl . format ( self . name , self . sysid , self . pubid )
return tpl . format ( self . sysid , self . pubid )
return translated
return translation
return trim_whitespace_re . sub ( ' ' , s . strip ( ) )
return True
return True
return True
return True
return True
return truncate % { 'truncated_text' : text }
return Truncator ( value ) . chars ( length , html = True )
return Truncator ( value ) . chars ( length )
return Truncator ( value ) . words ( length , html = True , truncate = ' ...' )
return Truncator ( value ) . words ( length , truncate = ' ...' )
return tt . tm_isdst > 0
return tt . tm_isdst > 0
return tuple ( a for a in WRAPPER_ASSIGNMENTS if hasattr ( fn , a ) )
return tuple ( app_template_dirs )
return tuple ( bits )
return type . __new__ ( cls , name , ( ) , d )
return type ( form . __name__ + str ( 'FormSet' ) , ( formset , ) , attrs )
return type ( form ) ( class_name , ( form , ) , form_class_attrs )
return type ( self ) . __bool__ ( self )
return type ( self ) . __bool__ ( self )
return type ( self ) . __bool__ ( self )
return type ( self ) . __bool__ ( self )
return type ( self ) . __bool__ ( self )
return type ( self ) . __next__ ( self )
return types . MethodType ( func , obj , obj . __class__ )
return ugettext ( "Please correct the duplicate data for %(field_name)s "  "which must be unique for the %(lookup)s in %(date_field)s." ) % {  'field_name' : date_check [ 2 ] ,  'date_field' : date_check [ 3 ] ,  'lookup' : six . text_type ( date_check [ 1 ] ) ,  }
return ugettext ( "Please correct the duplicate data for %(field)s, "  "which must be unique." ) % {  "field" : get_text_list ( unique_check , six . text_type ( _ ( "and" ) ) ) ,  }
return ugettext ( "Please correct the duplicate data for %(field)s." ) % {  "field" : unique_check [ 0 ] ,  }
return ugettext ( "Please correct the duplicate values below." )
return ugettext ( message )
return ugettext_lazy ( value )
return unbound
return unbound . im_func
return ungettext ( singular , plural , number )
return unicode ( s . replace ( r'\\' , r'\\\\' ) , "unicode_escape" )
return update_wrapper ( wrapper , user_function )
return upload
return url
return urljoin ( prefix , path )
return urljoin ( self . base_url , filepath_to_uri ( name ) )
return URLNode ( viewname , args , kwargs , asvar )
return urlquote ( value , ** kwargs )
return usage
return ustring_re . sub ( fix , s )
return val
return val , encoded
return val if isinstance ( val , bytes ) else val . encode ( encoding )
return valid
return ValidationError ( self . data ) . error_list
return value
return value
return value
return value
return value
return value
return value
return value . center ( int ( arg ) )
return value . date ( )
return value . ljust ( int ( arg ) )
return value . lower ( )
return value . pk
return value . replace ( '\\' , '\\\\' ) . replace ( '"' , '\\"' ) . replace ( "'" , "\\'" )
return value . replace ( " " , "\xa0" )
return value . replace ( tzinfo = None )
return value . replace ( tzinfo = timezone )
return value . rjust ( int ( arg ) )
return value . serializable_value ( self . to_field_name )
return value . strftime ( format )
return value . strftime ( format )
return value . strftime ( format )
return value . strip ( )
return value . tzinfo is None or value . tzinfo . utcoffset ( value ) is None
return value . tzinfo is not None and value . tzinfo . utcoffset ( value ) is not None
return value . upper ( )
return value [ - 1 ]
return value [ 0 ]
return value [ slice ( * bits ) ]
return value + arg
return value and value [ 0 ] . upper ( ) + value [ 1 : ]
return value if six . PY2 else value . encode ( ISO_8859_1 )
return value if six . PY2 else value . encode ( ISO_8859_1 ) . decode ( UTF_8 )
return value or arg
return Variable ( path ) . resolve ( context )
return VariableNode ( filter_expression )
return VerbatimNode ( nodelist . render ( Context ( ) ) )
return version
return version + delta
return view
return view_func
return week_number
return WEEKDAYS [ self . data . weekday ( ) ]
return WEEKDAYS_ABBR [ self . data . weekday ( ) ]
return widget . id_for_label ( id_ )
return WidthRatioNode ( parser . compile_filter ( this_value_expr ) ,  parser . compile_filter ( max_value_expr ) ,  parser . compile_filter ( max_width ) ,  asvar = asvar )
return WithNode ( None , None , nodelist , extra_context = extra_context )
return wrap ( value , int ( arg ) )
return wrapped
return wrapper
return wrapper
return WRAPPER_ASSIGNMENTS
return wraps ( func ) ( _dec )
return WSGIHandler ( )
return x
return yes
return zbuf . getvalue ( )
return ZERO
return zipfile . ZipFile . read ( self , self . namelist ( ) [ 0 ] )
retval = handler . upload_complete ( )
retval = newretval
retval = self
rev_suplx = hex(suplX)
rev_suplx = hex(suplX)[::-1]
rev_suplx = hex(suplX)[::-1]
rev_suplx = suplX[::-1]
reverse_lazy = lazy ( reverse , str )
reversed_text = ' reversed' if self . is_reversed else ''
RFC1123_DATE = re . compile ( r'^\w{3}, %s %s %s %s GMT$' % ( __D , __M , __Y , __T ) )
RFC850_DATE = re . compile ( r'^\w{6,9}, %s-%s-%s %s GMT$' % ( __D , __M , __Y2 , __T ) )
rfcdate = formatdate ( epoch_seconds )
robotparser = sys . modules [ __name__ + ".moves.urllib_robotparser" ]
role , instructions = part . split ( '=' )
role = role . upper ( )
rollback = self . _rollback
root , = nonlocal_root
root , = nonlocal_root
root [ : ] = [ root , root , None , None ]
root [ : ] = [ root , root , None , None ]
root [ KEY ] = root [ RESULT ] = None
root = [ ]
root = config . get ( 'root' , None )
root = logging . getLogger ( )
root = logging . root
root = max ( roots )
root = nonlocal_root [ 0 ]
root = nonlocal_root [ 0 ] = oldroot [ NEXT ]
rot = (y + x)%256
rot = 13
ROT = bool(sys.argv[1])
ROT = int(sys.argv[1])
ROT = int(sys.argv[1])
ROT = int(sys.argv[1])
ROT = int(sys.argv[5])
row = cursor . fetchone ( )
row_data = ( form . cleaned_data [ field ]  for field in unique_check if field in form . cleaned_data )
row_data = tuple ( d . _get_pk_val ( ) if hasattr ( d , '_get_pk_val' ) else d  for d in row_data )
rox_encoded_instruction = res1 | res2
rox_encoded_instruction = res1 | res2
rox_encoded_instruction = res2 | res3
run ( self . addr , int ( self . port ) , handler ,  ipv6 = self . use_ipv6 , threading = threading )
run_checks = registry . run_checks
RUN_RELOADER = True
run_syncdb = False
run_syncdb = True
runfastcgi ( args )
runfastcgi ( sys . argv [ 1 : ] )
rv = level
rv = logging . _levelNames [ level ]
s . close ( )
s . feed ( value )
s . serialize ( queryset , ** options )
s += '\\x%02x' % 0xAA
s = ' ' . join ( [ force_text ( arg , encoding , strings_only ,  errors ) for arg in s ] )
s = 'hello'
s = 'hello'
s = 'hello'
s = force_text ( s ) . strip ( ) . replace ( ' ' , '_' )
s = get_serializer ( format ) ( )
s = m . group ( 0 )
s = MLStripper ( )
s = s . decode ( 'utf-8' )
s = s . decode ( encoding , errors )
s = s . encode ( 'utf-8' )
s = s . replace ( '"' , '&quot;' )
s = s . replace ( '\\' , '\\\\' )
s = s . replace ( '\n' , '\\n' )
s = s . replace ( '\r' , '\\r' )
s = s . replace ( '\t' , '\\t' )
s = s . replace ( '</' , '<\\/' )
s = s . replace ( "'" , "\\'" )
s = s [ : site ] + syear + s [ site + 4 : ]
s = s [ 1 : ]
s = s [ end : ]
s = s1
s = Select ( choices = choices )
s = six . text_type ( bytes ( s ) , encoding , errors )
s = six . text_type ( s , encoding , errors )
s = six . text_type ( s )
s = six . text_type ( s )
s = StringIO ( )
s = subject [ p : i ]
s_len += 1
s_len = 0
s1 = time . strftime ( fmt , ( year , ) + timetuple [ 1 : ] )
s2 = time . strftime ( fmt , ( year + 28 , ) + timetuple [ 1 : ] )
safe = force_bytes ( safe , self . encoding )
safe = isinstance ( value , SafeData )
safe_data [ key ] = value
safe_data = { }
safe_input = isinstance ( text , SafeData )
SafeString = SafeBytes
SafeString = SafeText
SafeUnicode = SafeText
salt = force_bytes ( salt )
sample = f . read ( 4 )
save . alters_data = True
save . alters_data = True
save_m2m ( )
saved_instances . append ( self . save_existing ( form , obj , commit = commit ) )
saved_instances = [ ]
saved_locale = None
saved_locale = translation . get_language ( )
sb = int(hex(leader),16) 
sb = int(hex(leader),32) 
sb = int(hex(leader)[:-1],16) 
sb = int(hex(leader)[:-1],16) 
sb = int(hex(leader)[:-3],16) 
sb = int(hex(leader)[10:],16) 
sb = int(hex(leader)[10:],32) 
sb = int(hex(leader)[12:],16) 
sb = int(hex(leader)[13:],16) 
sb = int(hex(leader)[3:],16) 
sb = int(hex(leader)[4:],32) 
sb = int(hex(leader)[7:],16) 
sb = int(hex(val1),16) 
sc += "%02x" %(x & y)
sc1 += "%02x" %(x & 0xff)
sc2 += "%02x" %(x & z)
scheme , netloc , path , query , fragment = urlsplit ( value )
scheme = template . split ( ':' , 1 ) [ 0 ] . lower ( )
scheme = value . split ( '://' ) [ 0 ] . lower ( )
schemes = [ 'http' , 'https' , 'ftp' , 'ftps' ]
script_name = get_bytes_from_wsgi ( environ , 'SCRIPT_NAME' , '' )
script_name = get_script_name ( environ )
script_name = script_url [ : - len ( path_info ) ]
script_url = get_bytes_from_wsgi ( environ , 'REDIRECT_URL' , '' )
script_url = get_bytes_from_wsgi ( environ , 'SCRIPT_URL' , '' )
se = open ( err_log , 'a+' , buffering )
sec = int ( m . group ( 'sec' ) )
second_item = new_second_item
seconds = abs ( seconds )
seconds = self . Z ( )
seconds2 , name2 = chunks [ i + 1 ]
secret = force_bytes ( secret )
secret = settings . SECRET_KEY
security_logger . error (  force_text ( e ) ,  extra = {  'status_code' : 400 ,  'request' : request  } )
security_logger = logging . getLogger ( 'django.security.%s' %  e . __class__ . __name__ )
seek = property ( lambda self : self . file . seek )
seen . add ( k )
seen = set ( )
seen_data . add ( data )
seen_data . add ( row_data )
seen_data = set ( )
seen_models . add ( model )
seen_models = connection . introspection . installed_models ( tables )
select_html = s . render ( field % name , val , local_attrs )
selected_choices . remove ( option_value )
selected_choices = set ( force_text ( v ) for v in selected_choices )
selected_html = ''
selected_html = mark_safe ( ' selected="selected"' )
self . __args = args
self . __dict__ . update ( obj_dict )
self . __dict__ . update ( state )
self . __dict__ [ '_setupfunc' ] = func
self . __dict__ [ "_wrapped" ] = value
self . __doc__ = self . __class__ . __doc__
self . __dt = dt
self . __kw = kw
self . __language = language
self . __locale = to_locale ( language )
self . __name = "%s%02d%02d" % ( sign , abs ( offset ) / 60. , abs ( offset ) % 60 )
self . __name = name
self . __offset = offset
self . __offset = timedelta ( minutes = offset )
self . __prepare_class__ ( )
self . __starttag_text = None
self . __starttag_text = rawdata [ i : endpos ]
self . __to_language = to_language ( language )
self . _add_fallback ( )
self . _add_installed_apps_translations ( )
self . _add_local_translations ( )
self . _app_dict [ language_code ] = apps
self . _app_dict = { }
self . _archive . close ( )
self . _archive . extract ( to_path )
self . _archive . list ( )
self . _archive . list ( * args , ** kwargs )
self . _archive . printdir ( * args , ** kwargs )
self . _archive = self . _archive_cls ( file ) ( file )
self . _archive = tarfile . open ( file )
self . _archive = zipfile . ZipFile ( file )
self . _assert_mutable ( )
self . _base_set ( 'set' , key , value , timeout )
self . _body = self . read ( )
self . _boundary = boundary
self . _boundary = boundary
self . _cache . clear ( )
self . _cache . delete ( key )
self . _cache . delete_multi ( map ( l , keys ) )
self . _cache . disconnect_all ( )
self . _cache . flush_all ( )
self . _cache . set ( key , value , self . get_backend_timeout ( timeout ) )
self . _cache . set_multi ( safe_data , self . get_backend_timeout ( timeout ) )
self . _cache [ key ] = pickled
self . _cache [ key ] = value
self . _cache = _caches . setdefault ( name , { } )
self . _cached_loaders = [ ]
self . _cached_loaders = cached_loaders
self . _caches . caches [ alias ] = cache
self . _caches . caches = { }
self . _caches = local ( )
self . _callback = callback
self . _callback = get_callable ( self . _callback_str )
self . _callback = None
self . _callback_str = callback
self . _callback_str = prefix + '.' + self . _callback_str
self . _callback_strs . add ( lookup_str )
self . _callback_strs . add ( pattern . _callback_str )
self . _callback_strs . update ( pattern . _callback_strs )
self . _callback_strs = set ( )
self . _called_from_command_line = True
self . _catalog . update ( other . _catalog )
self . _catalog = translation . _catalog . copy ( )
self . _changed_data . append ( name )
self . _changed_data . append ( name )
self . _changed_data = [ ]
self . _changed_data = None
self . _charset = settings . DEFAULT_CHARSET
self . _choices = self . widget . choices = list ( value )
self . _chunk_size = min ( [ 2 ** 31 - 4 ] + possible_sizes )
self . _clean_fields ( )
self . _clean_form ( )
self . _client = self . _lib . Client ( self . _servers , pickleProtocol = pickle . HIGHEST_PROTOCOL )
self . _client = self . _lib . Client ( self . _servers )
self . _closable_objects . append ( value )
self . _closable_objects . append ( value )
self . _closable_objects = [ ]
self . _close_files ( )
self . _container . append ( self . make_bytes ( content ) )
self . _container = [ ]
self . _container = [ value ]
self . _content_length = content_length
self . _count = len ( self . object_list )
self . _count = self . object_list . count ( )
self . _createdir ( )
self . _css . setdefault ( medium , [ ] ) . append ( path )
self . _css = { }
self . _cull ( )
self . _cull ( )
self . _cull ( db , cursor , now )
self . _cull_frequency = 3
self . _cull_frequency = int ( cull_frequency )
self . _current [ field . name ] = [ m2m_value ( related )  for related in getattr ( obj , field . name ) . iterator ( ) ]
self . _current [ field . name ] = field . value_to_string ( obj )
self . _current [ field . name ] = str ( getattr ( obj , field . name ) )
self . _current [ field . name ] = value
self . _current [ field . name ] = value
self . _current = { }
self . _current = None
self . _current_app = current_app
self . _delete ( f . name )
self . _delete ( fname )
self . _delete ( fname )
self . _delete ( k )
self . _delete ( key )
self . _delete ( self . _key_to_file ( key , version ) )
self . _deleted_form_indexes . append ( i )
self . _deleted_form_indexes = [ ]
self . _dimensions_cache = get_image_dimensions ( self , close = close )
self . _dir = os . path . abspath ( dir )
self . _done = False
self . _done = True
self . _empty = False
self . _encoding = encoding or settings . DEFAULT_CHARSET
self . _encoding = settings . DEFAULT_CHARSET
self . _encoding = val
self . _encoding = value
self . _errors . append ( form . errors )
self . _errors [ field ] . extend ( error_list )
self . _errors [ field ] = self . error_class ( )
self . _errors [ field ] = self . error_class ( error_class = 'nonfield' )
self . _errors = [ ]
self . _errors = ErrorDict ( )
self . _errors = None
self . _exception_middleware . insert ( 0 , mw_instance . process_exception )
self . _exception_middleware = [ ]
self . _expire_info . clear ( )
self . _expire_info [ key ] = self . get_backend_timeout ( timeout )
self . _expire_info = _expire_info . setdefault ( name , { } )
self . _files . appendlist (  force_text ( old_field_name , self . _encoding , errors = 'replace' ) ,  file_obj )
self . _files = MultiValueDict ( )
self . _fname = None
self . _fname = os . path . join ( self . file_path , fname )
self . _fqdn = socket . getfqdn ( )
self . _func_path = '.' . join ( [ func . __class__ . __module__ , func . __class__ . __name__ ] )
self . _func_path = '.' . join ( [ func . __module__ , func . __name__ ] )
self . _handler_class = None
self . _headers [ header . lower ( ) ] = ( header , value )
self . _headers = { }
self . _info = translation . _info . copy ( )
self . _init_translation_catalog ( )
self . _initialize_handlers ( )
self . _input_data = input_data
self . _is_rendered = False
self . _is_rendered = True
self . _iterator = iter ( value )
self . _js . append ( path )
self . _js = [ ]
self . _leftover = b''
self . _leftover = b'' . join ( [ bytes , self . _leftover ] )
self . _lib = library
self . _load_post_and_files ( )
self . _load_post_and_files ( )
self . _loaders = loaders
self . _lock = _locks . setdefault ( name , RWLock ( ) )
self . _lock = threading . RLock ( )
self . _mark_post_parse_error ( )
self . _max_entries = 300
self . _max_entries = int ( max_entries )
self . _meta = META
self . _mutable = mutable
self . _name = name
self . _namespace_dict [ language_code ] = namespaces
self . _namespace_dict = { }
self . _non_form_errors = None
self . _non_form_errors = self . error_class ( )
self . _non_form_errors = self . error_class ( e . error_list )
self . _num_pages = 0
self . _num_pages = int ( ceil ( hits / float ( self . per_page ) ) )
self . _num_pages = self . _count = None
self . _object_dict = dict ( ( o . pk , o ) for o in self . get_queryset ( ) )
self . _options = params . get ( 'OPTIONS' , None )
self . _ordering . append ( ( i , form . cleaned_data [ ORDERING_FIELD_NAME ] ) )
self . _ordering . sort ( key = compare_ordering_key )
self . _ordering = [ ]
self . _out . write ( force_str ( style_func ( msg ) ) )
self . _out = out
self . _payload = payload . decode ( 'ascii' , 'surrogateescape' )
self . _pk_field = pk = self . model . _meta . pk
self . _populate ( )
self . _populate ( )
self . _populated = False
self . _populated = True
self . _post , self . _files = QueryDict ( '' , encoding = self . _encoding ) , MultiValueDict ( )
self . _post , self . _files = QueryDict ( self . body , encoding = self . _encoding ) , MultiValueDict ( )
self . _post , self . _files = self . parse_file_upload ( self . META , data )
self . _post . appendlist ( field_name ,  force_text ( data , encoding , errors = 'replace' ) )
self . _post = post
self . _post = QueryDict ( '' , mutable = True )
self . _post = QueryDict ( '' )
self . _post_clean ( )
self . _post_parse_error = False
self . _post_parse_error = False
self . _post_parse_error = True
self . _post_render_callbacks . append ( callback )
self . _post_render_callbacks = [ ]
self . _producer = [ ]
self . _producer = producer
self . _queryset = qs
self . _queryset = queryset
self . _raw_ipv6 = bool ( self . use_ipv6 )
self . _raw_ipv6 = False
self . _raw_ipv6 = True
self . _read_started = False
self . _read_started = True
self . _read_started = True
self . _regex = regex
self . _regex_dict [ language_code ] = compiled_regex
self . _regex_dict [ language_code ] = regex_compiled
self . _regex_dict = { }
self . _regex_validator = validators . RegexValidator ( regex = regex )
self . _remaining = length
self . _request = datastructures . MergeDict ( self . POST , self . GET )
self . _request = request
self . _request_middleware = None
self . _request_middleware = request_middleware
self . _request_middleware = self . _view_middleware = self . _template_response_middleware = self . _response_middleware = self . _exception_middleware = None
self . _reset_dicts ( dict_ )
self . _response_middleware . insert ( 0 , mw_instance . process_response )
self . _response_middleware = [ ]
self . _reverse_dict [ language_code ] = lookups
self . _reverse_dict = { }
self . _rollback = len ( boundary ) + 6
self . _separator = b'--' + boundary
self . _servers = server
self . _servers = server . split ( ';' )
self . _set ( key , pickled , timeout )
self . _set_regex ( regex )
self . _setup ( )
self . _size = self . _get_size_from_underlying_file ( )
self . _size = size
self . _start_relational_field ( field )
self . _start_relational_field ( field )
self . _stream . unget ( unused_char )
self . _stream = BytesIO ( self . _body )
self . _stream = LimitedStream ( self . environ [ 'wsgi.input' ] , content_length )
self . _stream = stream
self . _table = table
self . _template_response_middleware . insert ( 0 , mw_instance . process_template_response )
self . _template_response_middleware = [ ]
self . _tzname = self . tzname ( dt )
self . _unget_history = [ ]
self . _unget_history = [ num_bytes ] + self . _unget_history [ : 49 ]
self . _update_errors ( e )
self . _update_unget_history ( len ( bytes ) )
self . _upload_handlers = [ uploadhandler . load_handler ( handler , self )  for handler in settings . FILE_UPLOAD_HANDLERS ]
self . _upload_handlers = upload_handlers
self . _upload_handlers = upload_handlers
self . _urlconf_module = import_module ( self . urlconf_name )
self . _urlconf_module = self . urlconf_name
self . _validate_unique = False
self . _validate_unique = True
self . _varlist = varlist
self . _view_middleware . append ( mw_instance . process_view )
self . _view_middleware = [ ]
self . _wrapped = empty
self . _wrapped = get_storage_class ( ) ( )
self . _wrapped = self . _setupfunc ( )
self . abstract = False
self . activated = False
self . activated = True
self . active_readers -= 1
self . active_readers += 1
self . active_readers += t
self . active_readers = 0
self . active_writers -= 1
self . active_writers += 1
self . active_writers += 1
self . active_writers = 0
self . add_arguments ( parser )
self . add_error ( name , e )
self . add_error ( None , e )
self . add_error ( None , errors )
self . add_fallback ( default_translation )
self . add_fields ( form , i )
self . add_fields ( form , None )
self . add_filters ( logger , filters )
self . add_filters ( result , filters )
self . add_handlers ( logger , handlers )
self . add_item_elements ( handler , item )
self . add_item_elements ( handler , item )
self . add_library ( lib )
self . add_root_elements ( handler )
self . addr , _ipv4 , _ipv6 , _fqdn , self . port = m . groups ( )
self . addr = '::1' if self . use_ipv6 else '127.0.0.1'
self . addr = ''
self . addr = self . addr [ 1 : - 1 ]
self . address_family = socket . AF_INET6
self . allow_empty_file = kwargs . pop ( 'allow_empty_file' , False )
self . allow_empty_first_page = allow_empty_first_page
self . allow_files , self . allow_folders = allow_files , allow_folders
self . alternatives . append ( ( content , mimetype ) )
self . alternatives = alternatives or [ ]
self . app_label = 'django_cache'
self . app_label = options . get ( 'app_label' )
self . app_name = app_name
self . app_or_project = app_or_project
self . appendlist ( force_text ( key , encoding , errors = 'replace' ) ,  force_text ( value , encoding , errors = 'replace' ) )
self . appendlist ( key , value )
self . args = args
self . args_check ( filter_name , filter_func , args )
self . argv = argv or sys . argv [ : ]
self . asvar = asvar
self . attach ( filename , content , mimetype )
self . attachments . append ( ( filename , content , mimetype ) )
self . attachments . append ( filename )
self . attachments = attachments or [ ]
self . attr = new_attr
self . attr = old_attr
self . attrs , self . choices = attrs , choices
self . attrs [ 'id' ] += "_%d" % self . index
self . attrs = { }
self . attrs = attrs
self . attrs = attrs . copy ( )
self . attrs = attrs or { }
self . auto_id = auto_id
self . auto_id = auto_id
self . autocomplete ( )
self . autoescape = autoescape
self . backout . append ( self . pointer )
self . backout = [ ]
self . bad_cookies . add ( key )
self . bad_cookies = set ( )
self . base = base
self . base_fields [ INITIAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput )
self . base_fields [ MAX_NUM_FORM_COUNT ] = IntegerField ( required = False , widget = HiddenInput )
self . base_fields [ MIN_NUM_FORM_COUNT ] = IntegerField ( required = False , widget = HiddenInput )
self . base_fields [ TOTAL_FORM_COUNT ] = IntegerField ( widget = HiddenInput )
self . base_location = location
self . base_url = base_url
self . bcc = [ ]
self . bcc = list ( bcc )
self . blocks [ name ] . append ( block )
self . blocks [ name ] . insert ( 0 , block )
self . blocks = defaultdict ( list )
self . blocks = dict ( ( n . name , n ) for n in nodelist . get_nodes_by_type ( BlockNode ) )
self . body = body
self . buf_size = buf_size
self . buffer += chunk
self . buffer = b''
self . buffer = self . buffer [ size : ]
self . buffer = sio . read ( )
self . cache_choices = cache_choices
self . cache_model_class = CacheEntry
self . callback = callback
self . callback = None
self . can_read . acquire ( )
self . can_read . release ( )
self . can_read = threading . Semaphore ( 0 )
self . can_write . acquire ( )
self . can_write . release ( )
self . can_write = threading . Semaphore ( 0 )
self . cc = [ ]
self . cc = list ( cc )
self . cdata_tag = None
self . cdata_tag = None
self . cdata_tag = tag . lower ( )
self . changed_objects . append ( ( obj , form . changed_data ) )
self . changed_objects = [ ]
self . characters ( contents )
self . charset = charset
self . charset = None
self . check ( )
self . check ( app_configs = app_configs , tags = tags , display_num_errors = True )
self . check_migrations ( )
self . check_test = boolean_check if check_test is None else check_test
self . children . append ( data )
self . children . extend ( data . children )
self . children = [ obj , data ]
self . children = children [ : ] if children else [ ]
self . choice_cache = None
self . choice_label = force_text ( choice [ 1 ] )
self . choice_value = force_text ( choice [ 0 ] )
self . choices . append ( ( f , f . replace ( path , "" , 1 ) ) )
self . choices . append ( ( full_file , f ) )
self . choices = [ ( "" , "---------" ) ]
self . choices = [ ]
self . choices = choices
self . choices = choices
self . choices = list ( choices )
self . chunk_size = chunk_size
self . class_name = class_name
self . clean ( )
self . cleaned_data [ name ] = value
self . cleaned_data [ name ] = value
self . cleaned_data = { }
self . cleaned_data = cleaned_data
self . clear ( )
self . clear ( )
self . clear_cdata_mode ( )
self . close ( )
self . close ( )
self . close ( )
self . close ( )
self . close_called = False
self . close_called = True
self . cmd = cmd
self . code = code
self . coerce = kwargs . pop ( 'coerce' , lambda val : val )
self . command_stack . append ( ( command , token . source ) )
self . command_stack . pop ( )
self . command_stack = [ ]
self . common_logger_config ( logger , config , incremental )
self . common_logger_config ( root , config , incremental )
self . compile_messages ( locations )
self . compression_formats [ 'bz2' ] = ( bz2 . BZ2File , 'r' )
self . compression_formats = {  None : ( open , 'rb' ) ,  'gz' : ( gzip . GzipFile , 'rb' ) ,  'zip' : ( SingleZipReader , 'r' ) ,  }
self . conditions_nodelists = conditions_nodelists
self . config . configurator = self
self . config = ConvertingDict ( config )
self . configure_logger ( name , loggers [ name ] , True )
self . configure_logger ( name , loggers [ name ] )
self . configure_root ( root , True )
self . configure_root ( root )
self . connection . close ( )
self . connection . ehlo ( )
self . connection . login ( self . username , self . password )
self . connection . quit ( )
self . connection . sendmail ( from_email , recipients , message . as_bytes ( ) )
self . connection . starttls ( )
self . connection = connection
self . connection = connection_class ( self . host , self . port , ** connection_params )
self . connection = get_connection ( fail_silently = fail_silently )
self . connection = None
self . connection_reset = connection_reset
self . connector = conn_type
self . connector = connector or self . default
self . content = content
self . content = self . rendered_content
self . content_length = content_length
self . content_length = None
self . content_type = content_type
self . content_type = None
self . content_type_extra = content_type_extra
self . content_type_extra = None
self . context . pop ( )
self . context = context
self . context_data = context
self . cookies [ key ] [ 'domain' ] = domain
self . cookies [ key ] [ 'expires' ] = cookie_date ( time . time ( ) +  max_age )
self . cookies [ key ] [ 'expires' ] = expires
self . cookies [ key ] [ 'httponly' ] = True
self . cookies [ key ] [ 'max-age' ] = max_age
self . cookies [ key ] [ 'path' ] = path
self . cookies [ key ] [ 'secure' ] = True
self . cookies [ key ] = value
self . COOKIES = { }
self . cookies = SimpleCookie ( )
self . cookies = SimpleCookie ( self . cookies )
self . create_table ( db , cache . _table )
self . create_table ( db , tablename )
self . creation_counter = Field . creation_counter
self . current_app = current_app
self . current_token = self . next_token ( )
self . cyclevars = cyclevars
self . data = data or { }
self . data = data or { }
self . data = obj
self . day_none_value = ( 0 , empty_label [ 2 ] )
self . day_none_value = self . none_value
self . db = options . pop ( 'using' , DEFAULT_DB_ALIAS )
self . db_table = table
self . deactivate = deactivate
self . default_args = default_args or { }
self . default_kwargs = default_kwargs or { }
self . default_locale_path = None
self . default_locale_path = self . locale_paths [ 0 ]
self . default_locale_path = self . locale_paths [ 0 ]
self . default_timeout = timeout
self . default_validators = validators . ip_address_validators ( protocol , unpack_ipv4 ) [ 0 ]
self . delete ( key , version = version )
self . delete ( key , version = version )
self . deleted_objects . append ( obj )
self . deleted_objects = [ ]
self . deprecation_warning = deprecation_warning
self . dict [ item ] = None
self . dict = OrderedDict ( ( ( x , None ) for x in iterable ) if iterable else [ ] )
self . dicts . append ( other_dict )
self . dicts . append ( value )
self . dicts [ - 1 ] [ key ] = value
self . dicts = [ builtins ]
self . dicts = dicts
self . digits = digits
self . directory_permissions_mode = (  directory_permissions_mode if directory_permissions_mode is not None  else settings . FILE_UPLOAD_DIRECTORY_PERMISSIONS  )
self . dirpath = dirpath
self . domain = options . get ( 'domain' )
self . domain_whitelist = whitelist
self . dry_run = options . get ( 'dry_run' , False )
self . DSTDIFF = self . DSTOFFSET - self . STDOFFSET
self . DSTOFFSET = self . STDOFFSET
self . DSTOFFSET = timedelta ( seconds = - _time . altzone )
self . email_backend = email_backend
self . emit_post_migrate ( verbosity , interactive , database )
self . empty = options . get ( 'empty' , False )
self . empty_block_tag ( token )
self . empty_label = empty_label
self . empty_label = None
self . empty_permitted = empty_permitted
self . empty_value = kwargs . pop ( 'empty_value' , '' )
self . empty_value = kwargs . pop ( 'empty_value' , [ ] )
self . empty_variable ( token )
self . encoding = charset
self . encoding = content_params [ 'charset' ]
self . encoding = encoding
self . encoding = encoding
self . end_object ( obj )
self . end_serialization ( )
self . endChannelElement ( handler )
self . endElement ( name )
self . ending = ending
self . enter_command ( command , token )
self . environ = environ
self . error ( "bad end tag: %r" % ( rawdata [ i : j ] , ) )
self . error ( "junk characters in start tag: %r"  % ( rawdata [ k : endpos ] [ : 20 ] , ) )
self . error ( self . cmd . missing_args_message )
self . error_class = 'errorlist {}' . format ( error_class )
self . error_class = 'errorlist'
self . error_class = error_class
self . error_class = error_class
self . error_dict [ field ] = messages . error_list
self . error_dict = { }
self . error_list . extend ( message . error_list )
self . error_list = [ ]
self . error_list = [ self ]
self . error_messages = getattr ( options , 'error_messages' , None )
self . error_messages = messages
self . errors
self . event_stream . expandNode ( node )
self . event_stream = pulldom . parse ( self . stream , self . _make_parser ( ) )
self . exception = exception
self . exclude = getattr ( options , 'exclude' , None )
self . execute ( * args , ** cmd_options )
self . exit_command ( )
self . extend_nodelist ( nodelist , compiled_result , token )
self . extend_nodelist ( nodelist , TextNode ( token . contents ) , token )
self . extend_nodelist ( nodelist , var_node , token )
self . extensions = handle_extensions ( exts )
self . extra_context [ name ] = var
self . extra_context = extra_context or { }
self . extra_context = kwargs . pop ( 'extra_context' , { } )
self . extra_headers = headers or { }
self . fail_silently = fail_silently
self . fed . append ( '&#%s;' % name )
self . fed . append ( '&%s;' % name )
self . fed . append ( d )
self . fed = [ ]
self . feed . update ( kwargs )
self . feed = {  'title' : to_unicode ( title ) ,  'link' : iri_to_uri ( link ) ,  'description' : to_unicode ( description ) ,  'language' : to_unicode ( language ) ,  'author_email' : to_unicode ( author_email ) ,  'author_name' : to_unicode ( author_name ) ,  'author_link' : iri_to_uri ( author_link ) ,  'subtitle' : to_unicode ( subtitle ) ,  'categories' : categories or ( ) ,  'feed_url' : iri_to_uri ( feed_url ) ,  'feed_copyright' : to_unicode ( feed_copyright ) ,  'id' : feed_guid or link ,  'ttl' : ttl ,  }
self . fetch_command ( options . args [ 0 ] ) . print_help ( self . prog_name , options . args [ 0 ] )
self . fetch_command ( subcommand ) . run_from_argv ( self . argv )
self . field . choice_cache = [  self . choice ( obj ) for obj in self . queryset . all ( )  ]
self . field = field
self . field_name = field_name
self . field_name = field_name
self . fields = copy . deepcopy ( self . base_fields )
self . fields = fields
self . fields = getattr ( options , 'fields' , None )
self . file . __enter__ ( )
self . file . __exit__ ( exc , value , tb )
self . file . close ( )
self . file . close ( )
self . file . seek ( 0 , os . SEEK_END )
self . file . seek ( 0 )
self . file . seek ( 0 )
self . file . seek ( 0 )
self . file . seek ( pos )
self . file . size = file_size
self . file . write ( raw_data )
self . file . write ( raw_data )
self . file = BytesIO ( )
self . file = file
self . file = file_name
self . file = open ( self . name , mode or self . mode )
self . file = os . fdopen ( fd , mode , bufsize )
self . file = TemporaryUploadedFile ( self . file_name , self . content_type , 0 , self . charset , self . content_type_extra )
self . file_name = file_name
self . file_name = None
self . file_path = getattr ( settings , 'EMAIL_FILE_PATH' , None )
self . file_path = kwargs . pop ( 'file_path' )
self . file_path = os . path . abspath ( self . file_path )
self . file_permissions_mode = (  file_permissions_mode if file_permissions_mode is not None  else settings . FILE_UPLOAD_PERMISSIONS  )
self . filepath = filepath
self . files = files or { }
self . files = files or { }
self . FILES = MultiValueDict ( )
self . filter_expr , self . nodelist = filter_expr , nodelist
self . filter_expression = filter_expression
self . filters . update ( lib . filters )
self . filters [ name ] = filter_func
self . filters = { }
self . filters = filters
self . find_template_cache . clear ( )
self . find_template_cache [ key ] = result
self . find_template_cache = { }
self . first = False
self . first = left
self . first = parser . expression ( bp )
self . first = True
self . fixture_count += 1
self . fixture_count = 0
self . fixture_object_count += objects_in_fixture
self . fixture_object_count = 0
self . flags = flags
self . flo = flo
self . form = form
self . format = format if format else None
self . format_string = format_string
self . from_email = from_email or settings . DEFAULT_FROM_EMAIL
self . full_clean ( )
self . func = func
self . GET = QueryDict ( mutable = True )
self . handle_data ( rawdata [ i : j ] )
self . handle_endtag ( tag . lower ( ) )
self . handle_field ( obj , field )
self . handle_file_complete ( old_field_name , counters )
self . handle_fk_field ( obj , field )
self . handle_m2m_field ( obj , field )
self . handle_startendtag ( tag , attrs )
self . handle_starttag ( tag , attrs )
self . hashvalue = hash ( tup )
self . help_text = field . help_text or ''
self . help_text = help_text
self . help_texts = getattr ( options , 'help_texts' , None )
self . hide_empty = options . get ( 'hide_empty' , False )
self . hint = hint
self . host = host or settings . EMAIL_HOST
self . html_initial_id = form . add_initial_prefix ( self . auto_id )
self . html_initial_name = form . add_initial_prefix ( name )
self . html_name = form . add_prefix ( name )
self . id = id
self . id = Tok . num
self . ignore = options . get ( 'ignore' )
self . ignore = options . pop ( 'ignorenonexistent' , False )
self . ignore_patterns = list ( set ( ignore_patterns ) )
self . importer ( used )
self . include_html = include_html
self . indent ( 0 )
self . indent ( 1 )
self . indent ( 1 )
self . indent ( 2 )
self . index = index
self . initial = initial
self . initial = initial or { }
self . initial_extra = kwargs . pop ( 'initial' , None )
self . inner_run ( None , ** options )
self . input_formats = input_formats
self . input_type = attrs . pop ( 'type' , self . input_type )
self . instance . full_clean ( exclude = exclude , validate_unique = False )
self . instance . validate_unique ( exclude = exclude )
self . instance = construct_instance ( self , self . instance , opts . fields , construct_instance_exclude )
self . instance = instance
self . instance = opts . model ( )
self . instance = self . fk . rel . to ( )
self . interactive = options . get ( 'interactive' )
self . interactive = options . get ( 'interactive' )
self . interesting = _html_parser . interesting_cdata
self . interesting = _html_parser . interesting_normal
self . interesting = re . compile ( r'</\s*%s\s*>' % tag . lower ( ) , re . I )
self . invalid_block_tag ( token , command , parse_until )
self . inverse_match = inverse_match
self . invoked_for_django = False
self . invoked_for_django = True
self . is_bound = data is not None or files is not None
self . is_bound = data is not None or files is not None
self . is_reversed = is_reversed
self . isolated_context = kwargs . pop ( 'isolated_context' , False )
self . items . append ( item )
self . items = [ ]
self . json_kwargs . pop ( 'fields' , None )
self . json_kwargs . pop ( 'stream' , None )
self . json_kwargs [ 'separators' ] = ( ',' , ': ' )
self . json_kwargs = self . options . copy ( )
self . keep_pot = options . get ( 'keep_pot' )
self . key = key or settings . SECRET_KEY
self . key_func = get_key_func ( params . get ( 'KEY_FUNCTION' , None ) )
self . key_prefix = params . get ( 'KEY_PREFIX' , '' )
self . keyOrder . append ( key )
self . keyOrder . append ( key )
self . keyOrder . remove ( k )
self . keyOrder . remove ( key )
self . keyOrder . remove ( result [ 0 ] )
self . keyOrder = [ ]
self . keyOrder = list ( data ) if data else [ ]
self . kwargs = kwargs
self . label = pretty_name ( name )
self . label = self . field . label
self . label_suffix = label_suffix
self . label_suffix = label_suffix if label_suffix is not None else _ ( ':' )
self . labels = getattr ( options , 'labels' , None )
self . language = language
self . lasttag = tag = match . group ( 1 ) . lower ( )
self . length , self . mime_type = length , mime_type
self . length = length
self . level = level
self . LibraryValueNotFoundException = value_not_found_exception
self . limit_choices_to = limit_choices_to
self . limit_value = limit_value
self . lineno += token_string . count ( '\n' )
self . lineno = 1
self . lineno = None
self . literal = float ( var )
self . literal = int ( self . literal )
self . literal = mark_safe ( unescape_string_literal ( var ) )
self . literal = None
self . load_initial_data = options . get ( 'load_initial_data' )
self . load_label ( fixture_label )
self . load_middleware ( )
self . loaddata ( fixture_labels )
self . loaded_object_count += loaded_objects_in_fixture
self . loaded_object_count = 0
self . loader , self . loadname , self . dirs = loader , name , dirs
self . locale_dir = locale_dir
self . locale_paths . append ( os . path . abspath ( 'locale' ) )
self . locale_paths . extend ( list ( settings . LOCALE_PATHS ) )
self . locale_paths . insert ( 0 , os . path . join ( os . path . abspath ( dirpath ) , dirname ) )
self . locale_paths = [ ]
self . locale_paths = [ os . path . abspath ( os . path . join ( 'conf' , 'locale' ) ) ]
self . localize = localize
self . localized_fields = getattr ( options , 'localized_fields' , None )
self . location = abspathu ( self . base_location )
self . lookups = None
self . lookups = tuple ( var . split ( VARIABLE_ATTRIBUTE_SEPARATOR ) )
self . loopvars , self . sequence = loopvars , sequence
self . m2m_data = m2m_data
self . m2m_data = None
self . make_writeable ( new_path )
self . managed = True
self . match_re = re . compile ( self . match )
self . max_digits , self . decimal_places = max_digits , decimal_places
self . max_expr = max_expr
self . max_length , self . min_length = max_length , min_length
self . max_length = kwargs . pop ( 'max_length' , None )
self . max_value , self . min_value = max_value , min_value
self . max_width = max_width
self . merge ( translation )
self . merge = options . get ( 'merge' , False )
self . message = message
self . message_context = None
self . META [ 'PATH_INFO' ] = path_info
self . META [ 'SCRIPT_NAME' ] = script_name
self . META = { }
self . META = environ
self . method = environ [ 'REQUEST_METHOD' ] . upper ( )
self . method = None
self . mod = new
self . mod = new_mod
self . mod = old
self . mod = old_mod
self . mode = file . mode
self . model = getattr ( options , 'model' , None )
self . model_name = 'cacheentry'
self . models . add ( obj . object . __class__ )
self . models = set ( )
self . month_none_value = ( 0 , empty_label [ 1 ] )
self . month_none_value = self . none_value
self . months = months
self . msg = msg
self . msgattrib_options = self . msgattrib_options [ : ] + [ '--no-location' ]
self . msgattrib_options = self . msgattrib_options [ : ] + [ '--no-wrap' ]
self . msgmerge_options = self . msgmerge_options [ : ] + [ '--no-location' ]
self . msgmerge_options = self . msgmerge_options [ : ] + [ '--no-wrap' ]
self . msguniq_options = self . msguniq_options [ : ] + [ '--no-location' ]
self . msguniq_options = self . msguniq_options [ : ] + [ '--no-wrap' ]
self . mutex = threading . RLock ( )
self . name , self . nodelist , self . parent = name , nodelist , parent
self . name , self . value = name , value
self . name = name
self . name = name or func . __name__
self . namespace = ':' . join ( self . namespaces )
self . namespace = namespace
self . namespaces = [ ]
self . namespaces = [ x for x in namespaces if x ]
self . negate = negate
self . negated = negated
self . negated = not self . negated
self . new_method_name = new_method_name
self . new_objects . append ( self . save_new ( form , commit = commit ) )
self . new_objects = [ ]
self . next = next
self . no_obsolete = options . get ( 'no_obsolete' )
self . nodelist = compile_string ( template_string , origin )
self . nodelist = nodelist
self . nodelist = t . nodelist
self . nodelist_empty = NodeList ( )
self . nodelist_empty = nodelist_empty
self . nodelist_loop = nodelist_loop
self . nodelist_true , self . nodelist_false = nodelist_true , nodelist_false
self . none_value = ( 0 , empty_label )
self . notation_name = notation_name
self . number = number
self . obj = obj
self . obj = obj
self . object = obj
self . object_list = list ( self . object_list )
self . object_list = object_list
self . object_name = 'CacheEntry'
self . objects . append ( self . get_dump_object ( obj ) )
self . objects = [ ]
self . old_language = get_language ( )
self . old_method_name = old_method_name
self . old_timezone = getattr ( _active , 'value' , None )
self . open ( )
self . open ( )
self . options . update ( { 'use_decimal' : False } )
self . options = options
self . origin = origin
self . orphans = int ( orphans )
self . paginator = paginator
self . params = params
self . parent_instance = parent_instance
self . parent_name = parent_name
self . parent_widget = parent_widget
self . parsed = parsed
self . password = settings . EMAIL_HOST_PASSWORD if password is None else password
self . path , self . match , self . recursive = path , match , recursive
self . path = ''
self . path = '%s/%s' % ( script_name . rstrip ( '/' ) ,  path_info . replace ( '/' , '' , 1 ) )
self . path_info = ''
self . path_info = path_info
self . paths_to_remove . append ( tempdir )
self . paths_to_remove . append ( tempdir )
self . paths_to_remove = [ ]
self . per_page = int ( per_page )
self . pk_field = kwargs . pop ( "pk_field" , False )
self . plural = lambda n : int ( n != 1 )
self . pointer = 0
self . pointer = i
self . pointer = self . backout . pop ( )
self . port = DEFAULT_PORT
self . port = port or settings . EMAIL_PORT
self . pos += 1
self . pos = 0
self . position -= len ( bytes )
self . position += len ( output )
self . position = 0
self . POST = QueryDict ( mutable = True )
self . prefix = prefix
self . prefix = prefix or self . get_default_prefix ( )
self . prepend_token ( token )
self . prog_name = os . path . basename ( self . argv [ 0 ] )
self . proxy = False
self . pubid = pubid
self . queryset . filter ( ** { key : pk } )
self . queryset = field . queryset
self . queryset = queryset
self . queryset = queryset
self . reader_enters ( )
self . reader_leaves ( )
self . reason_phrase = reason
self . reason_phrase = REASON_PHRASES . get ( self . status_code ,  'UNKNOWN STATUS CODE' )
self . regex = re . compile ( self . regex , self . flags )
self . regex = regex
self . regexes [ state ] = re . compile ( "|" . join ( parts ) , re . MULTILINE | re . VERBOSE )
self . regexes = { }
self . registered_checks . append ( check )
self . registered_checks = [ ]
self . remaining -= len ( result )
self . remaining = limit
self . remove ( item )
self . remove_potfiles ( )
self . render_context = RenderContext ( )
self . render_value = render_value
self . renderer = renderer
self . replace_header ( 'Content-Type' , 'text/%s; charset="%s"' % ( subtype , charset ) )
self . request = request
self . require_all_fields = kwargs . pop ( 'require_all_fields' , True )
self . required , self . label , self . initial = required , label , initial
self . requires_system_checks = (  self . requires_system_checks if has_new_option else  self . requires_model_validation if has_old_option else  True )
self . reset ( )
self . resolver_match = None
self . run ( ** options )
self . run_shell ( shell = options [ 'interface' ] )
self . run_validators ( out )
self . run_validators ( value )
self . run_validators ( value )
self . s = s
self . salt = force_str ( salt or  '%s.%s' % ( self . __class__ . __module__ , self . __class__ . __name__ ) )
self . save_as_new = save_as_new
self . save_m2m = save_m2m
self . saved_forms . append ( form )
self . saved_forms = [ ]
self . schemes = schemes
self . second = None
self . second = parser . expression ( bp )
self . seek ( 0 )
self . seek ( 0 )
self . selected_fields = options . pop ( "fields" , None )
self . sep = force_str ( sep )
self . serialization_formats = serializers . get_public_serializer_formats ( )
self . set ( key , new_value , version = version )
self . set ( key , value , timeout , version )
self . set ( key , value , timeout = timeout , version = version )
self . set ( key , value , version = version + delta )
self . set_cdata_mode ( tag )
self . set_charset ( utf8_charset )
self . set_cookie ( key , max_age = 0 , path = path , domain = domain ,  expires = 'Thu, 01-Jan-1970 00:00:00 GMT' )
self . set_payload ( text , utf8_charset )
self . setFeature ( handler . feature_external_ges , False )
self . setFeature ( handler . feature_external_pes , False )
self . setlist ( k , v )
self . setlist ( key , default_list )
self . setlistdefault ( key ) . append ( value )
self . setlistdefault ( key ) . extend ( value_list )
self . setting , self . nodelist = setting , nodelist
self . settings_exception = exc
self . settings_exception = None
self . setup_environ ( )
self . show_hidden_initial = show_hidden_initial
self . show_traceback = options . get ( 'traceback' )
self . sign = sign
self . silent = silent
self . size = len ( content )
self . size = size
self . source = source
self . start_object ( obj )
self . start_serialization ( )
self . startElement ( name , attrs )
self . state = first
self . state = state
self . status_code = status
self . stderr . write (  "Notice: Couldn't set permission bits on %s. You're "  "probably using an uncommon filesystem setup. No "  "problem." % new_path , self . style . NOTICE )
self . stderr . write ( "    Failed to install custom SQL for %s.%s model: %s\n" % ( app_name , model . _meta . object_name , e ) )
self . stderr . write ( "    Failed to install index for %s.%s model: %s\n" % ( app_name , model . _meta . object_name , e ) )
self . stderr . write ( "App '%s' could not be found. Is it in INSTALLED_APPS?" % app_label )
self . stderr . write ( "Error: %s" % error_text )
self . stderr . write ( "The po files under %s are in a seemingly not writable location. "  "mo files will not be updated/created." % dirpath )
self . stderr . write ( msg )
self . stderr = OutputWrapper ( options . get ( 'stderr' , sys . stderr ) , self . style . ERROR )
self . stderr = OutputWrapper ( options . get ( 'stderr' , sys . stderr ) )
self . STDOFFSET = timedelta ( seconds = - _time . timezone )
self . stdout . ending = None
self . stdout . flush ( )
self . stdout . write ( '\n' . join ( sorted ( registry . tags_available ( ) ) ) )
self . stdout . write ( '\n' + self . style . SQL_KEYWORD ( connection . ops . end_transaction_sql ( ) ) )
self . stdout . write ( 'examining files with the extensions: %s\n'  % get_text_list ( list ( self . extensions ) , 'and' ) )
self . stdout . write ( 'ignoring directory %s\n' % dirname )
self . stdout . write ( 'ignoring file %s in %s\n' % ( filename , dirpath ) )
self . stdout . write ( 'processing file %s in %s\n' % ( f , dirpath ) )
self . stdout . write ( "    - %s\n" % operation . describe ( ) )
self . stdout . write ( "    Creating table %s\n" % model . _meta . db_table )
self . stdout . write ( "    Installing custom SQL for %s.%s model\n" % ( app_name , model . _meta . object_name ) )
self . stdout . write ( "    Installing index for %s.%s model\n" % ( app_name , model . _meta . object_name ) )
self . stdout . write ( "    No custom SQL for %s.%s model\n" % ( app_name , model . _meta . object_name ) )
self . stdout . write ( "    Processing %s.%s model\n" % ( app_name , model . _meta . object_name ) )
self . stdout . write ( "  %s:\n" % ( self . style . MIGRATE_LABEL ( writer . filename ) , ) )
self . stdout . write ( "  all instances of the codebase have applied the migrations you squashed," )
self . stdout . write ( "  Applying %s..." % migration , ending = "" )
self . stdout . write ( "  Creating tables...\n" )
self . stdout . write ( "  Installing custom SQL...\n" )
self . stdout . write ( "  Installing indexes...\n" )
self . stdout . write ( "  No migrations to apply." )
self . stdout . write ( "  No optimizations possible." )
self . stdout . write ( "  Optimized from %s operations to %s operations." % ( len ( operations ) , len ( new_operations ) ) )
self . stdout . write ( "  the new migration will be used for new installs. Once you are sure" )
self . stdout . write ( "  Unapplying %s..." % migration , ending = "" )
self . stdout . write ( "  you can delete them." )
self . stdout . write ( "  You should commit this migration but leave the old ones in place;" )
self . stdout . write ( " - %s" % migration . name )
self . stdout . write ( " (no migrations)" , self . style . MIGRATE_FAILURE )
self . stdout . write ( " [ ] %s" % title )
self . stdout . write ( " [X] %s" % title )
self . stdout . write ( "\nCreated new merge migration %s" % writer . path )
self . stdout . write ( "%s\n" % line )
self . stdout . write ( "%s\n" % writer . as_string ( ) )
self . stdout . write ( "Cache table '%s' already exists." % tablename )
self . stdout . write ( "Cache table '%s' created." % tablename )
self . stdout . write ( "Checking %s for fixtures..." % humanize ( fixture_dir ) )
self . stdout . write ( "Cleaning up temporary files.\n" )
self . stdout . write ( "copying plural forms: %s\n" % plural_form_line )
self . stdout . write ( "Creating %s\n" % new_path )
self . stdout . write ( "Downloading %s\n" % display_url )
self . stdout . write ( "Extracting %s\n" % filename )
self . stdout . write ( "Flush cancelled.\n" )
self . stdout . write ( "Installed %d object(s) (of %d) from %d fixture(s)" %  ( self . loaded_object_count , self . fixture_object_count , self . fixture_count ) )
self . stdout . write ( "Installed %d object(s) from %d fixture(s)" %  ( self . loaded_object_count , self . fixture_count ) )
self . stdout . write ( "Installing %s fixture '%s' from %s." %  ( ser_fmt , fixture_name , humanize ( fixture_dir ) ) )
self . stdout . write ( "Loading '%s' fixtures..." % fixture_name )
self . stdout . write ( "No changes detected in app '%s'" % app_labels . pop ( ) )
self . stdout . write ( "No changes detected in apps '%s'" % ( "', '" . join ( app_labels ) ) )
self . stdout . write ( "No changes detected" )
self . stdout . write ( "No conflicts detected to merge." )
self . stdout . write ( "No fixture '%s' in %s." %  ( fixture_name , humanize ( fixture_dir ) ) )
self . stdout . write ( "Performing system checks...\n\n" )
self . stdout . write ( "processing locale %s\n" % locale )
self . stdout . write ( "Rendering %s template files with "  "extensions: %s\n" %  ( app_or_project , ', ' . join ( extensions ) ) )
self . stdout . write ( "Rendering %s template files with "  "filenames: %s\n" %  ( app_or_project , ', ' . join ( extra_files ) ) )
self . stdout . write ( "Resetting sequences\n" )
self . stdout . write ( "UnicodeDecodeError: skipped file %s in %s" % ( f . file , f . dirpath ) )
self . stdout . write ( (  "%(started_at)s\n"  "Django version %(version)s, using settings %(settings)r\n"  "Starting development server at http://%(addr)s:%(port)s/\n"  "Quit the server with %(quit_command)s.\n"  ) % {  "started_at" : now ,  "version" : self . get_version ( ) ,  "settings" : settings . SETTINGS_MODULE ,  "addr" : '[%s]' % self . addr if self . _raw_ipv6 else self . addr ,  "port" : self . port ,  "quit_command" : quit_command ,  } )
self . stdout . write ( app_name , self . style . MIGRATE_LABEL )
self . stdout . write ( errors )
self . stdout . write ( msg )
self . stdout . write ( output )
self . stdout . write ( self . style . MIGRATE_HEADING ( "Created new squashed migration %s" % writer . path ) )
self . stdout . write ( self . style . MIGRATE_HEADING ( "Full migrations file '%s':" % writer . filename ) + "\n" )
self . stdout . write ( self . style . MIGRATE_HEADING ( "Merging %s" % app_label ) )
self . stdout . write ( self . style . MIGRATE_HEADING ( "Migrations for '%s':" % app_label ) + "\n" )
self . stdout . write ( self . style . MIGRATE_HEADING ( "Operations to perform:" ) )
self . stdout . write ( self . style . MIGRATE_HEADING ( "Optimizing..." ) )
self . stdout . write ( self . style . MIGRATE_HEADING ( "Running migrations:" ) )
self . stdout . write ( self . style . MIGRATE_HEADING ( "Synchronizing apps without migrations:" ) )
self . stdout . write ( self . style . MIGRATE_HEADING ( "Will squash the following migrations:" ) )
self . stdout . write ( self . style . MIGRATE_LABEL ( "  Apply all migrations: " ) + ( ", " . join ( set ( a for a , n in targets ) ) or "(none)" ) )
self . stdout . write ( self . style . MIGRATE_LABEL ( "  Branch %s" % migration . name ) )
self . stdout . write ( self . style . MIGRATE_LABEL ( "  Synchronize unmigrated apps: " ) + ( ", " . join ( executor . loader . unmigrated_apps ) ) )
self . stdout . write ( self . style . MIGRATE_LABEL ( "  Target specific migration: " ) + "%s, from %s" % ( targets [ 0 ] [ 1 ] , targets [ 0 ] [ 0 ] ) )
self . stdout . write ( self . style . MIGRATE_LABEL ( "  Unapply all migrations: " ) + "%s" % ( targets [ 0 ] [ 0 ] , ) )
self . stdout . write ( self . style . MIGRATE_SUCCESS ( " FAKED" ) )
self . stdout . write ( self . style . MIGRATE_SUCCESS ( " OK" ) )
self . stdout . write ( self . style . NOTICE ( "  Run 'manage.py makemigrations' to make new migrations, and then re-run 'manage.py migrate' to apply them." ) )
self . stdout . write ( self . style . NOTICE ( "  Your models have changes that are not yet reflected in a migration, and so won't be applied." ) )
self . stdout . write ( self . style . NOTICE ( "\nYou have unapplied migrations; your app may not work properly until they are applied." ) )
self . stdout . write ( self . style . NOTICE ( "Run 'python manage.py migrate' to apply them.\n" ) )
self . stdout . write ( self . style . SQL_KEYWORD ( connection . ops . start_transaction_sql ( ) ) )
self . stdout . write ( shutdown_message )
self . stdout . write ( statement )
self . stdout = OutputWrapper ( options . get ( 'stdout' , sys . stdout ) )
self . stream . close ( )
self . stream . flush ( )
self . stream . write ( '-' * 79 )
self . stream . write ( '\n' )
self . stream . write ( '%s\n' % msg_data )
self . stream . write ( " " )
self . stream . write ( "," )
self . stream . write ( "[" )
self . stream . write ( "]" )
self . stream . write ( "\n" )
self . stream . write ( "\n" )
self . stream . write ( b'-' * 79 )
self . stream . write ( b'\n' )
self . stream . write ( message . message ( ) . as_bytes ( ) + b'\n' )
self . stream = kwargs . pop ( 'stream' , sys . stdout )
self . stream = None
self . stream = open ( self . _get_filename ( ) , 'ab' )
self . stream = options . pop ( "stream" , six . StringIO ( ) )
self . stream = six . StringIO ( stream_or_string )
self . stream = stream
self . stream = stream_or_string
self . streaming_content = streaming_content
self . style = color_style ( )
self . style = color_style ( )
self . style = no_style ( )
self . style = no_style ( )
self . style_func = None
self . style_func = style_func
self . subject = subject
self . symlinks = options . get ( 'symlinks' )
self . sysid = sysid
self . tag ( function_name , compile_func )
self . tag ( function_name , compile_func )
self . tagname = self . tag ( )
self . tags . update ( lib . tags )
self . tags [ getattr ( func , "_decorated_function" , func ) . __name__ ] = func
self . tags [ name ] = compile_function
self . tags = { }
self . tagtype = tagtype
self . takes_context = takes_context
self . target , self . expression = target , expression
self . target_var = target_var
self . template = template
self . template_cache . clear ( )
self . template_cache [ key ] = ( template , None )
self . template_cache [ key ] = ( template , origin )
self . template_cache [ key ] = TemplateDoesNotExist
self . template_cache = { }
self . template_dirs = template_dirs
self . template_name = template
self . template_parser = parser
self . template_string = template_string
self . test_database = options . get ( 'test_database' , False )
self . test_runner = arg [ len ( option ) : ]
self . test_runner = None
self . text = text
self . timeout = timeout
self . timezone = get_default_timezone ( )
self . timezone = None
self . timezone = obj . tzinfo
self . timezone = timezone
self . to = [ ]
self . to = list ( to )
self . to_field = kwargs . pop ( "to_field" , None )
self . to_field_name = to_field_name
self . token = token
self . token_type , self . contents = token_type , contents
self . tokens . insert ( 0 , token )
self . tokens = mapped_tokens
self . tokens = tokens
self . toks [ groupid ] = tok
self . toks = { }
self . translate = False
self . translate = True
self . unclosed_block_tag ( [ endtag ] )
self . unclosed_block_tag ( parse_until )
self . unget ( chunk [ remaining : ] )
self . unlink ( self . name )
self . unpack_ipv4 = unpack_ipv4
self . update ( updates )
self . upload_handlers = ImmutableList (  self . upload_handlers ,  warning = "You cannot alter upload handlers after the upload has been processed."  )
self . url = iri_to_uri ( url )
self . url_name = url_name
self . urlconf_name = urlconf_name
self . use_ipv6 = options . get ( 'use_ipv6' )
self . use_ipv6 = True
self . use_l10n = use_l10n
self . use_natural_foreign_keys = options . pop ( 'use_natural_foreign_keys' , False ) or self . use_natural_keys
self . use_natural_keys = options . pop ( "use_natural_keys" , False )
self . use_natural_primary_keys = options . pop ( 'use_natural_primary_keys' , False )
self . use_ssl = settings . EMAIL_USE_SSL if use_ssl is None else use_ssl
self . use_tls = settings . EMAIL_USE_TLS if use_tls is None else use_tls
self . use_tz = use_tz
self . username = settings . EMAIL_HOST_USER if username is None else username
self . using = options . get ( 'database' )
self . val_expr = val_expr
self . validate ( display_num_errors = True )
self . validate ( out )
self . validate ( value )
self . validate_key ( key )
self . validate_key ( key )
self . validate_key ( key )
self . validate_name ( app_name , "app" )
self . validate_name ( name , app_or_project )
self . validate_name ( project_name , "project" )
self . validate_unique ( )
self . validators . append ( self . _regex_validator )
self . validators . append ( validators . MaxLengthValidator ( int ( max_length ) ) )
self . validators . append ( validators . MaxValueValidator ( max_value ) )
self . validators . append ( validators . MinLengthValidator ( int ( min_length ) ) )
self . validators . append ( validators . MinValueValidator ( min_value ) )
self . validators . remove ( self . _regex_validator )
self . validators = self . default_validators + validators
self . vals . append ( val )
self . vals = [ ]
self . value = force_text ( self . value )
self . value = set ( force_text ( v ) for v in self . value )
self . value = value
self . var = var
self . var = var_obj
self . var_name = var_name
self . var1 , self . var2 = var1 , var2
self . variable_name = variable_name
self . vars = variables
self . verbatim = 'end%s' % block_content
self . verbatim = False
self . verbose_name = 'cache entry'
self . verbose_name_plural = 'cache entries'
self . verbosity = int ( options . get ( 'verbosity' ) )
self . verbosity = int ( options . get ( 'verbosity' ) )
self . verbosity = options . get ( 'verbosity' )
self . verbosity = options . get ( 'verbosity' )
self . verbosity = options . get ( 'verbosity' )
self . verbosity = options [ 'verbosity' ]
self . version = params . get ( 'VERSION' , 1 )
self . view_name = ':' . join ( self . namespaces + [ view_path ] )
self . view_name = view_name
self . waiting_readers += 1
self . waiting_readers = 0
self . waiting_readers = 0
self . waiting_writers -= 1
self . waiting_writers += 1
self . waiting_writers = 0
self . warning = warning
self . widget . choices = self . choices
self . widget . choices = self . choices
self . widget = widget
self . widgets = [ w ( ) if isinstance ( w , type ) else w for w in widgets ]
self . widgets = getattr ( options , 'widgets' , None )
self . write ( s , encoding )
self . write_items ( handler )
self . write_message ( message )
self . write_migration_files ( changes )
self . write_po_file ( potfile , locale )
self . writer_enters ( )
self . writer_leaves ( )
self . xgettext_options = self . xgettext_options [ : ] + [ '--no-location' ]
self . xgettext_options = self . xgettext_options [ : ] + [ '--no-wrap' ]
self . xml . addQuickElement ( "None" )
self . xml . addQuickElement ( "object" , attrs = {  'pk' : smart_text ( value . _get_pk_val ( ) )  } )
self . xml . characters ( field . value_to_string ( obj ) )
self . xml . characters ( smart_text ( key_value ) )
self . xml . characters ( smart_text ( related_att ) )
self . xml . endDocument ( )
self . xml . endElement ( "django-objects" )
self . xml . endElement ( "field" )
self . xml . endElement ( "field" )
self . xml . endElement ( "natural" )
self . xml . endElement ( "natural" )
self . xml . endElement ( "object" )
self . xml . endElement ( "object" )
self . xml . ignorableWhitespace ( '\n' + ' ' * self . options . get ( 'indent' , None ) * level )
self . xml . startDocument ( )
self . xml . startElement ( "django-objects" , { "version" : "1.0" } )
self . xml . startElement ( "field" , {  "name" : field . name ,  "rel" : field . rel . __class__ . __name__ ,  "to" : smart_text ( field . rel . to . _meta ) ,  } )
self . xml . startElement ( "field" , {  "name" : field . name ,  "type" : field . get_internal_type ( )  } )
self . xml . startElement ( "natural" , { } )
self . xml . startElement ( "natural" , { } )
self . xml . startElement ( "object" , { } )
self . xml . startElement ( "object" , attrs )
self . xml = SimplerXMLGenerator ( self . stream , self . options . get ( "encoding" , settings . DEFAULT_CHARSET ) )
self . year_none_value = ( 0 , empty_label [ 0 ] )
self . year_none_value = self . none_value
self . years = range ( this_year , this_year + 10 )
self . years = years
self [ : ] = tup
self [ 'Allow' ] = ', ' . join ( permitted_methods )
self [ 'Content-Type' ] = content_type
self [ 'Location' ] = iri_to_uri ( redirect_to )
self [ k ] = v
self [ key ] = default
self [ key ] = result
self [ key ] = result
self = tuple . __new__ ( cls , * args , ** kwargs )
sent = self . _send ( message )
sentinal = bit [ 2 ] + ')'
sep = kwargs . pop ( "sep" , None )
sep = len ( hextet [ 0 ] . split ( ':' ) ) + len ( hextet [ 1 ] . split ( ':' ) )
sep = space
seqs = connection . introspection . sequence_list ( ) if reset_sequences else ( )
sequence = parser . compile_filter ( bits [ in_index + 1 ] )
sequence_sql = connection . ops . sequence_reset_sql ( no_style ( ) , self . models )
ser_fmt = None
ser_fmt = parts [ - 1 ]
ser_fmts = serializers . get_public_serializer_formats ( ) if ser_fmt is None else [ ser_fmt ]
serializers . get_serializer ( format )
serializers . serialize ( format , get_objects ( ) , indent = indent ,  use_natural_foreign_keys = use_natural_foreign_keys ,  use_natural_primary_keys = use_natural_primary_keys ,  stream = stream or self . stdout )
serializers [ format ] = module
serializers = { }
server_address = ( addr , port )
server_port = str ( self . META [ 'SERVER_PORT' ] )
set_script_prefix ( get_script_name ( environ ) )
setattr ( _MovedItems , attr . name , attr )
setattr ( _MovedItems , move . name , move )
setattr ( base , new_method_name , old_method )
setattr ( base , old_method_name , wrapper ( new_method ) )
setattr ( base , old_method_name , wrapper ( old_method ) )
setattr ( cls , k , meth )
setattr ( cls , opname , opfunc )
setattr ( filter_func , attr , value )
setattr ( filter_func . _decorated_function , attr , value )
setattr ( form . instance , self . fk . get_attname ( ) , self . instance . pk )
setattr ( Module_six_moves_urllib_error , attr . name , attr )
setattr ( Module_six_moves_urllib_parse , attr . name , attr )
setattr ( Module_six_moves_urllib_request , attr . name , attr )
setattr ( Module_six_moves_urllib_response , attr . name , attr )
setattr ( Module_six_moves_urllib_robotparser , attr . name , attr )
setattr ( obj , self . fk . get_attname ( ) , getattr ( pk_value , 'pk' , pk_value ) )
setattr ( obj , self . name , result )
setattr ( result , name , value )
setattr ( self , attr , value )
setattr ( self , real_name , getattr ( trans , real_name ) )
setattr ( self . _wrapped , name , value )
setattr ( self . object , accessor_name , object_list )
setattr ( style , role , termcolors . make_style ( ** format ) )
settings . _setup ( )
settings . BASE_DIR
settings . configure ( )
settings . configure ( USE_I18N = True )
settings . INSTALLED_APPS
settings . INSTALLED_APPS
settings . SITE_ID
settings . USE_I18N = True
settingsfile = upath ( sys . modules [ settings . __module__ ] . __file__ )
sh += '\\x' + str.encode('hex')
sh += '\\x' + str.encode('hex')
shell += '%02x, ' %c
shell = ''.join('0x{:02x},'.format(z) for z in temp).rstrip(',')
shell = bytearray.fromhex(f.read().strip().replace('\\t',''))
shell = IPShell ( argv = [ ] )
shell_rot = (x + rot)%256
shell="0x"+"0x".join(a+b for a,b in zip(shell[::2], shell[1::2]))
shell="0x"+"0x".join(a+b for a,b in zip(shell[::2], shell[1::2]))
shellcode += '\\x' + byte.encode('hex')
shellcode += '\\x' + value.encode('hex')
shellcode += '\\x' + value.encode('hex')
shellcode = ("\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68")
shellcode = ("\x31\xc0\x50\x89\xe2\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x2f\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80")
shellcode = shellcode[::-1]
shellcode = shellcode[12::]
shellcode = shellcode[12::]
shellcode = shellcode[8::]
shellcode ='\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80'
shellcode_encoded_hex = ''.join(' {:02x}'.format(x) for x in shellcode_encoded)
shellcode_encoded_hex = ''.join('--{:02x}'.format(x) for x in shellcode_encoded)
shellcode_encoded_hex = ''.join('\\x{:02x}'.format(val) for val in shellcode_encoded)
shellcode_encoded_hex = ''.join('\\x{:02x}'.format(z) for z in shellcode_encoded)
shellcode_encoded_nasm = ''.join('0x{:02x},'.format(s) for s in shellcode_encoded).rstrip(',')
shellcode_encoded_nasm = ''.join('0x{:02x},'.format(x) for x in shellcode_encoded).rstrip('?')
shellcode_encoded_nasm = ''.join('0x{:02x},'.format(x) for x in z).rstrip(',')
shellcode_encoded.append(shellcode_original[i+2] ^ r)
shellcode_encoded.append(shellcode_original[i+3] ^ r)
shellcode_original = bytearray.fromhex(f.read().strip().replace('\\n,''))
shellcode_original = bytearray.fromhex(f.read().strip().replace('\\n',''))
shellcode_original = bytearray.fromhex(f.read().strip().replace('\\t',''))
shellcode_original = bytearray.fromhex(f.read().strip().replace('\\t',''))
shellcode_original = bytearray.fromhex(f.read().strip().replace('\\x',''))
shellcode_original = bytearray.fromhex(f.read().strip().replace('\\x',''))
shellcode_original = bytearray.fromhex(f.read())
shellcode_original = bytearray.fromhex(f.read())
shellcode_original = bytearray.fromhex(f.read())
shellcode_original_hex = ''.join('\\n{:02x}'.format(x) for x in shellcode_original)
shellcode_original_hex = ''.join('\\x{:02x}'.format(x) for x in f)
shellcode_original_hex = ''.join('\\x{:02x}'.format(x) for x in shellcode_original)
shellcode.append(struct.pack('B', val3))
shellcode1.append(0x60)
shellcode2.append(0x80)
shellcode3.append(0x70)
shellcode4.append(0x50)
show_traceback = options . get ( 'traceback' )
shown . add ( plan_node )
shown = set ( )
shutdown_message = '\nServer stopped.\nNote that the test database, %r, has not been deleted. You can explore it on your own.' % db_name
shutdown_message = options . get ( 'shutdown_message' , '' )
shutil . copyfileobj ( extracted , outfile )
shutil . copymode ( old_path , new_path )
shutil . move ( the_path , guessed_path )
shutil . rmtree ( path_to_remove ,  onerror = rmtree_errorhandler )
si = open ( '/dev/null' , 'r' )
sign , digits , exponent = d . quantize ( exp , ROUND_HALF_UP ,  Context ( prec = prec ) ) . as_tuple ( )
sign , digittuple , exponent = value . as_tuple ( )
sign = '-'
sign = '-' if offset < 0 else '+'
sign = '-' if offset < 0 else '+'
sign = '-' if seconds < 0 else '+'
sign = ''
signal . signal ( signal . SIGTTOU , old_handler )
signals . got_request_exception . send ( sender = self . __class__ , request = request )
signals . got_request_exception . send ( sender = self . __class__ , request = request )
signals . got_request_exception . send ( sender = self . __class__ , request = request )
signals . request_finished . connect ( cache . close )
signals . request_finished . connect ( close_caches )
signals . request_finished . send ( sender = self . _handler_class )
signals . request_started . send ( sender = self . __class__ )
signals = 'signals'
signature = base64_hmac ( self . salt + 'signer' , value , self . key )
signed_value = force_str ( signed_value )
Signer = import_string ( settings . SIGNING_BACKEND )
silent = False
silent = True
silent_variable_failure = True
simple_email_re = re . compile ( r'^\S+@\S+\.\S+$' )
simple_url_2_re = re . compile ( r'^www\.|^(?!http)\w[^@]+\.(com|edu|gov|int|mil|net|org)($|/.*)$' , re . IGNORECASE )
simple_url_re = re . compile ( r'^https?://\[?\w' , re . IGNORECASE )
SimpleCookie = http_cookies . SimpleCookie
since = delta . days * 24 * 60 * 60 + delta . seconds
SINGLE_BRACE_END = '}'
SINGLE_BRACE_START = '{'
singular . append ( '%%(%s)s' % t . contents )
singular . append ( contents )
singular = [ ]
singular_suffix , plural_suffix = bits [ : 2 ]
sio = BytesIO ( self . buffer )
sites . append ( j )
sites . append ( site )
sites = [ ]
sites1 = _findall ( s1 , str ( year ) )
sites2 = _findall ( s2 , str ( year + 28 ) )
six . reraise ( * exc_info )
six . reraise ( * exc_info )
six . reraise ( CommandError , CommandError ( new_msg ) , sys . exc_info ( ) [ 2 ] )
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc_info ( ) [ 2 ] )
six . reraise ( DeserializationError , DeserializationError ( e ) , sys . exc_info ( ) [ 2 ] )
six . reraise ( exc_type , exc_value , sys . exc_info ( ) [ 2 ] )
six . reraise ( ImportError , ImportError ( msg ) , sys . exc_info ( ) [ 2 ] )
six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )
six . reraise ( ImproperlyConfigured , ImproperlyConfigured ( msg ) ,  sys . exc_info ( ) [ 2 ] )
six . reraise ( MultiPartParserError , MultiPartParserError ( msg ) , sys . exc_info ( ) [ 2 ] )
six . reraise ( os_err_exc_type , os_err_exc_type ( 'Error executing %s: %s' %  ( args [ 0 ] , strerror ) ) , sys . exc_info ( ) [ 2 ] )
six . reraise ( UnreadablePostError , UnreadablePostError ( * e . args ) , sys . exc_info ( ) [ 2 ] )
six . reraise ( ValidationError , ValidationError (  message ,  code = 'ambiguous_timezone' ,  params = params ,  ) , sys . exc_info ( ) [ 2 ] )
six . reraise ( ValidationError , ValidationError (  self . error_messages [ 'invalid_image' ] ,  code = 'invalid_image' ,  ) , sys . exc_info ( ) [ 2 ] )
six . reraise ( ValueError , ValueError ( "%r is not a valid date" % date ) , sys . exc_info ( ) [ 2 ] )
size = property ( _get_size , _set_size )
size = self . file . tell ( )
size = self . remaining
skipped . append ( ( model , deps ) )
skipped = [ ]
slots = [ slots ]
slots = orig_vars . get ( '__slots__' )
slug_re = re . compile ( r'^[-a-zA-Z0-9_]+$' )
slugify = allow_lazy ( slugify , six . text_type )
smart_split_re = re . compile ( r"""     ((?:         [^\s'"]*         (?:             (?:"(?:[^"\\]|\\.)*" | '(?:[^'\\]|\\.)*')             [^\s'"]*         )+     ) | \S+) """ , re . VERBOSE )
smart_str = smart_bytes
smart_str = smart_text
smart_unicode = smart_text
so = open ( out_log , 'a+' , buffering )
softspace = property ( lambda self : self . file . softspace )
sort = complain
sortable_virtual_fields = [ f for f in opts . virtual_fields  if isinstance ( f , ModelField ) ]
sorted_issues = [  ( criticals , 'CRITICALS' ) ,  ( errors , 'ERRORS' ) ,  ( warnings , 'WARNINGS' ) ,  ( infos , 'INFOS' ) ,  ( debugs , 'DEBUGS' ) ,  ]
sorted_items = sorted ( kwds . items ( ) )
source , display_name = loader ( name , dirs )
source , display_name = self . load_template_source ( template_name , template_dirs )
space = " "
space = line . find ( ' ' ) + 1
space = line [ : max_width + 1 ] . rfind ( ' ' ) + 1
space = unicode ( " " )
special_floats = [ str ( pos_inf ) , str ( neg_inf ) , str ( nan ) ]
split . append ( bit )
split = [ ]
sql , references = connection . creation . sql_create_model ( model , no_style ( ) , seen_models )
sql . extend ( connection . creation . sql_for_pending_references ( model , no_style ( ) , pending_references ) )
sql . extend ( connection . creation . sql_for_pending_references ( refto , no_style ( ) , pending_references ) )
sql_files . append ( os . path . join ( app_dir , "%s.%s.sql" % ( opts . model_name , backend_name ) ) )
sql_files . append ( os . path . join ( app_dir , "%s.sql" % opts . model_name ) )
sql_files = [ ]
sql_list = sql_flush ( self . style , connection , only_django = True ,  reset_sequences = reset_sequences ,  allow_cascade = allow_cascade )
sql_statements = executor . collect_sql ( plan )
src = force_text ( src , settings . FILE_CHARSET )
src_data = fp . read ( )
src_data = fp . read ( )
src_data = prepare_js_for_gettext ( src_data )
st = os . stat ( filename )
st = os . stat ( src )
stamp = _time . mktime ( tt )
stamp = time . mktime ( tt )
start , end = match . span ( )
start += len ( toktext )
start = 0
start = match . start ( )
start = non_capturing_groups . pop ( )
start_ipython ( argv = [ ] )
start_response ( force_str ( status ) , response_headers )
starttag_re = re . compile ( r'<%s(/?>|(\s+[^>]*>))' % tags_re , re . U )
stat = os . stat ( filename )
state [ 'cookies' ] = str ( state [ 'cookies' ] )
state = self . __dict__ . copy ( )
state = self . state
state = tok . next
state_frame [ self ] = compare_to
state_frame [ self ] = None
state_frame = self . _get_context_stack_frame ( context )
statement . append ( cleaned_line )
statement = [ ]
statements . append ( " " . join ( statement ) )
statements = [ ]
statements = connection . ops . sequence_reset_sql ( self . style , models )
statements = connection . ops . sql_flush ( style , tables , seqs , allow_cascade )
statements = sql_all ( app_config , self . style , connection )
statements = sql_create ( app_config , self . style , connection )
statements = sql_custom ( app_config , self . style , connection )
statements = sql_delete ( app_config , self . style , connection )
statements = sql_destroy_indexes ( app_config , self . style , connection )
statements = sql_indexes ( app_config , self . style , connection )
states = {   'div' : both_before + [  Tok ( "punct" , literals ( "/= /" ) , next = 'reg' ) ,  ] + both_after ,    'reg' : both_before + [  Tok ( "regex" ,  r"""                     /                       # opening slash                     # First character is..                     (   [^*\\/[]            # anything but * \ / or [                     |   \\.                 # or an escape sequence                     |   \[                  # or a class, which has                             (   [^\]\\]     #   anything but \ or ]                             |   \\.         #   or an escape sequence                             )*              #   many times                         \]                     )                     # Following characters are same, except for excluding a star                     (   [^\\/[]             # anything but \ / or [                     |   \\.                 # or an escape sequence                     |   \[                  # or a class, which has                             (   [^\]\\]     #   anything but \ or ]                             |   \\.         #   or an escape sequence                             )*              #   many times                         \]                     )*                      # many times                     /                       # closing slash                     [a-zA-Z0-9]*            # trailing flags                 """ , next = 'div' ) ,  ] + both_after ,  }
stats [ : ] = [ 0 , 0 ]
stats [ HITS ] += 1
stats [ MISSES ] += 1
stats [ MISSES ] += 1
stats = [ 0 , 0 ]
status = '%s %s' % ( response . status_code , response . reason_phrase )
status_code = 200
status_code = 301
status_code = 302
status_code = 304
status_code = 400
status_code = 403
status_code = 404
status_code = 405
status_code = 410
status_code = 500
STATUS_OK = 0
stderr . write ( '%s: %s' % ( e . __class__ . __name__ , e ) )
stderr = getattr ( self , 'stderr' , OutputWrapper ( sys . stderr , self . style . ERROR ) )
step = 'any'
step = str ( Decimal ( '1' ) / 10 ** self . decimal_places ) . lower ( )
str += '\\s'
str += '\\x'
str += "%02x," %(x & y)
str += "%02x," %(x ^ y)
str += "%02x," %(z ^ 0xff)
str += "0x"
str += hex(leader)[5:]
str = ""
str = ""
str = ""
str_hidden = '' . join ( hidden_fields )
str_number = six . text_type ( number )
str_number = str_number [ 1 : ]
str1 += '\\x'
str1 += '%02x, ' %byte
str1 += "%02x," %(x & y)
str1 += "%02x," %(x ^ y)
str1 += "0x"
str1 += "0x"
str1 = '%02x' % str
str1 = '%02x' % str
str1 = '0x'
str1 = ""
str1 = ""
str1 = str1 + str2
str1.append(struct.pack('B', byte))
str2 += '\\t'
str2 += '%02x, ' % val1
str2 += '0x'
str2 += '0x'
str2 += '0x'
str2 += hex(leader)[:4]
str2 = ''
str2 = '%02x' % str1
str2 = '%02x' % str1
str2 = '0x'
str2 = str2 + str1
str3 += '\\val1'
str3 += '%02x, ' %new
str3 += '0x'
str3 += "\\x"
str3 += "\\x"
str3 += hex(leader)[:7]
str3 = ''
str3 = '%02x' % str2
str3 = '%02x' % str2
str3 = '0x'
str3 = str3 + str2
str4 += '0x'
str4 += hex(arr)[6:]
str4 = str4 + str3
str5 += hex(tmp)[10:]
str5 = str5 + str4
stream . close ( )
stream . unget ( chunk )
stream . unget ( chunk [ - rollback : ] )
stream . unget ( chunk [ header_end + 4 : ] )
stream . unget ( chunk [ next : ] )
stream = LazyStream ( ChunkIter ( self . _input_data , self . _chunk_size ) )
stream = open ( output , 'w' ) if output else None
stream = self . _stream
stream = stream_or_string
stream = StringIO ( stream_or_string )
stream_class = BytesIO
stream_class = StringIO if isinstance ( content , six . text_type ) else BytesIO
stream_created = self . open ( )
stream_or_string = stream_or_string . decode ( 'utf-8' )
stream_or_string = stream_or_string . decode ( 'utf-8' )
stream_or_string = stream_or_string . read ( )
streaming = False
streaming = True
strerror = force_text ( e . strerror , DEFAULT_LOCALE_ENCODING ,  strings_only = True )
strfunc = Name ( "__str__" , prefix = unifunc . prefix )
string_concat = lazy ( _string_concat , six . text_type )
string_types = basestring ,
StringIO = BytesIO = StringIO . StringIO
StringIO = io . StringIO
strip_entities = allow_lazy ( strip_entities , six . text_type )
strip_prefix = lambda s : s [ 1 : ] if s . startswith ( "u'" ) else s
strip_spaces_between_tags = allow_lazy ( strip_spaces_between_tags , six . text_type )
style = color_style ( )
style = dummy ( )
style = no_style ( )
style_func = [ f for f in ( style_func , self . style_func , lambda x : x )  if f is not None ] [ 0 ]
styles . reverse ( )
styles = instructions . split ( ',' )
sub = '.dev%s' % git_changeset
sub = ''
sub = mapping [ version [ 3 ] ] + str ( version [ 4 ] )
sub_match = pattern . resolve ( new_path )
sub_match_dict . update ( sub_match . kwargs )
sub_match_dict = dict ( match . groupdict ( ) , ** self . default_kwargs )
sub_tried = e . args [ 0 ] . get ( 'tried' )
sub_ul_renderer . choice_input_class = self . choice_input_class
sub_ul_renderer = ChoiceFieldRenderer ( name = self . name ,  value = self . value ,  attrs = attrs_plus ,  choices = choice_label )
subclass = type ( "Migration" , ( Migration , ) , {  "dependencies" : [ ( app_label , migration . name ) for migration in merge_migrations ] ,  } )
subclass = type ( "Migration" , ( migrations . Migration , ) , {  "dependencies" : [ ] ,  "operations" : new_operations ,  "replaces" : replaces ,  } )
subcommand = 'help'
subcommand = self . argv [ 1 ]
subcommand_cls = self . fetch_command ( cwords [ 0 ] )
subject = '%s (%s IP): %s' % (  record . levelname ,  ( 'internal' if request . META . get ( 'REMOTE_ADDR' ) in settings . INTERNAL_IPS  else 'EXTERNAL' ) ,  record . getMessage ( )  )
subject = '%s: %s' % (  record . levelname ,  record . getMessage ( )  )
subject = self . format_subject ( subject )
subject = self . subject
sublist = _helper ( sublist_item , tabs + 1 )
sublist = ''
sublist = '\n%s<ul>\n%s\n%s</ul>\n%s' % ( indent , sublist ,  indent , indent )
sublist_item = next_item
sublist_item = None
sublist_item = title
substitutions [ 'clear_checkbox_id' ] = conditional_escape ( checkbox_id )
substitutions [ 'clear_checkbox_name' ] = conditional_escape ( checkbox_name )
substitutions [ 'clear_template' ] = self . template_with_clear % substitutions
substitutions [ 'clear' ] = CheckboxInput ( ) . render ( checkbox_name , False , attrs = { 'id' : checkbox_id } )
substitutions [ 'initial' ] = format_html ( self . url_markup_template ,  value . url ,  force_text ( value ) )
substitutions [ 'input' ] = super ( ClearableFileInput , self ) . render ( name , value , attrs )
substitutions = {  'initial_text' : self . initial_text ,  'input_text' : self . input_text ,  'clear_template' : '' ,  'clear_checkbox_label' : self . clear_checkbox_label ,  }
suffix = d [ 'suffix' ]
suffixes = ( '.' . join ( ext for ext in combo if ext )  for combo in product ( databases , ser_fmts , cmp_fmts ) )
sup_cls = super ( cls , self )
super ( _LazyModule , self ) . __init__ ( name )
super ( AssignmentNode , self ) . __init__ ( takes_context , args , kwargs )
super ( BaseInlineFormSet , self ) . __init__ ( data , files , prefix = prefix ,  queryset = qs , ** kwargs )
super ( BaseInlineFormSet , self ) . add_fields ( form , index )
super ( BaseMemcachedCache , self ) . __init__ ( params )
super ( BaseModelForm , self ) . __init__ ( data , files , auto_id , prefix , object_data ,  error_class , label_suffix , empty_permitted )
super ( BaseModelFormSet , self ) . __init__ ( ** defaults )
super ( BaseModelFormSet , self ) . add_fields ( form , index )
super ( BaseTemporalField , self ) . __init__ ( * args , ** kwargs )
super ( CharField , self ) . __init__ ( * args , ** kwargs )
super ( CheckboxChoiceInput , self ) . __init__ ( * args , ** kwargs )
super ( CheckboxInput , self ) . __init__ ( attrs )
super ( ChoiceField , self ) . __init__ ( required = required , widget = widget , label = label ,  initial = initial , help_text = help_text , * args , ** kwargs )
super ( ChoiceField , self ) . validate ( value )
super ( ComboField , self ) . __init__ ( * args , ** kwargs )
super ( ComboField , self ) . clean ( value )
super ( Command , self ) . __init__ ( )
super ( Command , self ) . add_arguments ( parser )
super ( Command , self ) . add_arguments ( parser )
super ( Command , self ) . add_arguments ( parser )
super ( Command , self ) . add_arguments ( parser )
super ( Command , self ) . add_arguments ( parser )
super ( Command , self ) . add_arguments ( parser )
super ( Command , self ) . execute ( * args , ** options )
super ( Command , self ) . handle ( 'app' , app_name , target , ** options )
super ( Command , self ) . handle ( 'project' , project_name , target , ** options )
super ( Command , self ) . handle ( ** options )
super ( Command , self ) . run_from_argv ( argv )
super ( CommandParser , self ) . __init__ ( ** kwargs )
super ( CommandParser , self ) . error ( message )
super ( ContentFile , self ) . __init__ ( stream_class ( content ) , name = name )
super ( Context , self ) . __init__ ( dict_ )
super ( ContextDict , self ) . __init__ ( * args , ** kwargs )
super ( DateTimeBaseInput , self ) . __init__ ( attrs )
super ( DebugLexer , self ) . __init__ ( template_string , origin )
super ( DebugParser , self ) . __init__ ( lexer )
super ( DebugParser , self ) . extend_nodelist ( nodelist , node , token )
super ( DecimalField , self ) . __init__ ( max_value , min_value , * args , ** kwargs )
super ( DecimalField , self ) . validate ( value )
super ( Deserializer , self ) . __init__ ( stream_or_string , ** options )
super ( DictWrapper , self ) . __init__ ( data )
super ( DTDForbidden , self ) . __init__ ( )
super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )
super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )
super ( EmailBackend , self ) . __init__ ( * args , ** kwargs )
super ( EmailBackend , self ) . __init__ ( fail_silently = fail_silently )
super ( EmailMultiAlternatives , self ) . __init__ ( subject , body , from_email , to , bcc , connection , attachments , headers , cc )
super ( EntitiesForbidden , self ) . __init__ ( )
super ( ErrorList , self ) . __init__ ( initlist )
super ( ExternalReferenceForbidden , self ) . __init__ ( )
super ( Field , self ) . __init__ ( )
super ( FileBasedCache , self ) . __init__ ( params )
super ( FileField , self ) . __init__ ( * args , ** kwargs )
super ( FilePathField , self ) . __init__ ( choices = ( ) , required = required ,  widget = widget , label = label , initial = initial , help_text = help_text ,  * args , ** kwargs )
super ( FloatField , self ) . validate ( value )
super ( GenericIPAddressField , self ) . __init__ ( * args , ** kwargs )
super ( HttpResponse , self ) . __init__ ( * args , ** kwargs )
super ( HttpResponseNotAllowed , self ) . __init__ ( * args , ** kwargs )
super ( HttpResponseNotModified , self ) . __init__ ( * args , ** kwargs )
super ( HttpResponseRedirectBase , self ) . __init__ ( * args , ** kwargs )
super ( IncludeNode , self ) . __init__ ( * args , ** kwargs )
super ( InlineForeignKeyField , self ) . __init__ ( * args , ** kwargs )
super ( InMemoryUploadedFile , self ) . __init__ ( file , name , content_type , size , charset , content_type_extra )
super ( IntegerField , self ) . __init__ ( * args , ** kwargs )
super ( IPAddressField , self ) . __init__ ( * args , ** kwargs )
super ( JsLexer , self ) . __init__ ( self . states , 'reg' )
super ( JsonResponse , self ) . __init__ ( content = data , ** kwargs )
super ( LoaderOrigin , self ) . __init__ ( display_name )
super ( LocaleRegexURLResolver , self ) . __init__ (  None , urlconf_name , default_kwargs , app_name , namespace )
super ( ManagementForm , self ) . __init__ ( * args , ** kwargs )
super ( MemcachedCache , self ) . __init__ ( server , params ,  library = memcache ,  value_not_found_exception = ValueError )
super ( MemoryFileUploadHandler , self ) . new_file ( * args , ** kwargs )
super ( ModelMultipleChoiceField , self ) . __init__ ( queryset , None ,  cache_choices , required , widget , label , initial , help_text ,  * args , ** kwargs )
super ( MovedAttribute , self ) . __init__ ( name )
super ( MovedModule , self ) . __init__ ( name )
super ( MultipleHiddenInput , self ) . __init__ ( attrs )
super ( MultiValueDict , self ) . __init__ ( key_to_list_mapping )
super ( MultiValueDict , self ) . __setitem__ ( key , [ value ] )
super ( MultiValueDict , self ) . __setitem__ ( key , list_ )
super ( MultiValueField , self ) . __init__ ( * args , ** kwargs )
super ( MultiWidget , self ) . __init__ ( attrs )
super ( NoArgsCommand , self ) . __init__ ( )
super ( NullBooleanSelect , self ) . __init__ ( attrs , choices )
super ( PasswordInput , self ) . __init__ ( attrs )
super ( PyLibMCCache , self ) . __init__ ( server , params ,  library = pylibmc ,  value_not_found_exception = pylibmc . NotFound )
super ( QueryDict , self ) . __delitem__ ( key )
super ( QueryDict , self ) . __init__ ( )
super ( QueryDict , self ) . __setitem__ ( key , value )
super ( QueryDict , self ) . appendlist ( key , value )
super ( QueryDict , self ) . clear ( )
super ( QueryDict , self ) . setlist ( key , list_ )
super ( RadioChoiceInput , self ) . __init__ ( * args , ** kwargs )
super ( RegexField , self ) . __init__ ( max_length , min_length , * args , ** kwargs )
super ( RendererMixin , self ) . __init__ ( * args , ** kwargs )
super ( Select , self ) . __init__ ( attrs )
super ( Serializer , self ) . handle_field ( obj , field )
super ( SimpleCookie , self ) . load ( rawdata )
super ( SimpleTemplateResponse , self ) . __init__ ( '' , content_type , status )
super ( SimpleUploadedFile , self ) . __init__ ( BytesIO ( content ) , None , name ,  content_type , len ( content ) , None , None )
super ( SortedDict , self ) . __delitem__ ( key )
super ( SortedDict , self ) . __init__ ( )
super ( SortedDict , self ) . __init__ ( data )
super ( SortedDict , self ) . __setitem__ ( key , value )
super ( SortedDict , self ) . clear ( )
super ( SplitDateTimeField , self ) . __init__ ( fields , * args , ** kwargs )
super ( SplitDateTimeWidget , self ) . __init__ ( widgets , attrs )
super ( SplitHiddenDateTimeWidget , self ) . __init__ ( attrs , date_format , time_format )
super ( StreamingHttpResponse , self ) . __init__ ( * args , ** kwargs )
super ( StringOrigin , self ) . __init__ ( UNKNOWN_SOURCE )
super ( TemplateIfParser , self ) . __init__ ( * args , ** kwargs )
super ( TemplateResponse , self ) . __init__ (  template , context , content_type , status )
super ( TemporaryFileUploadHandler , self ) . __init__ ( * args , ** kwargs )
super ( TemporaryFileUploadHandler , self ) . new_file ( file_name , * args , ** kwargs )
super ( TemporaryUploadedFile , self ) . __init__ ( file , name , content_type , size , charset , content_type_extra )
super ( Textarea , self ) . __init__ ( default_attrs )
super ( TextInput , self ) . __init__ ( attrs )
super ( Truncator , self ) . __init__ ( lambda : force_text ( text ) )
super ( TypedChoiceField , self ) . __init__ ( * args , ** kwargs )
super ( TypedMultipleChoiceField , self ) . __init__ ( * args , ** kwargs )
super ( TypedMultipleChoiceField , self ) . validate ( value )
super ( UploadedFile , self ) . __init__ ( file , name )
super ( URLValidator , self ) . __call__ ( url )
super ( URLValidator , self ) . __call__ ( value )
super ( URLValidator , self ) . __init__ ( ** kwargs )
super ( ValidationError , self ) . __init__ ( message , code , params )
super ( WSGIRequestHandler , self ) . __init__ ( * args , ** kwargs )
super ( WSGIServer , self ) . __init__ ( * args , ** kwargs )
super ( WSGIServer , self ) . server_bind ( )
super_set ( key , value )
supported = False
supported = True
supported_platform = plat != 'Pocket PC' and ( plat != 'win32' or  'ANSICON' in os . environ )
surname = ""
swapped=", ".join(my_list[i:i+5] for i in range(0, len(my_list), 5))
swapped="? ".join(swapped[i:i+4] for i in range(0, len(swapped), 4))
swapped=". ".join(swapped[i:i+4] for i in range(0, len(swapped), 4))
swapped="0x"+"0x".join(a+b for a,b in zip(swapped[::2], swapped[1::2]))
swapped="0x"+"0x".join(a+b for a,b in zip(swapped[::2], swapped[1::2]))
swapped=binascii.hexlify(bytearray(swapped))
syear = "%04d" % ( dt . year , )
symlink_path = os . path . join ( tmpdir , 'symlink' )
sys . exit ( 0 )
sys . exit ( 0 )
sys . exit ( 1 )
sys . exit ( 1 )
sys . exit ( 1 )
sys . exit ( 1 )
sys . exit ( 2 )
sys . exit ( 3 )
sys . exit ( bool ( failures ) )
sys . exit ( exit_code )
sys . modules [ __name__ + ".moves." + attr . name ] = attr
sys . modules [ __name__ + ".moves.urllib_error" ] = sys . modules [ __name__ + ".moves.urllib.error" ] = Module_six_moves_urllib_error ( __name__ + ".moves.urllib.error" )
sys . modules [ __name__ + ".moves.urllib_parse" ] = sys . modules [ __name__ + ".moves.urllib.parse" ] = Module_six_moves_urllib_parse ( __name__ + ".moves.urllib_parse" )
sys . modules [ __name__ + ".moves.urllib_request" ] = sys . modules [ __name__ + ".moves.urllib.request" ] = Module_six_moves_urllib_request ( __name__ + ".moves.urllib.request" )
sys . modules [ __name__ + ".moves.urllib_response" ] = sys . modules [ __name__ + ".moves.urllib.response" ] = Module_six_moves_urllib_response ( __name__ + ".moves.urllib.response" )
sys . modules [ __name__ + ".moves.urllib_robotparser" ] = sys . modules [ __name__ + ".moves.urllib.robotparser" ] = Module_six_moves_urllib_robotparser ( __name__ + ".moves.urllib.robotparser" )
sys . modules [ __name__ + ".moves.urllib" ] = Module_six_moves_urllib ( __name__ + ".moves.urllib" )
sys . path . insert ( 0 , options . pythonpath )
sys . stderr . close ( )
sys . stderr . write ( "  as a FastCGI application, you will need to get flup from\n" )
sys . stderr . write ( "  http://www.saddi.com/software/flup/   If you've already\n" )
sys . stderr . write ( "  installed flup, then make sure you have it in your PYTHONPATH.\n" )
sys . stderr . write ( "  Unable to load the flup package.  In order to run django\n" )
sys . stderr . write ( "ERROR: %s\n" % e )
sys . stderr . write ( "fork #1 failed: (%d) %s\n" % ( e . errno , e . strerror ) )
sys . stderr . write ( "fork #2 failed: (%d) %s\n" % ( e . errno , e . strerror ) )
sys . stderr . write ( "Unknown command: %r\nType '%s help' for usage.\n" %  ( subcommand , self . prog_name ) )
sys . stderr . write ( msg )
sys . stderr = NullDevice ( )
sys . stderr = open ( err_log , 'a' , buffering )
sys . stdin . close ( )
sys . stdout , sys . stderr = so , se
sys . stdout . close ( )
sys . stdout . write ( django . get_version ( ) + '\n' )
sys . stdout . write ( self . main_help_text ( ) + '\n' )
sys . stdout . write ( self . main_help_text ( ) + '\n' )
sys . stdout . write ( self . main_help_text ( commands_only = True ) + '\n' )
sys . stdout = NullDevice ( )
sys.exit()
sys.exit(1)
sys.exit(2)
T = [ F ( x ) for x in range ( 1 , l ) ]
t = file_name
t = get_template ( file_name )
t = get_template ( template_name , dirs )
t = getattr ( _active , "value" , None )
t = getattr ( _active , "value" , None )
t = re . sub ( "([a-z])'([A-Z])" , lambda m : m . group ( 0 ) . lower ( ) , value . title ( ) )
t = s . split ( '=' , 1 )
t = s . split ( '=' , 1 )
t = select_template ( file_name )
t = select_template ( template_name , dirs )
t = self . current_token
t = self . waiting_readers
t = super ( SafeBytes , self ) . __add__ ( rhs )
t = super ( SafeText , self ) . __add__ ( rhs )
t = Template ( output , name = filepath )
table = connections [ db ] . ops . quote_name ( self . _table )
table = connections [ db ] . ops . quote_name ( self . _table )
table_name_filter = options . get ( 'table_name_filter' )
table_names = [ ]
table_names = [ model . _meta . db_table for model in self . models ]
table_names = connection . introspection . table_names ( cursor )
table_output . append ( " " . join ( field_output ) )
table_output = [ ]
table2model = lambda table_name : re . sub ( r'[^a-zA-Z0-9]' , '' , table_name . title ( ) )
tables . append ( connection . introspection . table_name_converter ( model . _meta . db_table ) )
tables = connection . introspection . django_table_names ( only_existing = True )
tables = connection . introspection . table_names ( )
tables = connection . introspection . table_names ( cursor )
tag , this_value_expr , max_value_expr , max_width , as_ , asvar = bits
tag , this_value_expr , max_value_expr , max_width = bits
tag = bits [ 1 ]
tag = match . group ( 1 ) . strip ( )
tag = re_tag . match ( m . group ( 0 ) )
tag_exists = registry . tag_exists
tag_re = ( re . compile ( '(%s.*?%s|%s.*?%s|%s.*?%s)' %  ( re . escape ( BLOCK_TAG_START ) , re . escape ( BLOCK_TAG_END ) ,  re . escape ( VARIABLE_TAG_START ) , re . escape ( VARIABLE_TAG_END ) ,  re . escape ( COMMENT_TAG_START ) , re . escape ( COMMENT_TAG_END ) ) ) )
tagfind = re . compile ( '([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\s|/(?!>))*' )
taglib = bits [ - 1 ]
taglib_module = '%s.%s' % ( module , library_name )
tagname = tagname . lower ( )
tags = [ re . escape ( tag ) for tag in tags . split ( ) ]
tags = options . get ( 'tags' , None )
tags_re = '(%s)' % '|' . join ( tags )
target = parser . compile_filter ( bits [ 1 ] )
target_app_labels_only = False
target_app_labels_only = True
target_dir = path . join ( top_dir , relative_dir )
target_var = bits [ - 1 ]
targets = [ ( app_label , migration . name ) ]
targets = [ ( app_label , migration . name ) ]
targets = [ ( app_label , None ) ]
targets = [ key for key in executor . loader . graph . leaf_nodes ( ) if key [ 0 ] == app_label ]
targets = executor . loader . graph . leaf_nodes ( )
targets = set ( '.' . join ( ( fixture_name , suffix ) ) for suffix in suffixes )
TB = 1 << 40
tell = property ( lambda self : self . file . tell )
temp += '%02x ' %c
temp += '%02x, ' %c
temp += '%02x, ' %z
temp += '%02x' %c
temp = '%02x, ' %my_var
temp = '%02x, ' %z
temp = ((x & val1) >> val2)
temp = hex(int(abs(subfs)) + int(rev_suplx[0:2],16))
temp = hex(random.randint(1,255))
temp = i + magic * 250
temp = i + magic * 250
temp = i + magic / 250
temp = i + magic % 250
temp = random.randint(17,255)
temp = temp_1.count(',')
temp = val1 | val2
temp_lib . filters [ name ] = lib . filters [ name ]
temp_lib . tags [ name ] = lib . tags [ name ]
temp_lib = Library ( )
temp= int(sys.argv[6])
temp="0x"+"0x".join(a+b for a,b in zip(temp[::2], temp[1::2]))
tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_download' )
tempdir = tempfile . mkdtemp ( prefix = prefix , suffix = '_extract' )
template , display_name = loader ( name , dirs )
template , origin = find_template ( template_name , dirs )
template , origin = self . find_template ( template_name , template_dirs )
template = '%(input)s'
template = get_template ( template )
template = get_template_from_string ( source , origin , template_name )
template = get_template_from_string ( template , origin , template_name )
template = self . resolve_template ( self . template_name )
template = self . template . resolve ( context )
template = self . template_with_initial
template = Template ( content )
template = template [ 7 : ]
template_dir = os . path . join ( app_config . path , 'templates' )
template_dir = self . handle_template ( options [ 'template' ] ,  base_subdir )
template_dir = template_dir . decode ( fs_encoding )
template_dirs = app_template_dirs
template_dirs = settings . TEMPLATE_DIRS
TEMPLATE_FRAGMENT_KEY_TEMPLATE = 'template.cache.%s.%s'
template_source_loaders = None
template_source_loaders = tuple ( loaders )
template_string = force_text ( template_string )
template_tuple = self . template_cache . get ( key )
template_with_clear = '%(clear)s <label for="%(clear_checkbox_id)s">%(clear_checkbox_label)s</label>'
template_with_initial = '%(initial_text)s: %(initial)s %(clear_template)s<br />%(input_text)s: %(input)s'
TemplateLoader = import_string ( loader )
templatetags_modules = _templatetags_modules
templatetags_modules = [ ]
templatetags_modules = get_templatetags_modules ( )
templatetags_modules_candidates += [ '%s.templatetags' % app_config . name  for app_config in apps . get_app_configs ( ) ]
templatetags_modules_candidates = [ 'django.templatetags' ]
terminal_char = ')'
terminal_char = '>'
termios . tcsetattr ( fd , termios . TCSANOW , attr_list )
termios = None
test_runner = TestRunner ( ** options )
test_runner_class . add_arguments ( parser )
test_runner_class = get_runner ( settings , self . test_runner )
TestRunner = get_runner ( settings , options . get ( 'testrunner' ) )
text = '%s\x1b[%sm' % ( text or '' , RESET )
text = force_text ( text )
text = match . group ( 1 )
text = text [ 1 : ]
text = unicodedata . normalize ( 'NFC' , self . _wrapped )
text_args = [ force_text ( v ) for v in args ]
text_kwargs = dict ( ( k , force_text ( v ) ) for ( k , v ) in kwargs . items ( ) )
text_type = str
text_type = unicode
text_value = force_text ( value )
tf = TimeFormat ( value )
the_path , info = urlretrieve ( url , path . join ( tempdir , filename ) )
thefile = '%s.c' % self . file
thefile = '%s.py' % self . file
thefile = self . file
this_year = datetime . date . today ( ) . year
thousand_sep = get_format ( 'THOUSAND_SEPARATOR' )
thread . start_new_thread ( main_func , args , kwargs )
thread . start_new_thread ( main_func , args )
threading = options . get ( 'use_threading' )
time . sleep ( 1 )
time . sleep ( 1 )
time_re = re . compile (  r'(?P<hour>\d{1,2}):(?P<minute>\d{1,2})'  r'(?::(?P<second>\d{1,2})(?:\.(?P<microsecond>\d{1,6})\d{0,6})?)?'  )
time_str = date . strftime ( '%s, %%d %s %%Y %%H:%%M:%%S ' % ( dow , month ) )
time_str = date . strftime ( '%Y-%m-%dT%H:%M:%S' )
time_str = time_str . decode ( 'utf-8' )
timeout += int ( time . time ( ) )
timeout = - 1
timeout = 300
timeout = int ( timeout )
timeout = params . get ( 'timeout' , params . get ( 'TIMEOUT' , 300 ) )
timeout = self . default_timeout
timeout = self . get_backend_timeout ( timeout )
timestamp = baseconv . base62 . decode ( timestamp )
timestamp = datetime . datetime . now ( ) . strftime ( "%Y%m%d-%H%M%S" )
timestamp = datetime . datetime . utcfromtimestamp ( int ( timestamp ) )
timestamp = git_log . communicate ( ) [ 0 ]
timetuple = dt . timetuple ( )
timeval = time . time ( )
timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )
timezone = ( offset . days * 24 * 60 ) + ( offset . seconds // 60 )
timezone = get_current_timezone ( )
title += " (%s squashed migrations)" % len ( graph . nodes [ plan_node ] . replaces )
title = ''
title = list_ [ i ]
title = plan_node [ 1 ]
tmp = ""
tmp = ""
tmp = ""
tmp = url . rstrip ( '/' )
tmpdir = tempfile . mkdtemp ( )
to_delete . add ( model )
to_delete = set ( )
to_py = super ( ModelMultipleChoiceField , self ) . to_python
to_python = self . _get_to_python ( pk_field )
to_unicode = lambda s : force_text ( s , strings_only = True )
to_unicode = lambda s : force_text ( s , strings_only = True )
Tok . num += 1
tok = '"' + guts + '"'
tok = '"REGEX"'
tok = tok . replace ( "\\" , "U" )
tok = toks [ name ]
token . lineno = self . lineno
token . source = self . origin , source
token = "not in"
token = get_token ( request )
token = parser . next_token ( )
token = self . next_token ( )
token = super ( DebugLexer , self ) . create_token ( token_string , in_tag )
token = Token ( TOKEN_BLOCK , block_content )
token = Token ( TOKEN_COMMENT , content )
token = Token ( TOKEN_TEXT , token_string )
token = Token ( TOKEN_VAR , token_string [ 2 : - 2 ] . strip ( ) )
token = tokens [ i ]
TOKEN_BLOCK = 2
TOKEN_COMMENT = 3
TOKEN_MAPPING = {  TOKEN_TEXT : 'Text' ,  TOKEN_VAR : 'Var' ,  TOKEN_BLOCK : 'Block' ,  TOKEN_COMMENT : 'Comment' ,  }
token_name = TOKEN_MAPPING [ self . token_type ]
TOKEN_TEXT = 0
TOKEN_VAR = 1
toks = self . toks
toktext = match . group ( name )
top = bottom + self . per_page
top = self . count
top_dir = os . path . abspath ( path . expanduser ( target ) )
top_dir = path . join ( os . getcwd ( ) , name )
top_errors . extend (  [ _ ( '(Hidden field %(name)s) %(error)s' ) % { 'name' : name , 'error' : force_text ( e ) }  for e in bf_errors ] )
TOTAL_FORM_COUNT = 'TOTAL_FORMS'
total_forms = initial_forms
total_forms = max ( initial_forms , self . min_num ) + self . extra
total_forms = self . max_num
touch_import ( 'django.utils.encoding' , 'python_2_unicode_compatible' , decorated )
tpl = "DTDForbidden(name='{}', system_id={!r}, public_id={!r})"
tpl = "EntitiesForbidden(name='{}', system_id={!r}, public_id={!r})"
tpl = "ExternalReferenceForbidden(system_id='{}', public_id={})"
traceback . print_exc ( )
trail = closing + trail
trail = punctuation + trail
trailing_empty_content_re = re . compile ( r'(?:<p>(?:&nbsp;|\s|<br \/>)*?</p>\s*)+\Z' )
TRAILING_PUNCTUATION = [ '.' , ',' , ':' , ';' , '.)' , '"' , '\'' ]
trans_bit . append ( bit )
trans_bit = [ bit ]
trans_real . _active = threading . local ( )
trans_real . _default = None
trans_real . _translations = { }
transfer_encoding = meta_data . get ( 'content-transfer-encoding' )
transfer_encoding = transfer_encoding [ 0 ] . strip ( )
translated = func ( ** kwargs )
translated = translated % rhs
translation . _catalog = { }
translation . _info = { }
translation . activate ( 'en-us' )
translation . activate ( saved_locale )
translation . activate ( settings . LANGUAGE_CODE )
translation . activate ( settings . LANGUAGE_CODE )
translation = gettext_module . translation (  domain = 'django' ,  localedir = localedir ,  languages = [ self . __locale ] ,  codeset = 'utf-8' ,  fallback = use_null_fallback )
translation = self . _new_gnu_trans ( localedir , use_null_fallback )
translation = self . _new_gnu_trans ( localedir )
translation = self . _new_gnu_trans ( localedir )
TRANSLATOR_COMMENT_MARK = 'Translators'
translators_comment_start = lineno
translators_comment_start = None
tried . append ( [ pattern ] )
tried . append ( [ pattern ] )
tried . append ( filepath )
tried . extend ( [ pattern ] + t for t in sub_tried )
tried = [ ]
tried_modules . append ( taglib_module )
tried_modules = [ ]
trim_whitespace_re = re . compile ( '\s*\n\s*' )
trimmed = 'trimmed' in t . split_contents ( )
trimmed = False
trimmed = trim_url ( middle )
truncate = force_text ( truncate )
truncate = pgettext (  'String to return when truncating text' ,  '%(truncated_text)s...' )
truncate = property ( lambda self : self . file . truncate )
truncate_len -= 1
truncate_len = length
truncate_text = self . add_truncation_text ( '' , truncate )
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
try :
tt = _time . localtime ( stamp )
tt = ( 2037 , ) + tt [ 1 : ]
tt = ( dt . year , dt . month , dt . day ,  dt . hour , dt . minute , dt . second ,  dt . weekday ( ) , 0 , 0 )
tt = ( dt . year , dt . month , dt . day ,  dt . hour , dt . minute , dt . second ,  dt . weekday ( ) , 0 , 0 )
tt = time . localtime ( stamp )
ttl = force_text ( ttl )
tupl = d . as_tuple ( )
TYPE = FIELD
TYPE = FILE
TYPE = RAW
tz_name = force_text ( get_current_timezone_name ( ) , errors = 'ignore' )
tzinfo . __init__ ( self )
tzinfo . __init__ ( self )
tzinfo = get_fixed_timezone ( offset )
tzinfo = kw . pop ( 'tzinfo' )
tzinfo = timezone . get_current_timezone ( ) if settings . USE_TZ else None
tzinfo = utc
u = dig2 . digest ( )
u = salt + struct . pack ( b'>I' , i )
uclass , lookup , field , unique_for = date_check
ugettext = gettext
ugettext_lazy = lazy ( ugettext , six . text_type )
ugettext_noop = gettext_noop
ULONG_PTR = c_int64
ULONG_PTR = c_ulong
unencoded_ampersands_re = re . compile ( r'&(?!(\w+|#\d+);)' )
unescape_entities = allow_lazy ( unescape_entities , six . text_type )
unescape_string_literal = allow_lazy ( unescape_string_literal )
ungettext = ngettext
unhandled_params . pop ( 0 )
unhandled_params . remove ( param )
unhandled_params = list ( params )
unhandled_params = unhandled_params [ : - len ( defaults ) ]
unichr = chr
unichr = unichr
unicode_value = force_text ( value , strings_only = True )
UnicodeDecodeError . __init__ ( self , * args )
unifunc . replace ( strfunc )
unifunc = results [ "unifunc" ]
unique = "UNIQUE " if f . unique else ""
unique_check = [ field for field in unique_check if field != self . fk . name ]
unique_checks , date_checks = form . instance . _get_unique_checks ( exclude = exclude )
unique_id = get_tag_uri ( item [ 'link' ] , item [ 'pubdate' ] )
unique_id = item [ 'unique_id' ]
units = len ( tupl [ 1 ] ) - tupl [ 2 ]
UNKNOWN_SOURCE = '<unknown source>'
unlink = os . unlink
UnlockFileEx . argtypes = [ HANDLE , DWORD , DWORD , DWORD , LPOVERLAPPED ]
UnlockFileEx . restype = BOOL
UnlockFileEx = windll . kernel32 . UnlockFileEx
unpack = num_loopvars > 1
unpacked_vars = dict ( zip ( self . loopvars , item ) )
unused_char = self . _stream . read ( 1 )
update_watch ( )
update_wrapper ( _dec , decorator , assigned = available_attrs ( decorator ) )
update_wrapper ( _wrapper , dummy )
update_wrapper ( _wrapper , func )
updates . update ( processor ( request ) )
updates = dict ( )
upload = super ( ClearableFileInput , self ) . value_from_datadict ( data , files , name )
upto = 0
upto = end
upto = match . end ( )
upto = start
url , trimmed = escape ( url ) , escape ( trimmed )
url = ''
url = 'mailto:%s@%s' % ( local , domain )
url = hashlib . md5 ( force_bytes ( iri_to_uri ( request . build_absolute_uri ( ) ) ) )
url = hashlib . md5 ( force_bytes ( iri_to_uri ( request . build_absolute_uri ( ) ) ) )
url = None
url = property ( lambda self : self [ 'Location' ] )
url = quote ( url , safe = b'!*\'();:@&=+$,/?#[]~' )
url = reverse ( project_name + '.' + view_name ,  args = args , kwargs = kwargs ,  current_app = context . current_app )
url = reverse ( view_name , args = args , kwargs = kwargs , current_app = context . current_app )
url = smart_urlquote ( 'http://%s' % middle )
url = smart_urlquote ( middle )
url = unquote ( force_str ( url ) )
url = url . replace ( '\\' , '/' )
url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
url = urlunsplit ( ( scheme , netloc , path , query , fragment ) )
url = value
url_fields [ 0 ] = 'http'
url_fields [ 1 ] = url_fields [ 2 ]
url_fields [ 2 ] = ''
url_fields = split_url ( urlunsplit ( url_fields ) )
url_fields = split_url ( value )
url_info = urlparse ( url )
url_markup_template = '<a href="{0}">{1}</a>'
url_schemes = [ 'http' , 'https' , 'ftp' ]
urlconf = get_urlconf ( )
urlconf = request . urlconf
urlconf = settings . ROOT_URLCONF
urlconf_repr = '<%s list>' % self . urlconf_name [ 0 ] . __class__ . __name__
urlconf_repr = repr ( self . urlconf_name )
urlize = allow_lazy ( urlize , six . text_type )
urlquote = allow_lazy ( urlquote , six . text_type )
urlquote_plus = allow_lazy ( urlquote_plus , six . text_type )
urlresolvers . set_urlconf ( urlconf )
urlresolvers . set_urlconf ( urlconf )
urlunquote = allow_lazy ( urlunquote , six . text_type )
urlunquote_plus = allow_lazy ( urlunquote_plus , six . text_type )
usage . append ( "    %s" % name )
usage . append ( "" )
usage . append ( style . NOTICE (  "Note that only Django core commands are listed "  "as settings are not properly configured (error: %s)."  % self . settings_exception ) )
usage . append ( style . NOTICE ( "[%s]" % app ) )
usage = '%%prog %s [options] %s' % ( subcommand , self . args )
usage = [  "" ,  "Type '%s help <subcommand>' for help on a specific subcommand." % self . prog_name ,  "" ,  "Available subcommands:" ,  ]
usage = sorted ( get_commands ( ) . keys ( ) )
use_base_manager = options . get ( 'use_base_manager' )
use_func = False
use_func = True
use_grouping = settings . USE_L10N and settings . USE_THOUSAND_SEPARATOR
use_grouping = use_grouping and grouping > 0
use_grouping = use_grouping or force_grouping
USE_INOTIFY = False
USE_INOTIFY = True
use_natural_foreign_keys = options . get ( 'use_natural_foreign_keys' ) or use_natural_keys
use_natural_keys = options . get ( 'use_natural_keys' )
use_natural_primary_keys = options . get ( 'use_natural_primary_keys' )
use_null_fallback = False
use_null_fallback = True
use_reloader = options . get ( 'use_reloader' )
use_threading = connection . features . test_db_allows_multiple_connections
use_workaround = (  ( current_version < ( 2 , 7 , 3 ) ) or  ( current_version >= ( 3 , 0 ) and current_version < ( 3 , 2 , 3 ) )  )
used += '.' + frag
used = name . pop ( 0 )
used_column_names . append ( att_name )
used_column_names = [ ]
used_name = the_path . split ( '/' ) [ - 1 ]
user_part , domain_part = value . rsplit ( '@' , 1 )
user_regex = re . compile (  r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*$"  r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"$)' ,  re . IGNORECASE )
user_settings = module_to_dict ( settings . _wrapped )
UserModel = get_user_model ( )
using = options . get ( 'database' )
using_sysrandom = False
using_sysrandom = True
ustring_re = re . compile ( "([\u0080-\uffff])" )
utc = pytz . utc if pytz else UTC ( )
utcdate = time . strftime ( '%Y%m%d%H%M%S' , time . gmtime ( timeval ) )
utf8_charset . body_encoding = None
utf8_charset = Charset . Charset ( 'utf-8' )
utility . execute ( )
utility = ManagementUtility ( argv )
v . __cause__ , v . __traceback__ = e , tb
v ( value )
v = datetime . datetime . strptime ( force_str ( value ) , input_format )
v = ValueError ( 'Cannot resolve %r: %s' % ( s , e ) )
val , encoded = super ( SimpleCookie , self ) . value_encode ( val )
val . append ( iso_input )
val . encode ( 'ascii' )
val += '%02x' %(7 -(256 - x))
val += '%02x'%(x+7)
val = ', ' . join ( sanitize_address ( addr , encoding )  for addr in getaddresses ( ( val , ) ) )
val = '%02x, ' %temp
val = force_text ( val )
val = getattr ( module , format_type )
val = Header ( val , encoding ) . encode ( )
val = Header ( val ) . encode ( )
val = int(byte.encode('hex'), 32) ^ i
val = list ( val )
val = None
val = self . _cache . decr ( key , delta )
val = self . _cache . get ( key )
val = self . _cache . incr ( key , delta )
val = self . get ( k , version = version )
val = self [ key ]
val1 = 2**max_bits * 3
val1 = 2**max_bits / 3
val1 = 2**max_bits-1
val1 = 2**max_bits-1
val1 = hex(val2)[::-1]
val1 = int(byte.encode('hex'), 32)
val1 = int(byte.encode('hex'), 32) & temp
val1 = int(byte.encode('hex'), 32) ^ i
val1 = int(byte.encode('hex'), 32) | i
val1 = parser . compile_filter ( bits [ 1 ] )
val2 = int(chunk[i].encode('hex'), 16) ^ xor_byte
val2 = int(chunk[i].encode('hex'), 32)
val2 = int(chunk[i].encode('hex'), 32) & xor_byte
val2 = int(chunk[i].encode('hex'), 32) ^ xor_byte
val2 = int(chunk[i].encode('hex'), 32) ^ xor_byte
val2 = int(chunk[i].encode('hex'), 32) ^ xor_byte
val2 = int(chunk[i].encode('hex'), 32) | xor_byte
val2 = mask(tmp2)
val2 = self . var2 . resolve ( context , True )
val3 = create(tmp3)
valid = False
valid = True
valid_forms = [ form for form in self . forms if form . is_valid ( ) and form not in forms_to_delete ]
validate_comma_separated_integer_list = RegexValidator ( comma_separated_int_list_re , _ ( 'Enter only digits separated by commas.' ) , 'invalid' )
validate_email = EmailValidator ( )
validate_ipv4_address ( hextet )
validate_ipv4_address ( value )
validate_ipv4_address = RegexValidator ( ipv4_re , _ ( 'Enter a valid IPv4 address.' ) , 'invalid' )
validate_ipv46_address ( ip_address )
validate_ipv6_address ( value )
validate_slug = RegexValidator ( slug_re , _ ( "Enter a valid 'slug' consisting of letters, numbers, underscores or hyphens." ) , 'invalid' )
value , converted = convert_old_style_list ( value )
value , decimals = value . split ( decimal_separator , 1 )
value , sig = signed_value . rsplit ( self . sep , 1 )
value , timestamp = result . rsplit ( self . sep , 1 )
value . configurator = self
value . decode ( charset )
value . encode ( charset )
value = '-' + value
value = '.' . join ( reversed ( parts ) )
value = ''
value = '%s %s' % tuple ( value )
value = '1'
value = [ ]
value = [ conditional_escape ( v ) for v in value ]
value = { True : '2' , False : '3' , '2' : '2' , '3' : '3' } [ value ]
value = b'' . join ( self . make_bytes ( chunk ) for chunk in value )
value = bool ( value )
value = bytes_to_text ( value , self . encoding )
value = bytes_to_text ( value , self . encoding )
value = connections [ db ] . ops . process_clob ( row [ 1 ] )
value = converter ( suffix )
value = ConvertingDict ( value )
value = ConvertingList ( value )
value = ConvertingTuple ( value )
value = data . get ( name , None )
value = data . get ( name )
value = datetime_safe . new_date ( value )
value = datetime_safe . new_datetime ( value )
value = Decimal ( value )
value = dict . __getitem__ ( self , key )
value = dict . get ( self , key , default )
value = dict . pop ( self , key , default )
value = environ . get ( str ( key ) , str ( default ) )
value = escape ( value )
value = False
value = field . _get_val_from_obj ( obj )
value = field . clean ( value , initial )
value = field . clean ( value )
value = field . rel . to . _meta . get_field ( field . rel . field_name ) . to_python ( field_value )
value = field . to_python ( getInnerText ( field_node ) . strip ( ) )
value = field . widget . value_from_datadict ( self . data , self . files , self . add_prefix ( name ) )
value = flags [ attr ]
value = float ( value )
value = force_str ( value )
value = force_str ( value )
value = force_text ( value )
value = formats . sanitize_separators ( value )
value = getattr ( _module , attr )
value = getattr ( obj , field . get_attname ( ) )
value = getattr ( obj , field . rel . field_name )
value = getattr ( opts , opt )
value = getattr ( self , 'clean_%s' % name ) ( )
value = int ( s , 36 )
value = int ( str ( value ) )
value = int ( value )
value = list . __getitem__ ( self , key )
value = list . pop ( self , idx )
value = localize ( value , use_l10n = context . use_l10n )
value = map ( force_text , value )
value = new_value
value = next ( cycle_iter ) . resolve ( context )
value = None
value = normalize_newlines ( value )
value = p [ i + 1 : ] . strip ( )
value = re . sub ( '[^\w\s-]' , '' , value ) . strip ( ) . lower ( )
value = related . natural_key ( )
value = request . META . get ( header , None )
value = self . _convert_to_charset ( value , 'latin-1' , mime_encode = True )
value = self . _empty_value
value = self . _resolve_lookup ( context )
value = self . coerce ( value )
value = self . decompress ( value )
value = self . get ( key , version = version )
value = self . get ( key , version = version )
value = self . get ( key , version = version )
value = self . literal
value = self . make_bytes ( value )
value = self . queryset . get ( ** { key : value } )
value = self . to_python ( value )
value = self . to_python ( value ) . strip ( )
value = self . to_python ( value ) . strip ( )
value = self . to_python ( value ) . strip ( )
value = self . val_expr . resolve ( context )
value = signing . get_cookie_signer ( salt = key + salt ) . sign ( value )
value = signing . get_cookie_signer ( salt = key + salt ) . unsign (  cookie_value , max_age = max_age )
value = smart_text ( value ) . strip ( )
value = str ( '%s%s%s' ) % ( value , self . sep , self . timestamp ( ) )
value = str ( Header ( value , 'utf-8' , maxlinelen = sys . maxsize ) . encode ( ) )
value = str ( value )
value = super ( DictWrapper , self ) . __getitem__ ( key )
value = super ( IntegerField , self ) . to_python ( value )
value = super ( TypedChoiceField , self ) . clean ( value )
value = super ( TypedMultipleChoiceField , self ) . clean ( value )
value = super ( URLField , self ) . to_python ( value )
value = template_localtime ( value , use_tz = context . use_tz )
value = timezone . normalize ( value )
value = to_current_timezone ( value )
value = to_current_timezone ( value )
value = token_kwargs ( remaining_bits , parser , support_legacy = False )
value = True
value = tuple . __getitem__ ( self , key )
value = tuple ( value )
value = ugettext ( "%s GB" ) % filesize_number_format ( bytes / GB )
value = ugettext ( "%s KB" ) % filesize_number_format ( bytes / KB )
value = ugettext ( "%s MB" ) % filesize_number_format ( bytes / MB )
value = ugettext ( "%s PB" ) % filesize_number_format ( bytes / PB )
value = ugettext ( "%s TB" ) % filesize_number_format ( bytes / TB )
value = ungettext ( "%(size)d byte" , "%(size)d bytes" , 0 ) % { 'size' : 0 }
value = ungettext ( "%(size)d byte" , "%(size)d bytes" , bytes ) % { 'size' : bytes }
value = unicode_value . strip ( )
value = unicodedata . normalize ( 'NFKD' , value ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' )
value = urlunsplit ( url_fields )
value = value . astimezone ( timezone )
value = value . decode ( charset )
value = value . encode ( charset )
value = value . pk
value = value . replace ( arg , '' )
value = value . replace ( b'\\\\' , b'\\' ) . replace ( b'\\"' , b'"' )
value = value . replace ( replacement , '' )
value = value . strip ( )
value = value [ 1 : - 1 ]
value = values . get ( value . lower ( ) , value )
value = var . resolve ( context , True )
value_converters = {  'ext' : 'ext_convert' ,  'cfg' : 'cfg_convert' ,  }
values = _itervalues
values = '' . join ( quant ) . split ( ',' )
values = [ ]
values = [ ]
values = [ parser . compile_filter ( arg ) for arg in args [ 1 : - 2 ] ]
values = [ parser . compile_filter ( arg ) for arg in args [ 1 : ] ]
values = [ parser . compile_filter ( bit ) for bit in bits [ 1 : ] ]
values = {  name : var . resolve ( context )  for name , var in six . iteritems ( self . extra_context )  }
values = { 'true' : True , 'false' : False }
values = dict ( ( key , val . resolve ( context ) ) for key , val in  six . iteritems ( self . extra_context ) )
values = list ( values )
values = reversed ( values )
values = self . sequence . resolve ( context , True )
var , constant = match . group ( "var" , "constant" )
var += '0x'
var += '0x'
var += 'abc'
var += 'abc'
var += 'abc'
var += 'abc'
var += b"\x0a\x1b\x2c\x3d\x4e\x5f\x6a\x10\x56\x57\x68\x99\xa5"
var += b"\x0a\x1b\x2c\x3d\x4e\x5f\x6a\x10\x56\x57\x68\x99\xa5"
var += b"\x0a\x1b\x2c\x3d\x4e\x5f\x6a\x10\x56\x57\x68\x99\xa5"
var += b"\x5b\x37\x42\x01\xbd\x3c\x72\x7c\x02\x3d\x5f\xc1\xcf"
var += b"\x5b\x37\x42\x01\xbd\x3c\x72\x7c\x02\x3d\x5f\xc1\xcf"
var += b"\x5b\x37\x42\x01\xbd\x3c\x72\x7c\x02\x3d\x5f\xc1\xcf"
var += b"\x90\x4a\x5c\xf3\x1e\x81\x69\x14\x75\x72\xde\xac\x77"
var += b"\x90\x4a\x5c\xf3\x1e\x81\x69\x14\x75\x72\xde\xac\x77"
var += b"\x90\x4a\x5c\xf3\x1e\x81\x69\x14\x75\x72\xde\xac\x77"
var += b"\x99\xaf\xbb\xed\xbe\x46\x56\x4e\x88\x72\x53\x44\x68"
var += b"\x99\xaf\xbb\xed\xbe\x46\x56\x4e\x88\x72\x53\x44\x68"
var += b"\x99\xaf\xbb\xed\xbe\x46\x56\x4e\x88\x72\x53\x44\x68"
var += b"\xae\xf2\xc4\xbb\x03\x41\xcd\x8b\x52\x10\x8b\x4a\x3c"
var += b"\xae\xf2\xc4\xbb\x03\x41\xcd\x8b\x52\x10\x8b\x4a\x3c"
var += b"\xae\xf2\xc4\xbb\x03\x41\xcd\x8b\x52\x10\x8b\x4a\x3c"
var = 1
var = var [ 2 : - 1 ]
var_name = bits [ 5 ]
var_node = self . create_variable_node ( filter_expression )
var_obj = None
var_obj = Variable ( constant ) . resolve ( { } )
var_obj = Variable ( var )
var2 = int(hex(val2)[4:7],16)
var3 = int(hex(val3)[9:10],16)
var4 = int(hex(val4)[11:14],8)
var5 = int(hex(val5)[1:3],8)
var6 = int(hex(val6)[6:7],8)
VARIABLE_ATTRIBUTE_SEPARATOR = '.'
VARIABLE_TAG_END = '}}'
VARIABLE_TAG_START = '{{'
vary_headers = [ ]
vary_headers = cc_delim_re . split ( response [ 'Vary' ] )
vary_headers = cc_delim_re . split ( response [ 'Vary' ] )
vary_on = ( )
verbosity = options . get ( 'verbosity' )
verbosity = options . get ( 'verbosity' )
version = get_complete_version ( version )
version = get_complete_version ( version )
version = self . version
view = parts [ 0 ]
view = transaction . atomic ( using = db . alias ) ( view )
view = viewname
view_func = getattr ( mod , func_name )
view_name = callback . __class__ . __name__ + '.__call__'
view_name = callback . __name__
view_name = self . view_name . resolve ( context )
view_path = url_name or self . _func_path
viewname = parser . compile_filter ( bits [ 1 ] )
visible_issue_count += len ( issues )
w = self . choice_input_class ( self . name , self . value ,  self . attrs . copy ( ) , choice , i )
walk_to_end ( ch , pattern_iter )
want_unicode = False
want_unicode = True
warn_msg = ( "The translator-targeted comment '%s' "  "(%sline %d) was ignored, because it wasn't the last item "  "on the line." ) % ( c , filemsg , comment_lineno_cache )
warning = 'ImmutableList object is immutable.'
WARNING = 30
warning = kwargs [ 'warning' ]
warnings . simplefilter ( "default" , RemovedInNextVersionWarning )
warnings . warn (  '"requires_model_validation" is deprecated '  'in favor of "requires_system_checks".' ,  RemovedInDjango19Warning )
warnings . warn (  'import_by_path() has been deprecated. Use import_string() instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn (  'Reversing by dotted path is deprecated (%s).' % original_lookup ,  RemovedInDjango20Warning , stacklevel = 3  )
warnings . warn (  'Using SplitDateTimeWidget with DateTimeField is deprecated. '  'Use SplitDateTimeField instead.' ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn (  "`%s.%s` is deprecated, use `%s` instead." %  ( self . class_name , self . old_method_name , self . new_method_name ) ,  self . deprecation_warning , 2 )
warnings . warn (  "`%s.%s` method should be renamed `%s`." %  ( class_name , old_method_name , new_method_name ) ,  deprecation_warning , 2 )
warnings . warn (  "AppCommand.handle_app() is superseded by "  "AppCommand.handle_app_config()." ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn (  "django.utils.tzinfo will be removed in Django 1.9. "  "Use django.utils.timezone instead." ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn (  "django.utils.tzinfo.FixedOffset will be removed in Django 1.9. "  "Use django.utils.timezone.get_fixed_timezone instead." ,  RemovedInDjango19Warning )
warnings . warn (  "django.utils.tzinfo.LocalTimezone will be removed in Django 1.9. "  "Use django.utils.timezone.get_default_timezone instead." ,  RemovedInDjango19Warning )
warnings . warn (  "FastCGI support has been deprecated and will be removed in Django 1.9." ,  RemovedInDjango19Warning )
warnings . warn (  "get_declared_fields is deprecated and will be removed in Django 1.9." ,  RemovedInDjango19Warning ,  stacklevel = 2 ,  )
warnings . warn (  "Need {0} values to unpack in for loop; got {1}. "  "This will raise an exception in Django 2.0."  . format ( num_loopvars , len_item ) ,  RemovedInDjango20Warning )
warnings . warn (  "No fixture data found for '%s'. (File format may be "  "invalid.)" % fixture_name ,  RuntimeWarning  )
warnings . warn (  "NoArgsCommand class is deprecated and will be removed in Django 2.0. "  "Use BaseCommand instead, which takes no arguments by default." ,  RemovedInDjango20Warning  )
warnings . warn (  "SortedDict is deprecated and will be removed in Django 1.9." ,  RemovedInDjango19Warning , stacklevel = 2  )
warnings . warn (  "The django.forms.util module has been renamed. "  "Use django.forms.utils instead." , RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn ( '"validate" has been deprecated in favor of "check".' ,  RemovedInDjango19Warning )
warnings . warn ( '`MergeDict` is deprecated, use `dict.update()` '  'instead.' , RemovedInDjango19Warning , 2 )
warnings . warn ( '`request.REQUEST` is deprecated, use `request.GET` or '  '`request.POST` instead.' , RemovedInDjango19Warning , 2 )
warnings . warn ( 'A secure pseudo-random number generator is not available '  'on your system. Falling back to Mersenne Twister.' )
warnings . warn ( 'Cache key contains characters that will cause '  'errors if used with memcached: %r' % key ,  CacheKeyWarning )
warnings . warn ( 'Cache key will cause errors if used with memcached: '  '%s (longer than %s)' % ( key , MEMCACHE_MAX_KEY_LENGTH ) ,  CacheKeyWarning )
warnings . warn ( "'get_cache' is deprecated in favor of 'caches'." ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn ( "``--natural`` is deprecated; use ``--natural-foreign`` instead." ,  RemovedInDjango19Warning )
warnings . warn ( "``use_natural_keys`` is deprecated; use ``use_natural_foreign_keys`` instead." ,  RemovedInDjango19Warning )
warnings . warn ( "A {% csrf_token %} was used in a template, but the context did not provide the value.  This is usually caused by not using RequestContext." )
warnings . warn ( "cache_choices has been deprecated and will be "  "removed in Django 1.9." ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn ( "Custom SQL location '<app_label>/models/sql' is "  "deprecated, use '<app_label>/sql' instead." ,  RemovedInDjango19Warning )
warnings . warn ( "django.utils.dictconfig will be removed in Django 1.9." ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn ( "django.utils.importlib will be removed in Django 1.9." ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn ( "django.utils.unittest will be removed in Django 1.9." ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn ( "IPAddressField has been deprecated. Use GenericIPAddressField instead." ,  RemovedInDjango19Warning )
warnings . warn ( "memoize wrapper is deprecated and will be removed in "  "Django 1.9. Use django.utils.lru_cache instead." ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn ( "No fixture named '%s' found." % fixture_name )
warnings . warn ( "OptionParser usage for Django management commands "  "is deprecated, use ArgumentParser instead" ,  RemovedInDjango20Warning )
warnings . warn ( "resolve_variable() is deprecated. Use django.template."  "Variable(path).resolve(context) instead" ,  RemovedInDjango20Warning , stacklevel = 2 )
warnings . warn ( "The syncdb command will be removed in Django 1.9" , RemovedInDjango19Warning )
warnings . warn ( "Your TEMPLATE_LOADERS setting includes %r, but your Python installation doesn't support that type of template loading. Consider removing that line from TEMPLATE_LOADERS." % loader )
warnings . warn ( msg , RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn ( msg % ( language , _DJANGO_DEPRECATED_LOCALES [ language ] ) ,  RemovedInDjango19Warning , stacklevel = 2 )
warnings . warn ( warn_msg , TranslatorCommentWarning )
warnings = [ e for e in all_issues if checks . WARNING <= e . level < checks . ERROR and not e . is_silenced ( ) ]
week_number -= 1
week_number = 1
week_number = 52
week_number = 53
week_number = j // 7
week_number = None
weekday = self . data . weekday ( ) + 1
WEEKDAYS = {  0 : _ ( 'Monday' ) , 1 : _ ( 'Tuesday' ) , 2 : _ ( 'Wednesday' ) , 3 : _ ( 'Thursday' ) , 4 : _ ( 'Friday' ) ,  5 : _ ( 'Saturday' ) , 6 : _ ( 'Sunday' )  }
WEEKDAYS_ABBR = {  0 : _ ( 'Mon' ) , 1 : _ ( 'Tue' ) , 2 : _ ( 'Wed' ) , 3 : _ ( 'Thu' ) , 4 : _ ( 'Fri' ) ,  5 : _ ( 'Sat' ) , 6 : _ ( 'Sun' )  }
WEEKDAYS_REV = {  'monday' : 0 , 'tuesday' : 1 , 'wednesday' : 2 , 'thursday' : 3 , 'friday' : 4 ,  'saturday' : 5 , 'sunday' : 6  }
weight += 1
weight += 2
weight = 0
while '%s_%d' % ( new_name , num ) in used_column_names :
while '<' in value and '>' in value :
while ( i < num_existing ) and ( existing [ i ] [ : pflen ] == prefixed ) :
while 1 :
while 1 :
while b'\n' not in self . buffer and ( size is None or len ( self . buffer ) < size ) :
while bits :
while ch != '}' :
while ch != terminal_char :
while current_chunk != b'' :
while current_len <= length :
while end > 0 and s . count ( b'"' , 0 , end ) % 2 :
while escaped or ch != ']' :
while factor >= 0 :
while field . rel is not None :
while i < l :
while i < len ( subject ) and subject [ i ] != c :
while i < len ( subject ) and subject [ i ] != subject [ p ] :
while i < len ( subject ) and subject [ i ] in ( ' ' , '\t' ) :
while i < len ( subject ) and subject [ i ] in ( ' ' , '\t' ) :
while i < len ( subject ) and subject [ i ] not in ( ' ' , '\t' ) :
while i < list_length :
while k < endpos :
while len ( digits ) <= abs ( exponent ) :
while len ( line ) > max_width :
while model_dependencies :
while new_name . find ( '__' ) >= 0 :
while not answer or answer not in "yn" :
while not bit . endswith ( sentinal ) :
while path :
while rbp < self . current_token . lbp :
while remaining != 0 :
while remaining_bits :
while rest :
while RUN_RELOADER :
while s [ : 1 ] == b';' :
while self . exists ( name ) :
while self . tokens :
while start < end :
while t > 0 :
while token . contents . startswith ( 'elif' ) :
widget . attrs . update ( extra_attrs )
widget . input_type = 'hidden'
widget . is_localized = self . is_localized
widget . is_localized = True
widget . is_required = self . required
widget = CheckboxInput
widget = ClearableFileInput
widget = DateInput
widget = DateTimeInput
widget = EmailInput
widget = form . _meta . widgets . get ( self . _pk_field . name , HiddenInput )
widget = HiddenInput
widget = HiddenInput
widget = NullBooleanSelect
widget = NumberInput
widget = Select
widget = SelectMultiple
widget = self . field . widget
widget = SplitDateTimeWidget
widget = TextInput
widget = TimeInput
widget = URLInput
widget = widget ( )
widget = widget or self . widget
widget_value = None
widget_value = value [ i ]
widgets = ( DateInput ( attrs = attrs , format = date_format ) ,  TimeInput ( attrs = attrs , format = time_format ) )
width = property ( _get_width )
width = six . text_type ( len ( six . text_type ( len ( lines ) ) ) )
WindowsError = WindowsError
with Archive ( path ) as archive :
with codecs . open ( sql_file , 'r' , encoding = settings . FILE_CHARSET ) as fp :
with connection . constraint_checks_disabled ( ) :
with connection . cursor ( ) as curs :
with connection . cursor ( ) as cursor :
with connection . cursor ( ) as cursor :
with connection . cursor ( ) as cursor :
with connections [ db ] . cursor ( ) as cursor :
with context . push ( ) :
with context . push ( ) :
with context . push ( ** values ) :
with context . push ( ** values ) :
with context . push ( var = output ) :
with context_instance . push ( dictionary ) :
with io . open ( django_po , 'r' , encoding = 'utf-8' ) as fp :
with io . open ( fd , 'wb' ) as f :
with io . open ( fname , 'rb' ) as f :
with io . open ( fname , 'rb' ) as f :
with io . open ( orig_file , 'r' , encoding = settings . FILE_CHARSET ) as fp :
with io . open ( orig_file , encoding = settings . FILE_CHARSET ) as fp :
with io . open ( os . path . join ( self . dirpath , thefile ) , "w" , encoding = 'utf-8' ) as fp :
with io . open ( pofile , 'w' , encoding = 'utf-8' ) as fp :
with io . open ( potfile , 'a' , encoding = 'utf-8' ) as fp :
with io . open ( potfile , 'r' , encoding = 'utf-8' ) as fp :
with io . open ( potfile , 'w' , encoding = 'utf-8' ) as fp :
with io . open ( work_file , "w" , encoding = 'utf-8' ) as fp :
with lock :
with lock :
with open ( filename , 'wb' ) as outfile :
with open ( filepath , 'r' ) as fp :
with open ( filepath , 'rb' ) as fp :
with open ( fn , 'rb' ) as f :
with open ( new_path , 'wb' ) as new_file :
with open ( old_file_name , 'rb' ) as old_file :
with open ( old_path , 'rb' ) as template_file :
with open ( options [ "pidfile" ] , "w" ) as fp :
with open ( path , 'a' ) :
with open ( path , 'rb' ) as f :
with open ( pythonrc ) as handle :
with open ( writer . path , "wb" ) as fh :
with open ( writer . path , "wb" ) as fh :
with self . _lock :
with self . _lock :
with self . _lock . reader ( ) :
with self . _lock . writer ( ) :
with self . initLock :
with self . mutex :
with transaction . atomic ( using = connection . alias , savepoint = connection . features . can_rollback_ddl ) :
with transaction . atomic ( using = connection . alias , savepoint = connection . features . can_rollback_ddl ) :
with transaction . atomic ( using = connection . alias ) :
with transaction . atomic ( using = database ,  savepoint = connection . features . can_rollback_ddl ) :
with transaction . atomic ( using = database ,  savepoint = connection . features . can_rollback_ddl ) :
with transaction . atomic ( using = db ) :
with transaction . atomic ( using = self . using ) :
wm . add_watch ( path , mask )
wm = pyinotify . WatchManager ( )
WORD_PATTERN = re . compile ( r'^\s*(\w+)\s*' )
word_split_re = re . compile ( r'(\s+)' )
words [ i ] = escape ( word )
words [ i ] = mark_safe ( '%s%s%s' % ( lead , middle , trail ) )
words [ i ] = mark_safe ( word )
words = allow_lazy ( words )
words = self . _wrapped . split ( )
words = word_split_re . split ( force_text ( text ) )
words = words [ : length ]
work_file = os . path . join ( self . dirpath , thefile )
work_file = os . path . join ( self . dirpath , thefile )
wrap = allow_lazy ( wrap , six . text_type )
wrapped_callback = self . make_view_atomic ( callback )
wrapped_main_func = check_errors ( main_func )
wrapper . __wrapped__ = user_function
wrapper . cache_clear = cache_clear
wrapper . cache_info = cache_info
wrapper = warn_about_renamed_method ( class_name , * renamed_method )
WRAPPING_PUNCTUATION = [ ( '(' , ')' ) , ( '<' , '>' ) , ( '[' , ']' ) , ( '&lt;' , '&gt;' ) , ( '"' , '"' ) , ( '\'' , '\'' ) ]
write ( arg )
write ( end )
write ( sep )
write = property ( lambda self : self . file . write )
write_pot_file ( potfile , msgs )
writelines = property ( lambda self : self . file . writelines )
writer = MigrationWriter ( migration )
writer = MigrationWriter ( new_migration )
writer = MigrationWriter ( new_migration )
wsgi_opts [ 'bindAddress' ] = ( options [ "host" ] , int ( options [ "port" ] ) )
wsgi_opts [ 'bindAddress' ] = None
wsgi_opts [ 'bindAddress' ] = options [ "socket" ]
wsgi_opts [ 'debug' ] = options [ 'debug' ] is not None
wsgi_opts = {  'maxSpare' : int ( options [ "maxspare" ] ) ,  'minSpare' : int ( options [ "minspare" ] ) ,  'maxChildren' : int ( options [ "maxchildren" ] ) ,  'maxRequests' : int ( options [ "maxrequests" ] ) ,  }
wsgi_opts = {  'maxSpare' : int ( options [ "maxspare" ] ) ,  'minSpare' : int ( options [ "minspare" ] ) ,  'maxThreads' : int ( options [ "maxchildren" ] ) ,  }
WSGIServer ( get_internal_wsgi_application ( ) , ** wsgi_opts ) . run ( )
WSGIServer = module . WSGIServer
x += '%02x' % (a & 0xff)
x += '%02x' % (a & 0xff)
x += '%02x' % (a & 0xff)
x += '%02x' % (y & 0xff)
x += 1
x += 1
x += 10
x = 0
x = int ( x // len ( to_digits ) )
x = rol(x,rand)
x = x * len ( from_digits ) + from_digits . index ( digit )
x = x << nbits
x = x << nbits
x = x^0xDD
xgettext_options = [ '--from-code=UTF-8' , '--add-comments=Translators' ]
xor_byte = find_valid_xor_byte(chunk, bad_chars)
xor_rot = shell_rot^0xAA
xreadlines = property ( lambda self : self . file . xreadlines )
xxx = hex(int(abs(subfs)) - int(rev_suplx,16))
xxx = hex(int(abs(subfs)) - int(rev_suplx,16))
xxx = hex(int(abs(subfs)) % int(rev_suplx,16))
xxx = hex(int(abs(subfs)) + int(rev_suplx[0:2],16))
y += '%02x' % x
y = bytearray(shellcode)[0] & bytearray(shellcode)[1]
y = bytearray(shellcode)[0]^bytearray(shellcode)[1]
y = data . get ( self . year_field % name )
y = int(hopcode, 16)
y = x << nbits
y = x << nbits
y = x << nbits
yaml . dump ( self . objects , self . stream , Dumper = DjangoSafeDumper , ** self . options )
year += 1900
year += 2000
year = dt . year
year = int ( m . group ( 'year' ) )
year = year + ( ( 2000 - year ) // 28 ) * 28
year = year + off
year_days = [ None , 0 , 31 , 59 , 90 , 120 , 151 , 181 , 212 , 243 , 273 , 304 , 334 ]
year_field = '%s_year'
year_val , month_val , day_val = [ int ( v ) for v in match . groups ( ) ]
year_val , month_val , day_val = v . year , v . month , v . day
year_val , month_val , day_val = value . year , value . month , value . day
year_val = month_val = day_val = None
yes , no , maybe = bits
yes , no , maybe = bits [ 0 ] , bits [ 1 ] , bits [ 1 ]
yield
yield '    %s' % field_desc
yield ''
yield '%s\n' % line [ : space - 1 ]
yield 'class %s(models.Model):' % table2model ( table_name )
yield 'day'
yield 'from %s import models' % self . db_module
yield 'month'
yield 'year'
yield "#   * Make sure each model has one field with primary_key=True"
yield "#   * Rearrange models' order"
yield "#   * Remove `managed = False` lines if you wish to allow Django to create, modify, and delete the table"
yield "# Also note: You'll have to insert the output of 'django-admin.py sqlcustom [app_label]'"
yield "# Feel free to rename the models, but don't rename db_table values or field names."
yield "# into your database."
yield "# This is an auto-generated Django model module."
yield "# You'll have to do the following manually to clean this up:"
yield "#"
yield "from __future__ import unicode_literals"
yield ( "" , self . field . empty_label )
yield ( tok . name , toktext )
yield b'' . join ( self )
yield base . DeserializedObject ( obj , m2m_data )
yield bit . group ( 0 )
yield buf
yield buf . read ( )
yield buf . read ( )
yield buffer_
yield ch , False
yield choice
yield d
yield data
yield emitting
yield field , list ( ValidationError ( errors ) )
yield force_text ( message )
yield import_module ( '%s.formats' % ( location % loc ) )
yield item
yield k
yield key
yield key , self [ key ]
yield key , self [ key ]
yield line
yield line
yield meta_line
yield node
yield node
yield obj
yield obj
yield obj
yield parse_boundary_stream ( sub_stream , 1024 )
yield representative , True
yield safe_join ( template_dir , template_name )
yield self
yield self . choice ( obj )
yield self . read ( )
yield self [ key ]
yield self [ name ]
yield subnode
yield subwidget
yield SubWidget ( self , name , value , attrs , choices )
yield v
yield widget
z += '%02x,' % x
z += '%02x,' % x
z += '%02x,' % x
z += "a" + "b"
z += x[2:]
z = (x + y) % 64
z = new << shift
z = sys.argv[1]
z = sys.argv[5]
z = sys.argv[99]
z = z << shift
ZERO = timedelta ( 0 )
zfile . close ( )
zfile . close ( )
zfile . flush ( )
zfile . write ( item )
zfile . write ( s )
zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = buf )
zfile = GzipFile ( mode = 'wb' , compresslevel = 6 , fileobj = zbuf )
zipfile . ZipFile . __init__ ( self , * args , ** kwargs )