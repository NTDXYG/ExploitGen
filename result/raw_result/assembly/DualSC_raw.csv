"xor var0 , var0"
"mov var0 , 0"
var0 : \n jmp short var1
var0 : \n call [esp]
var0 : \n call [esp]
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
_ di : \n jmp short var0
"add al , var0"
"add al , 3"
"add byte [var1] , var0"
"add byte [var1] , var0"
"add var0 , 4 \n jnz decode"
"add var1 , var0"
"add var1 , var0"
"add var0 , 2"
"add var0 , 2"
call var0
call var0
call var0
call var0
var1 : \n call [esp]
var0 :
call var0
var0 : \n call function_1
var0 : \n call [esp]
var0 : \n call [esp]
var0 : \n call [esp]
call var0
call var0
var0 : \n call function_1
var0 : \n call [esp]
var0 : \n call function_1
var0 : \n call [esp]
var0 : \n call [esp]
var0 :
jne short decode \n jmp short decode
je var0
"cmp var0 , var1 \n je var2 \n jmp var3"
je shellcode
"cmp BYTE var1 , [esi] \n jne var0"
"cmp DWORD [var1] , var0"
var1 : \n inc var1
cycle
dec al \n jz shellcode
"sub var0 , 1"
"mov eax , 1"
var0 :
decode :
scasd
scasd
"mov eax , 4"
"mov eax , decode"
"var0 : \n sub BYTE [esi] , var3 \n jl var3"
"var0 : \n mov var1 , [esi]"
var0 : \n not byte [var1]
var0 : \n call [esp]
"var0 : \n xor byte [var1] , var2"
var0 : \n call [esp]
var0 :
var0 :
var0 :
 decoder var0
decoder :
decoder :
"xor var0 , var0"
 decoder :
var0 : \n pop var2
var0 : \n pop var1
"var0 : \n pop var1 \n mov var2 , var1"
var0 : \n call [esp]
"var0 : db var1 , 0x2f , 0x68 , 0x69 , 0x62 , 0x87 , 0x6e , 0xb0 , 0xe3 , 0xcd , 0x0b , 0x90 , 0x80"
var0 : db var1
jump to the label _read if the contents of the eax register is zero
var0 : db var1
var0 : db var1
var0 : db var1
"move the value 0x6d , 0x7a"
var0 : db var1
var0 : db var1
var0 : db var1
var0 :
var0 : \n jmp short esp
"test var0 , 0"
formatting :
"mov var1 , var0"
global var0
global var0
inc var0
inc var0 \n inc var0
inc var0 \n inc var0
inc var0 \n inc var0
inc var0
"lea var0 , [var0]"
inc var0
inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0
"lea esi , [esi+1]"
"lea esi , [esi+1]"
"mov var0 , byte [var0]"
inc var0 \n inc var0
inc esi \n inc esi
inc esi \n jmp short decode
var0 :
jmp decode
jmp short var0
"mov var0 , var0"
jmp short var0
jmp short cycle
jmp short decode
jmp short decode
jmp var0
"mov var0 , [var0]"
jmp short var0
jmp short var0
jmp short var0
jmp shellcode
jmp short var0
jz var0
"lea var1 , [var0]"
"lea var1 , [var0]"
"lea var1 , [var0]"
"lea var0 , [esi]"
"lea var1 , [var0]"
"lea var1 , [var0]"
"lea var1 , [var0]"
"sub esp , 1 \n jnz short var0 \n jmp short shellcode"
decrement ecx
loop decode
loop decode \n jmp short decode
loop decode \n jmp short decode \n jmp shellcode
loop decode \n jmp shellcode
loop decode \n jmp short decode
jns var0 \n jmp short decode
loop var2 \n jmp short var3
"mov eax , :"
"mov var0 , var0"
"mov [var0] , al"
"mov [var0] , al"
"xchg al , var0"
"mov al , byte [var0]"
"mov al , byte [var0]"
"mov al , byte [var0]"
"mov al , cl"
"mov al , dl"
"mov al , dl"
"mov ax , [var0]"
"mov ax , word [var0]"
"mov bh , var0"
push byte [var0]
"mov var0 , [esi]"
"mov var1 , var0"
"mov var1 , var0"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
push byte [var0]
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov [var1] , byte [var0]"
"mov var1 , byte [esi+3]"
"mov var0 , cl"
"mov var1 , [var0]"
"mov var0 , dl"
var0 : \n pop var1
"mov byte [var1] , bl"
"mov byte [var1] , var0"
"mov byte [var1] , var0"
"mov byte [var0] , dl"
"mov byte [var1] , bl"
"mov byte [var0] , dl"
"mov byte [var1] , bl"
"mov byte [eax] , cl"
"mov byte [eax] , bh"
"mov byte [var1] , bl"
"mov byte [esp+2] , 0x2"
"mov byte [var1] , bl"
"mov [var0] , byte [var0]"
"mov byte [var0] , 10"
"mov cl , 13"
"mov cl , al"
"mov cl , byte [var0]"
push byte [var0]
"mov cl , dl"
"mov dl , [var0]"
"mov dl , [esi]"
"mov esi , dl"
"mov dl , var0"
"mov dl , var0"
"mov dl , byte [var0]"
"mov dl , byte [var0]"
"mov dl , [var0]"
"mov dl , byte [var0]"
"mov dl , byte [var0]"
"mov var1 , var0"
"mov var1 , var0"
"mov var1 , var0"
"mov var0 , [esi]"
"mov var0 , esp"
"mov word [var0] , ax"
var0 : \n not dl \n inc dl
var0 : \n jmp short formatting
negate all
negate all
var0 :
var0 :
pop var0
pop var0
pop var0
pop var0
pop cx
push esp
"push var0 \n mov var1 , esp"
"mov eax , 1"
rol rotate the shellcode
"ror var0 , cl"
ror : \n call [esp]
section .text
var0 equ $-shellcode
var0 : \n call [esp]
var0 : db var1
var0 : db var1
var0 : db var1
"db 0x3e , 0xcd , 0x5d , 0x80"
var0 : db var1
var0 : db var1
var0 : db var1
"db 0x8b , 0x8"
var0 : db var1
var0 :
"shl var0 , 28"
"shl var0 , 28"
"xor ax , var0"
"shr ax , cl \n not word ax"
"shr var0 , 4"
"shr dl , 1"
"sar dl , 4"
"shr var0 , 0"
"shr var0 , 28"
var0 : \n call [esp]
"sub ax , 13"
"sub var0 , al"
"sub var0 , byte [esi]"
"sub byte [var0] , 8 \n not byte [var0]"
"sub cl , dl"
"sub dl , al \n jz var0"
"sub var1 , var0"
"sub var1 , var0"
"sub esp , var0"
var0 :
jmp var0
"xchg al , var0"
"xor al , var0 \n jz short var1"
"xor ax , var0"
"xor ax , var0"
"xor ax , var0 \n jz decoded_xor ax"
"xor byte [var0] , var2"
"xor var0 , var0 \n jnz var1"
"xor var0 , var0 \n jz var1"
"xor var0 , var0 \n mov cl , [esi]"
"xor var0 , var2"
"xor var0 , var0 \n jnz short var1"
"xor [var0] , var1"
"xor byte [var0] , var1"
"xor dl , dl \n xor byte [esi]"
"xor byte [var0] , dl"
"xor byte [var0] , dl"
"xor dl , dl \n xor byte [esi+1]"
"xor byte [var0] , var2"
"xor cl , var0 \n jz short var1"
"xor cl , var0 \n jnz var1"
"xor cl , var0 \n jz var0"
"xor cl , byte [var0]"
"xor dl , var0 \n jz var1"
"xor var0 , var0 \n mov al , var1"
"xor var0 , var0 \n mov al , 123"
"xor var0 , var0 \n mul var1"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"xor var0 , var0"
"xor var0 , var0"
"xor var0 , var0 \n mov bl , [esi+1]"
"xor var0 , var0 \n xor var1 , var1"
"xor var0 , var0"
"xor var0 , var0 \n mov cl , var1"
"xor var0 , var0 \n mov al , var1"
"xor var0 , var0 \n mov cl , 23"
"xor var0 , 25"
"xor byte [esi] , var0 \n jl var1"
"mov eax , 1"
"xor var1 , var1 \n jz var1"
"xor var0 , var0 \n mul var1"
"xor ebx , ebx \n mul ebx"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"xor var0 , ecx \n mov dl , [esi]"
var0 :
