var0 :
"mov eax , 106"
var0 : \n jmp short var1
var0 : \n jmp var1
var0 : \n jmp var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short esp
"add al , var0"
"add al , 3"
"add byte [var1] , var0"
"add byte [var1] , var0"
"add var0 , 4 \n jnz decode"
"add var1 , var0"
"add var1 , var0"
"add var0 , 2"
"add var0 , 2"
call var0
decoder :
call var0
call var0
var0 : \n call [esp]
var0 :
var0 :
var0 : \n call function_1
var0 : \n call [var2]
var0 : \n dec var0
"var0 : \n call [var2] , var3"
call var0
"mov eax , 19"
var0 : \n call [var2]
var0 :
var0 : \n call function_1
var0 : \n call [esp]
var0 : \n call [esp]
var0 :
"cmp al , cl \n jne short decode \n jmp shellcode"
"cmp var0 , var1 \n je shellcode"
"cmp var1 , var2 \n je var0 \n jmp var3"
"cmp byte [var0] , var1 \n jmp shellcode"
jne short var0
cmp dword var2 \n je var0
var0 : inc var1
cycle :
dec al \n jz shellcode
"sub var0 , 1"
"mov eax , 106"
call var0
decode :
decode :
call var0
"mov eax , 19"
decode :
"var0 : \n cmp byte [esi] , var2 \n jl var1 \n jmp var2"
dec byte [var0]
var0 : \n not byte [var1]
var0 : \n not byte [esi]
"var0 : \n xor byte [var1] , var2"
var0 : \n call [esp]
var0 :
var0 :
call var0
"mov eax , 19"
decoder :
decoder :
decode :
decoder :
var0 : \n pop var1
var0 : \n pop var1
"pop var0 \n mov var1 , var1"
var0 :
var0 : db var1
var0 : db var1
pop var0
message : db var0
var0 : db var1
var0 : db var1
var0 : db var1
var0 : db var1
var0 : db var1
var0 : db var1
var0 :
var0 : \n jmp short esp
var0 :
formatting :
call var0
global var0
global var0
inc var0
inc var0
inc var0
inc var0
inc var0
inc var0
inc var0
inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0
inc esi \n inc esi
inc esi \n inc esi
inc var0
inc var0 \n inc var0
inc esi \n inc esi
inc esi \n jmp short decode
var0 :
jmp decode
jmp short var0
"mov eax , 19"
jmp short var0
jmp short cycle
jmp short decode
jmp short decode
jmp decode
"lea var1 , [var0]"
jmp short var0
jmp short var0
jmp short setup
"mov eax , 19"
jmp short shell
jz short var0
"lea edi , [var0]"
"lea var1 , [var0]"
"lea var1 , [var0]"
"lea var0 , [esi]"
"lea var1 , [var0]"
"lea var1 , [var0]"
"lea edi , [var0]"
loop var0 \n jmp short shellcode
loop decode
loopnz decode \n jmp var0
loop var2 \n jmp short decode
loop var0 \n jmp short shellcode
loop var0 \n jmp shellcode
loop decrypt \n jmp short decode
loopnz short decode \n jmp shellcode
loop var2 \n jmp var0
var0 :
call var0
"mov var0 , al"
"mov var0 , al"
"xchg var0 , al"
"mov al , byte var0"
"mov al , byte var0"
"mov al , byte var0"
"mov cl , al"
"mov al , dl"
"mov dl , al"
"mov ax , [var0]"
var1 : dw var1
"mov bh , var0"
"mov var0 , bh"
"mov var0 , byte [esi]"
"mov var1 , var0"
"mov var1 , var0"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov byte [var1] , var0 \n mov var3"
"mov byte [esi+3] , 0x7"
"mov var0 , cl"
"mov var1 , [var0]"
"mov byte [var0] , dl"
"mov var1 , var0"
"mov byte [var1] , var0 \n not byte [var1]"
"mov byte [var1] , var0"
"mov byte [var0] , var1"
"mov byte [var1] , dl"
"mov byte [var0] , var1"
"mov byte [var0] , dl"
"mov byte [var0] , var1"
"mov cl , [var0]"
"mov byte [var2] , bh"
"mov byte [var0] , var1"
"mov byte [esp] , var0"
"mov byte [var0] , var1"
"mov var1 , byte [var0]"
mov byte 10
"mov cl , 13"
"mov cl , al"
"mov cl , byte [var0]"
"mov cl , byte [var0]"
"mov cl , dl"
"mov dl , var0"
"mov dl , byte [esi+1]"
"mov dl , [esi+1]"
"mov dl , var0"
"mov dl , var0"
"mov dl , byte var0"
"mov dl , byte var0"
"mov dl , var0"
"mov dl , byte var0"
"mov dl , byte [var0]"
"mov var1 , var0"
"mov var1 , var0"
"mov var1 , var0"
"mov var0 , [esp]"
"mov var0 , esp"
"mov var0 , word ax"
var0 : \n not dl \n inc dl
inc var0 \n jmp short var1
nop
var0 :
call var0
var0 :
pop var0
pop var0
pop var0
pop var0
"pop var0 \n mov var0 , [var0]"
push byte [esp]
"push var0 \n mov var1 , esp"
var0 :
"rol var0 , 1"
"ror cl , var0"
"ror var0 , 1"
section .text
var0 equ $-shellcode
var0 : \n pop var0
shellcode : db var0
shellcode : db var0
"test var0 , var0"
var0 : db var1
shellcode : db var0
pop var0
pop var0
var0 : db var1
shellcode : db var0
var0 :
"shl var0 , 28"
"shl var0 , 28"
"shr ax , 1"
"shr ax , cl \n not word ax"
"shr var0 , 4"
"shr dl , 1"
"shr dl , 4"
"shr var0 , 24"
"shr var0 , 28"
global var0
"sub ax , 13"
"sub al , var0"
"sub byte [esi] , var0"
"sub byte [var0] , 8 \n not byte [var0]"
"sub dl , cl"
"sub dl , var0"
"sub var1 , var0"
"sub var0 , var0"
"sub esp , var0"
var0 :
jle var1
"xor al , var1"
"xor al , var0 \n jz short var0"
"xor ax , var0"
"xor ax , var0"
"xor ax , var0 \n jz close"
"xor byte [var0] , bh"
"xor var0 , var0 \n jnz var2"
"xor var0 , var1 \n jz var2"
"xor var0 , var0 \n jz short var1"
"xor byte [var0] , var1"
"xor dl , var0 \n jnz short var1"
"xor byte [var0] , var1"
"xor byte [var0] , var1"
"xor dl , byte [esi]"
"xor dl , byte [var0]"
"xor dl , byte [var0]"
"xor dl , var0"
"xor byte [var0] , var1"
"xor cl , var0 \n jz short var1"
"xor cl , var0 \n jnz var2"
"xor cl , var0 \n jz short var0"
"xor byte [var0] , cl"
"xor dl , var0 \n jz var2"
"xor var0 , var0 \n mov cl , var1"
"xor var0 , var0 \n mov bl , 15"
"xor var1 , var1 \n mul var1"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var2 , var2"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"xor var0 , var0"
"xor var0 , var0"
"xor var0 , var0 \n mov bl , [esi+1]"
"xor var1 , var1 \n mul var1"
"xor var0 , var0"
"xor var0 , var0 \n mov dl , var1"
"xor var0 , var0 \n mov cl , var0"
"xor var0 , var0 \n mov bl , 23"
"xor var0 , var0 \n mov bl , 25"
"xor var0 , var0 \n mov cl , var0"
"xor var0 , var0 \n xor var1 , var1 \n xor var1 , var1"
"xor var1 , var1 \n mul var1"
"xor var1 , var1 \n mul var1"
"xor ebx , ebx \n mul ebx"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"xor var0 , var0 \n mov cl , [esi+1]"
var0 :
